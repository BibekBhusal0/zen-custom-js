import fs from "fs";
import path from "path";
import { spawn } from "child_process";

const getSubdirectories = (dir) => {
  return fs.readdirSync(dir).filter((file) => {
    const fullPath = path.join(dir, file);
    return (
      fs.statSync(fullPath).isDirectory() &&
      !file.startsWith(".") &&
      file !== "node_modules" &&
      file !== "dist"
    );
  });
};

const fixBrowseBotImports = () => {
  const mainFile = "./dist/browse-bot.uc.mjs";
  if (fs.existsSync(mainFile)) {
    const orignal_content = fs.readFileSync(mainFile, "utf-8");

    const modules = ['@ai-sdk\\/[^"]*', "ai", "zod", "ollama-ai-provider-v2"];

    let content = orignal_content;
    for (const mod of modules) {
      content = content.replace(
        new RegExp('import\\s*\\{\\s*([^}]+)\\s*\\}\\s*from\\s*"' + mod + '"\\s*;', "g"),
        'import { $1} from "./vercel-ai-sdk.uc.mjs";'
      );
    }

    if (orignal_content !== content) fs.writeFileSync(mainFile, content);
  }
};

const createBanner = (themePath) => {
  const theme = JSON.parse(fs.readFileSync(themePath, "utf-8"));

  let banner = `// ==UserScript==
// @name            ${theme.name}
// @description     ${theme.description}
// @author          ${theme.author}
// @version         ${theme.version}
// @lastUpdated     ${theme.updatedAt}
`;

  if (theme.ignoreCache !== false) {
    banner += `// @ignorecache\n`;
  }

  const standardKeys = [
    "id",
    "name",
    "description",
    "author",
    "version",
    "updatedAt",
    "tags",
    "fork",
    "preferences",
    "style",
    "scripts",
    "readme",
    "image",
    "createdAt",
    "ignoreCache",
  ];

  for (const key in theme) {
    if (!standardKeys.includes(key)) {
      const value = theme[key];
      if (Array.isArray(value)) {
        value.forEach((item) => {
          banner += `// @${key.padEnd(15)} ${item}\n`;
        });
      } else if (typeof value === "boolean") {
        if (value) banner += `// @${key}\n`;
      } else {
        banner += `// @${key.padEnd(15)} ${value}\n`;
      }
    }
  }

  banner += `// ==/UserScript==

// This file was automatically generated. Do not edit this file directly.
// Any changes made here will be overwritten.
// To make changes, please edit the source files in the repository:
// https://github.com/BibekBhusal0/zen-custom-js

`;

  return banner;
};

function buildMod(themePath, entryFile, theme, isWatch = false) {
  console.log(`[buildMod] Building mod: ${theme.id}`);
  console.log(`[buildMod] Theme Path: ${themePath}`);
  console.log(`[buildMod] Entry File: ${entryFile}`);
  const banner = createBanner(themePath);

  if (theme.id === "browse-bot") {
    const externalPackages = ["@ai-sdk/*", "ai", "zod", "ollama-ai-provider-v2"];

    // Build main entry with vendor packages as external
    const mainArgs = [
      "build",
      entryFile,
      "--outdir",
      "./dist",
      "--format",
      "esm",
      "--target",
      "browser",
      "--entry-naming",
      "browse-bot.uc.mjs",
      "--banner",
      banner,
      "--minify-syntax",
    ];

    externalPackages.forEach((pkg) => mainArgs.push("--external", pkg));
    console.log(`[buildMod] BrowseBot mainArgs: ${mainArgs.join(" ")}`);

    // Build vendor bundle
    const vendorArgs = [
      "build",
      "./findbar-ai/vendor-entry.js",
      "--outdir",
      "./dist",
      "--format",
      "esm",
      "--target",
      "browser",
      "--entry-naming",
      "vercel-ai-sdk.uc.mjs",
      "--minify-syntax",
    ];
    console.log(`[buildMod] BrowseBot vendorArgs: ${vendorArgs.join(" ")}`);

    if (isWatch) {
      mainArgs.push("--watch");
      vendorArgs.push("--watch");
      spawn("bun", vendorArgs, { stdio: "inherit" });
      const mainChild = spawn("bun", mainArgs, { stdio: "inherit" });

      mainChild.on("spawn", () => {
        setTimeout(() => fixBrowseBotImports(), 1000);
      });
      return;
    } else {
      const mainChild = spawn("bun", mainArgs, { stdio: "inherit" });
      const vendorChild = spawn("bun", vendorArgs, { stdio: "inherit" });

      return new Promise((resolve, reject) => {
        let mainDone = false;
        let vendorDone = false;

        mainChild.on("close", () => {
          fixBrowseBotImports();
          mainDone = true;
          if (mainDone && vendorDone) resolve();
        });

        vendorChild.on("close", () => {
          vendorDone = true;
          if (mainDone && vendorDone) resolve();
        });

        mainChild.on("error", reject);
        vendorChild.on("error", reject);
      });
    }
  }

  const args = [
    "build",
    entryFile,
    "--outdir",
    "./dist",
    "--format",
    "iife",
    "--target",
    "browser",
    "--entry-naming",
    `${theme.id}.uc.js`,
    "--banner",
    banner,
    "--minify-syntax",
  ];

  if (isWatch) args.push("--watch");

  const child = spawn("bun", args, { stdio: "inherit" });

  return new Promise((resolve, reject) => {
    child.on("close", (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(`Build failed with code ${code}`));
      }
    });

    child.on("error", reject);
  });
}

async function build() {
  const target = process.env.TARGET;
  console.log(`[build.js] TARGET: ${target}`);
  const isWatch = process.argv.includes("--watch");

  // For watch mode without target, only build browse-bot
  if (isWatch && !target) {
    const browseBotTheme = JSON.parse(fs.readFileSync("findbar-ai/theme.json", "utf-8"));
    const browseBotEntry = "findbar-ai/index.js";

    buildMod("findbar-ai/theme.json", browseBotEntry, browseBotTheme, true);
    return;
  }

  const mods = getSubdirectories(process.cwd());
  let modsToBuild = mods;
  if (target) {
    modsToBuild = mods.filter((dir) => {
      const themePath = path.join(dir, "theme.json");
      if (!fs.existsSync(themePath)) return false;

      const theme = JSON.parse(fs.readFileSync(themePath, "utf-8"));
      const normalizedTarget = target.replace(/-/g, "");
      const normalizedThemeId = theme.id.replace(/-/g, "");
      return normalizedThemeId.includes(normalizedTarget);
    });
  }

  // Build each mod
  for (const dir of modsToBuild) {
    const themePath = path.join(dir, "theme.json");
    const entryFile = path.join(dir, "index.js");

    if (!fs.existsSync(themePath) || !fs.existsSync(entryFile)) {
      continue;
    }

    const theme = JSON.parse(fs.readFileSync(themePath, "utf-8"));
    if (!theme.scripts) continue;

    await buildMod(themePath, entryFile, theme, isWatch);
  }
}

build().catch(() => {
  process.exit(1);
});
