// ==UserScript==
// @name            Browse Bot
// @description     Transforms the standard Zen Browser findbar into a modern, floating, AI-powered chat interface. Inspired by Arc Browser.
// @author          Bibek Bhusal
// @version         2.5.83b
// @lastUpdated     2026-02-06
// @ignorecache
// @homepage        https://github.com/Vertex-Mods/Browse-Bot
// ==/UserScript==

// This file was automatically generated. Do not edit this file directly.
// Any changes made here will be overwritten.
// To make changes, please edit the source files in the repository:
// https://github.com/BibekBhusal0/zen-custom-js


// findbar-ai/llm/index.js
import { streamText, generateText, Output, stepCountIs } from "./vercel-ai-sdk.uc.mjs";

// utils/pref.js
function setPref(key, value) {
  try {
    let prefService = Services.prefs;
    if (typeof value === "boolean")
      prefService.setBoolPref(key, value);
    else if (typeof value === "number")
      prefService.setIntPref(key, value);
    else
      prefService.setStringPref(key, value);
  } catch {}
}
var getPref = (key, defaultValue) => {
  try {
    let prefService = Services.prefs;
    if (prefService.prefHasUserValue(key))
      switch (prefService.getPrefType(key)) {
        case prefService.PREF_STRING:
          return prefService.getStringPref(key);
        case prefService.PREF_INT:
          return prefService.getIntPref(key);
        case prefService.PREF_BOOL:
          return prefService.getBoolPref(key);
      }
  } catch {
    return defaultValue;
  }
  return defaultValue;
}, setPrefIfUnset = (key, value) => {
  if (Services.prefs.getPrefType(key) === 0)
    setPref(key, value);
}, resetPref = (key) => {
  if (Services.prefs.getPrefType(key) !== 0)
    Services.prefs.clearUserPref(key);
};
function addPrefListener(name, callback) {
  let modified_callback = () => {
    callback({ value: getPref(name) });
  };
  return Services.prefs.addObserver(name, modified_callback), { name, callback };
}
function removePrefListener(listener) {
  if (listener && listener.name && listener.callback)
    Services.prefs.removeObserver(listener.name, listener.callback);
}

class PREFS {
  static MOD_NAME = "BasePrefs";
  static DEBUG_MODE = "";
  static defaultValues = {};
  static getPref(key, defaultValue = void 0) {
    let defaultVal = defaultValue !== void 0 ? defaultValue : this.defaultValues[key];
    return getPref(key, defaultVal);
  }
  static setPref(prefKey, value) {
    setPref(prefKey, value);
  }
  static setInitialPrefs() {
    for (let [key, value] of Object.entries(this.defaultValues))
      setPrefIfUnset(key, value);
  }
  static get debugMode() {
    if (!this.DEBUG_MODE)
      return !1;
    return this.getPref(this.DEBUG_MODE);
  }
  static set debugMode(value) {
    if (!this.DEBUG_MODE)
      return;
    this.setPref(this.DEBUG_MODE, value);
  }
  static debugLog(...args) {
    if (this.debugMode)
      console.log(`${this.MOD_NAME}:`, ...args);
  }
  static debugError(...args) {
    if (this.debugMode)
      console.error(`${this.MOD_NAME}:`, ...args);
  }
}

// findbar-ai/utils/prefs.js
class BrowseBotPREFS extends PREFS {
  static MOD_NAME = "BrowseBot";
  static DEBUG_MODE = "extension.browse-bot.debug-mode";
  static ENABLED = "extension.browse-bot.findbar-ai.enabled";
  static MINIMAL = "extension.browse-bot.findbar-ai.minimal";
  static PERSIST = "extension.browse-bot.findbar-ai.persist-chat";
  static DND_ENABLED = "extension.browse-bot.findbar-ai.dnd-enabled";
  static POSITION = "extension.browse-bot.findbar-ai.position";
  static REMEMBER_DIMENSIONS = "extension.browse-bot.findbar-ai.remember-dimensions";
  static WIDTH = "extension.browse-bot.findbar-ai.width";
  static STREAM_ENABLED = "extension.browse-bot.findbar-ai.stream-enabled";
  static AGENTIC_MODE = "extension.browse-bot.findbar-ai.agentic-mode";
  static CITATIONS_ENABLED = "extension.browse-bot.findbar-ai.citations-enabled";
  static MAX_TOOL_CALLS = "extension.browse-bot.findbar-ai.max-tool-calls";
  static CONFORMATION = "extension.browse-bot.findbar-ai.conform-before-tool-call";
  static CONTEXT_MENU_ENABLED = "extension.browse-bot.findbar-ai.context-menu-enabled";
  static CONTEXT_MENU_AUTOSEND = "extension.browse-bot.findbar-ai.context-menu-autosend";
  static CONTEXT_MENU_COMMAND_WITH_SELECTION = "extension.browse-bot.findbar-ai.context-menu-command-with-selection";
  static CONTEXT_MENU_COMMAND_NO_SELECTION = "extension.browse-bot.findbar-ai.context-menu-command-no-selection";
  static BACKGROUND_STYLE = "extension.browse-bot.findbar-ai.background-style";
  static CUSTOM_SYSTEM_PROMPT = "extension.browse-bot.custom-system-prompt";
  static SHORTCUT_FINDBAR = "extension.browse-bot.findbar-ai.shortcut-findbar";
  static SHORTCUT_URLBAR = "extension.browse-bot.urlbar-ai.shortcut-urlbar";
  static URLBAR_AI_ENABLED = "extension.browse-bot.urlbar-ai-enabled";
  static URLBAR_AI_HIDE_SUGGESTIONS = "extension.browse-bot.urlbar-ai.hide-suggestions";
  static URLBAR_AI_ANIMATIONS_ENABLED = "extension.browse-bot.urlbar-ai.animations-enabled";
  static SOLID_BG = "extension.browse-bot.solid-bg";
  static LLM_PROVIDER = "extension.browse-bot.llm-provider";
  static MISTRAL_API_KEY = "extension.browse-bot.mistral-api-key";
  static MISTRAL_MODEL = "extension.browse-bot.mistral-model";
  static GEMINI_API_KEY = "extension.browse-bot.gemini-api-key";
  static GEMINI_MODEL = "extension.browse-bot.gemini-model";
  static OPENAI_API_KEY = "extension.browse-bot.openai-api-key";
  static OPENAI_MODEL = "extension.browse-bot.openai-model";
  static CLAUDE_API_KEY = "extension.browse-bot.claude-api-key";
  static CLAUDE_MODEL = "extension.browse-bot.claude-model";
  static GROK_API_KEY = "extension.browse-bot.grok-api-key";
  static GROK_MODEL = "extension.browse-bot.grok-model";
  static PERPLEXITY_API_KEY = "extension.browse-bot.perplexity-api-key";
  static PERPLEXITY_MODEL = "extension.browse-bot.perplexity-model";
  static CEREBRAS_API_KEY = "extension.browse-bot.cerebras-api-key";
  static CEREBRAS_MODEL = "extension.browse-bot.cerebras-model";
  static OLLAMA_MODEL = "extension.browse-bot.ollama-model";
  static OLLAMA_BASE_URL = "extension.browse-bot.ollama-base-url";
  static LLM_TEMPERATURE = "extension.browse-bot.llm.temperature";
  static LLM_TOP_P = "extension.browse-bot.llm.top-p";
  static LLM_TOP_K = "extension.browse-bot.llm.top-k";
  static LLM_FREQUENCY_PENALTY = "extension.browse-bot.llm.frequency-penalty";
  static LLM_PRESENCE_PENALTY = "extension.browse-bot.llm.presence-penalty";
  static LLM_MAX_OUTPUT_TOKENS = "extension.browse-bot.llm.max-output-tokens";
  static defaultValues = {
    [BrowseBotPREFS.ENABLED]: !0,
    [BrowseBotPREFS.URLBAR_AI_ENABLED]: !0,
    [BrowseBotPREFS.URLBAR_AI_HIDE_SUGGESTIONS]: !0,
    [BrowseBotPREFS.URLBAR_AI_ANIMATIONS_ENABLED]: !0,
    [BrowseBotPREFS.MINIMAL]: !0,
    [BrowseBotPREFS.AGENTIC_MODE]: !1,
    [BrowseBotPREFS.DEBUG_MODE]: !1,
    [BrowseBotPREFS.PERSIST]: !1,
    [BrowseBotPREFS.STREAM_ENABLED]: !0,
    [BrowseBotPREFS.CITATIONS_ENABLED]: !1,
    [BrowseBotPREFS.CONTEXT_MENU_ENABLED]: !0,
    [BrowseBotPREFS.CONTEXT_MENU_AUTOSEND]: !0,
    [BrowseBotPREFS.CONTEXT_MENU_COMMAND_NO_SELECTION]: "Summarize current page",
    [BrowseBotPREFS.CONTEXT_MENU_COMMAND_WITH_SELECTION]: `Explain this in context of current page:

{selection}`,
    [BrowseBotPREFS.LLM_PROVIDER]: "gemini",
    [BrowseBotPREFS.MISTRAL_API_KEY]: "",
    [BrowseBotPREFS.MISTRAL_MODEL]: "mistral-medium-latest",
    [BrowseBotPREFS.GEMINI_API_KEY]: "",
    [BrowseBotPREFS.GEMINI_MODEL]: "gemini-2.5-flash",
    [BrowseBotPREFS.OPENAI_API_KEY]: "",
    [BrowseBotPREFS.OPENAI_MODEL]: "gpt-5.2",
    [BrowseBotPREFS.CLAUDE_API_KEY]: "",
    [BrowseBotPREFS.CLAUDE_MODEL]: "claude-4-opus",
    [BrowseBotPREFS.GROK_API_KEY]: "",
    [BrowseBotPREFS.GROK_MODEL]: "grok-4",
    [BrowseBotPREFS.PERPLEXITY_API_KEY]: "",
    [BrowseBotPREFS.PERPLEXITY_MODEL]: "sonar",
    [BrowseBotPREFS.CEREBRAS_API_KEY]: "",
    [BrowseBotPREFS.CEREBRAS_MODEL]: "llama3.1-8b",
    [BrowseBotPREFS.OLLAMA_MODEL]: "llama2",
    [BrowseBotPREFS.OLLAMA_BASE_URL]: "http://localhost:11434/api",
    [BrowseBotPREFS.DND_ENABLED]: !0,
    [BrowseBotPREFS.POSITION]: "top-right",
    [BrowseBotPREFS.REMEMBER_DIMENSIONS]: !0,
    [BrowseBotPREFS.WIDTH]: 500,
    [BrowseBotPREFS.MAX_TOOL_CALLS]: 5,
    [BrowseBotPREFS.CONFORMATION]: !0,
    [BrowseBotPREFS.BACKGROUND_STYLE]: "solid",
    [BrowseBotPREFS.SHORTCUT_FINDBAR]: "ctrl+shift+f",
    [BrowseBotPREFS.SHORTCUT_URLBAR]: "ctrl+space",
    [BrowseBotPREFS.CUSTOM_SYSTEM_PROMPT]: "",
    [BrowseBotPREFS.LLM_TEMPERATURE]: 0.7,
    [BrowseBotPREFS.LLM_TOP_P]: 1,
    [BrowseBotPREFS.LLM_TOP_K]: 40,
    [BrowseBotPREFS.LLM_FREQUENCY_PENALTY]: 0,
    [BrowseBotPREFS.LLM_PRESENCE_PENALTY]: 0,
    [BrowseBotPREFS.LLM_MAX_OUTPUT_TOKENS]: 2048
  };
  setInitialPrefs() {
    this.migratePrefs(), super.setInitialPrefs();
  }
  static migratePrefs() {
    let migrationMap = {
      "extension.browse-bot.enabled": this.ENABLED,
      "extension.browse-bot.minimal": this.MINIMAL,
      "extension.browse-bot.persist-chat": this.PERSIST,
      "extension.browse-bot.dnd-enabled": this.DND_ENABLED,
      "extension.browse-bot.position": this.POSITION,
      "extension.browse-bot.stream-enabled": this.STREAM_ENABLED,
      "extension.browse-bot.god-mode": this.AGENTIC_MODE,
      "extension.browse-bot.findbar-god-mode": this.AGENTIC_MODE,
      "extension.browse-bot.citations-enabled": this.CITATIONS_ENABLED,
      "extension.browse-bot.max-tool-calls": this.MAX_TOOL_CALLS,
      "extension.browse-bot.conform-before-tool-call": this.CONFORMATION,
      "extension.browse-bot.context-menu-enabled": this.CONTEXT_MENU_ENABLED,
      "extension.browse-bot.context-menu-autosend": this.CONTEXT_MENU_AUTOSEND
    };
    for (let [oldKey, newKey] of Object.entries(migrationMap))
      try {
        let oldPref = this.getPref(oldKey);
        if (oldPref != null) {
          let value = oldPref;
          this.debugLog(`Migrating pref ${oldKey} to ${newKey} with value: ${value}`), this.setPref(newKey, value), resetPref(oldPref);
        }
      } catch (e) {
        this.debugError(`Could not migrate pref ${oldKey}:`, e);
      }
  }
  static get enabled() {
    return this.getPref(this.ENABLED);
  }
  static set enabled(value) {
    this.setPref(this.ENABLED, value);
  }
  static get minimal() {
    return this.getPref(this.MINIMAL);
  }
  static set minimal(value) {
    this.setPref(this.MINIMAL, value);
  }
  static get streamEnabled() {
    return this.getPref(this.STREAM_ENABLED);
  }
  static set streamEnabled(value) {
    this.setPref(this.STREAM_ENABLED, value);
  }
  static set agenticMode(value) {
    this.setPref(this.AGENTIC_MODE, value);
  }
  static get agenticMode() {
    return this.getPref(this.AGENTIC_MODE);
  }
  static get citationsEnabled() {
    return this.getPref(this.CITATIONS_ENABLED);
  }
  static set citationsEnabled(value) {
    this.setPref(this.CITATIONS_ENABLED, value);
  }
  static get contextMenuEnabled() {
    return this.getPref(this.CONTEXT_MENU_ENABLED);
  }
  static set contextMenuEnabled(value) {
    this.setPref(this.CONTEXT_MENU_ENABLED, value);
  }
  static get contextMenuAutoSend() {
    return this.getPref(this.CONTEXT_MENU_AUTOSEND);
  }
  static set contextMenuAutoSend(value) {
    this.setPref(this.CONTEXT_MENU_AUTOSEND, value);
  }
  static get contextMenuCommandWithSelection() {
    return this.getPref(this.CONTEXT_MENU_COMMAND_WITH_SELECTION);
  }
  static set contextMenuCommandWithSelection(value) {
    this.setPref(this.CONTEXT_MENU_COMMAND_WITH_SELECTION, value);
  }
  static get contextMenuCommandNoSelection() {
    return this.getPref(this.CONTEXT_MENU_COMMAND_NO_SELECTION);
  }
  static set contextMenuCommandNoSelection(value) {
    this.setPref(this.CONTEXT_MENU_COMMAND_NO_SELECTION, value);
  }
  static get llmProvider() {
    return this.getPref(this.LLM_PROVIDER);
  }
  static set llmProvider(value) {
    this.setPref(this.LLM_PROVIDER, value);
  }
  static get persistChat() {
    return this.getPref(this.PERSIST);
  }
  static set persistChat(value) {
    this.setPref(this.PERSIST, value);
  }
  static get backgroundStyle() {
    return this.getPref(this.BACKGROUND_STYLE);
  }
  static get pseudoBg() {
    return this.backgroundStyle === "pseudo";
  }
  static get maxToolCalls() {
    return this.getPref(this.MAX_TOOL_CALLS);
  }
  static set maxToolCalls(value) {
    this.setPref(this.MAX_TOOL_CALLS, value);
  }
  static get conformation() {
    return this.getPref(this.CONFORMATION);
  }
  static set conformation(value) {
    this.setPref(this.CONFORMATION, value);
  }
  static get dndEnabled() {
    return this.getPref(this.DND_ENABLED);
  }
  static set dndEnabled(value) {
    this.setPref(this.DND_ENABLED, value);
  }
  static get position() {
    return this.getPref(this.POSITION);
  }
  static set position(value) {
    this.setPref(this.POSITION, value);
  }
  static get rememberDimensions() {
    return this.getPref(this.REMEMBER_DIMENSIONS);
  }
  static set rememberDimensions(value) {
    this.setPref(this.REMEMBER_DIMENSIONS, value);
  }
  static get width() {
    return this.getPref(this.WIDTH);
  }
  static set width(value) {
    this.setPref(this.WIDTH, value);
  }
  static get ollamaBaseUrl() {
    return this.getPref(this.OLLAMA_BASE_URL);
  }
  static set ollamaBaseUrl(value) {
    this.setPref(this.OLLAMA_BASE_URL, value);
  }
  static get llmTemperature() {
    return this.getPref(this.LLM_TEMPERATURE);
  }
  static set llmTemperature(value) {
    this.setPref(this.LLM_TEMPERATURE, value);
  }
  static get llmTopP() {
    return this.getPref(this.LLM_TOP_P);
  }
  static set llmTopP(value) {
    this.setPref(this.LLM_TOP_P, value);
  }
  static get llmTopK() {
    return this.getPref(this.LLM_TOP_K);
  }
  static set llmTopK(value) {
    this.setPref(this.LLM_TOP_K, value);
  }
  static get llmFrequencyPenalty() {
    return this.getPref(this.LLM_FREQUENCY_PENALTY);
  }
  static set llmFrequencyPenalty(value) {
    this.setPref(this.LLM_FREQUENCY_PENALTY, value);
  }
  static get llmPresencePenalty() {
    return this.getPref(this.LLM_PRESENCE_PENALTY);
  }
  static set llmPresencePenalty(value) {
    this.setPref(this.LLM_PRESENCE_PENALTY, value);
  }
  static get llmMaxOutputTokens() {
    return this.getPref(this.LLM_MAX_OUTPUT_TOKENS);
  }
  static set llmMaxOutputTokens(value) {
    this.setPref(this.LLM_MAX_OUTPUT_TOKENS, value);
  }
  static get shortcutFindbar() {
    return this.getPref(this.SHORTCUT_FINDBAR);
  }
  static set shortcutFindbar(value) {
    this.setPref(this.SHORTCUT_FINDBAR, value);
  }
  static get shortcutUrlbar() {
    return this.getPref(this.SHORTCUT_URLBAR);
  }
  static set shortcutUrlbar(value) {
    this.setPref(this.SHORTCUT_URLBAR, value);
  }
  static get customSystemPrompt() {
    return this.getPref(this.CUSTOM_SYSTEM_PROMPT);
  }
  static set customSystemPrompt(value) {
    this.setPref(this.CUSTOM_SYSTEM_PROMPT, value);
  }
}
var PREFS2 = BrowseBotPREFS, prefs_default = PREFS2;

// findbar-ai/messageManager.js
async function frameScript() {
  let getUrlAndTitle = () => {
    return {
      url: content.location.href,
      title: content.document.title
    };
  }, extractRelevantContent = () => {
    let clonedBody = content.document.body.cloneNode(!0);
    return clonedBody.querySelectorAll("script, style, meta, noscript, iframe, svg, canvas, img, video, audio, object, embed, applet, link, head").forEach((el) => el.remove()), clonedBody.innerHTML;
  }, extractTextContent = (trimWhiteSpace = !0) => {
    let clonedBody = content.document.body.cloneNode(!0);
    clonedBody.querySelectorAll("script, style, meta, noscript, iframe, svg, canvas, input, textarea, select, img, video, audio, object, embed, applet, form, button, link, head").forEach((el) => el.remove()), clonedBody.querySelectorAll("br").forEach((br) => {
      br.replaceWith(`
`);
    });
    let blockSelector = "p, div, li, h1, h2, h3, h4, h5, h6, tr, article, section, header, footer, aside, main, blockquote, pre";
    clonedBody.querySelectorAll(blockSelector).forEach((el) => {
      el.append(`
`);
    });
    let textContent = clonedBody.textContent;
    if (trimWhiteSpace)
      return textContent.replace(/\s+/g, " ").trim();
    return textContent.replace(/[ \t\r\f\v]+/g, " ").replace(/ ?\n ?/g, `
`).replace(/\n+/g, `
`).trim();
  };
  async function getYouTubeTranscript() {
    let win = content, doc = content.document;
    async function ensureBodyAvailable() {
      if (doc.body)
        return;
      await new Promise((resolve) => {
        let check = () => {
          if (doc.body)
            resolve();
          else
            win.setTimeout(check, 50);
        };
        check();
      });
    }
    function waitForSelectorWithObserver(selector, timeout = 5000) {
      return new Promise((resolve, reject) => {
        ensureBodyAvailable().then(() => {
          let el = doc.querySelector(selector);
          if (el)
            return resolve(el);
          let observer = new win.MutationObserver(() => {
            let el2 = doc.querySelector(selector);
            if (el2)
              observer.disconnect(), resolve(el2);
          });
          observer.observe(doc.body, {
            childList: !0,
            subtree: !0
          }), win.setTimeout(() => {
            observer.disconnect(), reject(Error(`Timeout waiting for ${selector}`));
          }, timeout);
        }).catch((e) => {
          reject(Error(`waitForSelectorWithObserver failed: ${e.message}`));
        });
      });
    }
    if (!doc.querySelector("ytd-transcript-renderer")) {
      let button = doc.querySelector('button[aria-label="Show transcript"]');
      if (!button)
        throw Error('"Show transcript" button not found â€” transcript may not be available.');
      button.click(), await waitForSelectorWithObserver("ytd-transcript-renderer", 5000);
    }
    await waitForSelectorWithObserver("ytd-transcript-segment-renderer .segment-text", 5000);
    let segments = Array.from(doc.querySelectorAll("ytd-transcript-segment-renderer .segment-text"));
    if (!segments.length)
      throw Error("Transcript segments found, but all are empty.");
    return segments.map((el) => el.textContent.trim()).filter(Boolean).join(`
`);
  }
  let getYoutubeDescription = async () => {
    let descriptionContainer = content.document.querySelector("#description-inline-expander");
    if (descriptionContainer) {
      let expandButton = descriptionContainer.querySelector("#expand") || descriptionContainer.querySelector("#expand-button") || descriptionContainer.querySelector("tp-yt-paper-button#more");
      if (expandButton && expandButton.offsetParent !== null)
        expandButton.click(), await new Promise((resolve) => setTimeout(resolve, 0));
    }
    let desc = content.document.querySelector("#description-inline-expander .yt-core-attributed-string, #description .content, .ytd-expandable-video-description-body-renderer .yt-core-attributed-string");
    return desc ? desc.textContent.trim() : "Description not found.";
  }, getYoutubeComments = (count = 10) => {
    let comments = Array.from(content.document.querySelectorAll("ytd-comment-thread-renderer #content-text")).slice(0, count);
    if (comments.length === 0)
      return ["No comments found or they are not loaded yet."];
    return comments.map((c) => c.textContent.trim());
  }, handlers = {
    GetPageHTMLContent: () => {
      return {
        content: extractRelevantContent(),
        url: getUrlAndTitle().url,
        title: getUrlAndTitle().title
      };
    },
    GetSelectedText: () => {
      let selection = content.getSelection();
      return {
        selectedText: selection.toString(),
        hasSelection: !selection.isCollapsed,
        ...getUrlAndTitle()
      };
    },
    GetPageTextContent: ({ trimWhiteSpace }) => {
      return {
        textContent: extractTextContent(trimWhiteSpace),
        ...getUrlAndTitle()
      };
    },
    ClickElement: ({ selector }) => {
      let element = content.document.querySelector(selector);
      if (!element)
        throw Error(`Element with selector "${selector}" not found.`);
      return element.click(), { result: `Clicked element with selector "${selector}".` };
    },
    FillForm: ({ selector, value }) => {
      let element = content.document.querySelector(selector);
      if (!element)
        throw Error(`Element with selector "${selector}" not found.`);
      return element.value = value, element.dispatchEvent(new Event("input", { bubbles: !0 })), {
        result: `Filled element with selector "${selector}" with value "${value}".`
      };
    },
    GetYoutubeTranscript: async () => {
      return { transcript: await getYouTubeTranscript() };
    },
    GetYoutubeDescription: async () => {
      return { description: await getYoutubeDescription() };
    },
    GetYoutubeComments: ({ count }) => {
      return { comments: getYoutubeComments(count) };
    }
  };
  addMessageListener("FindbarAI:Command", async function(msg) {
    let cmd = msg.data.command, data = msg.data.data || {};
    try {
      let result = await handlers[cmd](data);
      sendAsyncMessage("FindbarAI:Result", { command: cmd, result });
    } catch (e) {
      sendAsyncMessage("FindbarAI:Result", { command: cmd, result: { error: e.message } });
    }
  });
}
var currentMessageManager = null, updateMessageManager = () => {
  if (gBrowser && gBrowser.selectedBrowser) {
    let mm = gBrowser.selectedBrowser.messageManager;
    if (mm !== currentMessageManager) {
      if (currentMessageManager = mm, !gBrowser.selectedBrowser._findbarAIInjected) {
        let scriptText = `(${frameScript})();`;
        mm.loadFrameScript("data:application/javascript;charset=utf-8," + encodeURIComponent(scriptText), !1), gBrowser.selectedBrowser._findbarAIInjected = !0;
      }
    }
  }
}, messageManagerAPI = {
  send(cmd, data = {}) {
    if (updateMessageManager(), !currentMessageManager)
      return PREFS2.debugError("No message manager available."), Promise.reject(Error("No message manager available."));
    return new Promise((resolve, reject) => {
      let listener = (msg) => {
        if (msg.data.command === cmd)
          if (currentMessageManager.removeMessageListener("FindbarAI:Result", listener), msg.data.result && msg.data.result.error)
            reject(Error(msg.data.result.error));
          else
            resolve(msg.data.result);
      };
      currentMessageManager.addMessageListener("FindbarAI:Result", listener), currentMessageManager.sendAsyncMessage("FindbarAI:Command", { command: cmd, data });
    });
  },
  getUrlAndTitle() {
    return {
      url: gBrowser.currentURI.spec,
      title: gBrowser.selectedBrowser.contentTitle
    };
  },
  async getHTMLContent() {
    return this.send("GetPageHTMLContent").catch((error) => {
      return PREFS2.debugError("Failed to get page HTML content:", error), {};
    });
  },
  async getSelectedText() {
    return this.send("GetSelectedText").then((result) => {
      if (!result || !result.hasSelection)
        return this.getUrlAndTitle();
      return result;
    }).catch((error) => {
      return PREFS2.debugError("Failed to get selected text:", error), this.getUrlAndTitle();
    });
  },
  async getPageTextContent(trimWhiteSpace = !0) {
    return this.send("GetPageTextContent", { trimWhiteSpace }).catch((error) => {
      return PREFS2.debugError("Failed to get page text content:", error), this.getUrlAndTitle();
    });
  },
  async clickElement(selector) {
    return this.send("ClickElement", { selector }).catch((error) => {
      return PREFS2.debugError(`Failed to click element with selector "${selector}":`, error), { error: `Failed to click element with selector "${selector}".` };
    });
  },
  async fillForm(selector, value) {
    return this.send("FillForm", { selector, value }).catch((error) => {
      return PREFS2.debugError(`Failed to fill form with selector "${selector}":`, error), { error: `Failed to fill form with selector "${selector}".` };
    });
  },
  async getYoutubeTranscript() {
    return this.send("GetYoutubeTranscript").catch((error) => {
      return PREFS2.debugError("Failed to get youtube transcript:", error), { error: `Failed to get youtube transcript: ${error.message}` };
    });
  },
  async getYoutubeDescription() {
    return this.send("GetYoutubeDescription").catch((error) => {
      return PREFS2.debugError("Failed to get youtube description:", error), { error: `Failed to get youtube description: ${error.message}` };
    });
  },
  async getYoutubeComments(count) {
    return this.send("GetYoutubeComments", { count }).catch((error) => {
      return PREFS2.debugError("Failed to get youtube comments:", error), { error: `Failed to get youtube comments: ${error.message}` };
    });
  }
};

// utils/parse.js
var parseElement = (elementString, type = "html") => {
  if (type === "xul")
    return window.MozXULElement.parseXULToFragment(elementString).firstChild;
  let element = new DOMParser().parseFromString(elementString, "text/html");
  if (element.body.children.length)
    element = element.body.firstChild;
  else
    element = element.head.firstChild;
  return element;
}, escapeXmlAttribute = (str) => {
  if (typeof str !== "string")
    return str;
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
};

// utils/keyboard.js
function eventToShortcutSignature(event) {
  let modifiers = [];
  if (event.ctrlKey || event.metaKey)
    modifiers.push("ctrl");
  if (event.altKey)
    modifiers.push("alt");
  if (event.shiftKey)
    modifiers.push("shift");
  return modifiers.push(normalizeKeyName(event.key)), modifiers.join("+");
}
function normalizeKeyName(key) {
  if (!key)
    return "";
  let k = key.toLowerCase();
  if (k === " " || k === "space" || k === "spacebar")
    return "space";
  return k;
}
function shortcutStringToSignature(shortcutStr) {
  if (!shortcutStr)
    return "";
  return shortcutStr.toLowerCase().replace(/control/g, "ctrl").replace(/option/g, "alt").split("+").map((s) => normalizeKeyName(s.trim())).join("+");
}
var _shortcuts = /* @__PURE__ */ new Map;
function handleKeyDown(event) {
  let t = event.target;
  if (t && (t.tagName === "input" || t.tagName === "textarea" || t.isContentEditable))
    return;
  let signature = eventToShortcutSignature(event), shortcut = _shortcuts.get(signature);
  if (shortcut)
    event.preventDefault(), event.stopPropagation(), shortcut.callback(event);
}
function initShortcutRegistry() {
  window.addEventListener("keydown", handleKeyDown, !0);
}
function registerShortcut(shortcutStr, id, callback) {
  if (!shortcutStr || !id || typeof callback !== "function")
    return console.error("registerShortcutInRegistry: Invalid arguments", { shortcutStr, id, callback }), !1;
  unregisterShortcutById(id);
  let signature = shortcutStringToSignature(shortcutStr);
  return _shortcuts.set(signature, { id, callback, shortcutStr }), !0;
}
function unregisterShortcutById(id) {
  for (let [signature, shortcut] of _shortcuts.entries())
    if (shortcut.id === id)
      return _shortcuts.delete(signature), !0;
  return !1;
}

// findbar-ai/settings.js
var SettingsModal = {
  _modalElement: null,
  _currentPrefValues: {},
  _currentShortcutTarget: null,
  _boundHandleShortcutKeyDown: null,
  _getSafeIdForProvider(providerName) {
    return providerName.replace(/\./g, "-");
  },
  _initShortcutHandler() {
    this._boundHandleShortcutKeyDown = this._handleShortcutKeyDown.bind(this);
  },
  _handleShortcutKeyDown(event) {
    if (!this._currentShortcutTarget)
      return;
    event.preventDefault(), event.stopPropagation();
    let targetInput = this._currentShortcutTarget, prefKey = targetInput.dataset.pref;
    if (event.key === "Escape") {
      targetInput.value = PREFS2.getPref(prefKey), targetInput.classList.remove("recording"), targetInput.placeholder = "Click to set", this._currentShortcutTarget = null, window.removeEventListener("keydown", this._boundHandleShortcutKeyDown, !0);
      return;
    }
    if (event.key === "Backspace" || event.key === "Delete") {
      targetInput.value = "", this._currentPrefValues[prefKey] = "", targetInput.classList.remove("recording"), targetInput.placeholder = "Click to set", this._currentShortcutTarget = null, window.removeEventListener("keydown", this._boundHandleShortcutKeyDown, !0);
      return;
    }
    if (["Control", "Alt", "Shift", "Meta"].includes(event.key))
      return;
    let shortcutString = eventToShortcutSignature(event);
    targetInput.value = shortcutString, this._currentPrefValues[prefKey] = shortcutString, PREFS2.debugLog(`Shortcut for ${prefKey} set to: ${shortcutString}`), targetInput.classList.remove("recording"), targetInput.placeholder = "Click to set", this._currentShortcutTarget = null, window.removeEventListener("keydown", this._boundHandleShortcutKeyDown, !0);
  },
  _generateShortcutInputHtml(prefConstant, label) {
    let currentValue = PREFS2.getPref(prefConstant), prefId = `pref-${prefConstant.toLowerCase().replace(/_/g, "-")}`;
    return `
      <div class="setting-item">
        <label for="${prefId}">${label}</label>
        <input type="text" id="${prefId}" data-pref="${prefConstant}" value="${escapeXmlAttribute(currentValue)}" readonly placeholder="Click to set" class="shortcut-input" />
      </div>
    `;
  },
  createModalElement() {
    this._initShortcutHandler();
    let settingsHtml = this._generateSettingsHtml(), container = parseElement(settingsHtml);
    this._modalElement = container;
    let providerOptionsXUL = Object.entries(browseBotFindbarLLM.AVAILABLE_PROVIDERS).map(([name, provider]) => `<menuitem
            value="${name}"
            label="${escapeXmlAttribute(provider.label)}"
            ${name === PREFS2.llmProvider ? 'selected="true"' : ""}
            ${provider.faviconUrl ? `image="${escapeXmlAttribute(provider.faviconUrl)}"` : ""}
          />`).join(""), menulistXul = `
      <menulist id="pref-llm-provider" data-pref="${PREFS2.LLM_PROVIDER}" value="${PREFS2.llmProvider}">
        <menupopup>
          ${providerOptionsXUL}
        </menupopup>
      </menulist>`, providerSelectorXulElement = parseElement(menulistXul, "xul"), placeholder = this._modalElement.querySelector("#llm-provider-selector-placeholder");
    if (placeholder)
      placeholder.replaceWith(providerSelectorXulElement);
    for (let [name, provider] of Object.entries(browseBotFindbarLLM.AVAILABLE_PROVIDERS)) {
      let { modelPref: modelPrefKey, model: currentModel } = provider, modelOptionsXUL = provider.AVAILABLE_MODELS.map((model) => `<menuitem
              value="${model}"
              label="${escapeXmlAttribute(provider.AVAILABLE_MODELS_LABELS[model] || model)}"
              ${model === currentModel ? 'selected="true"' : ""}
            />`).join(""), modelMenulistXul = `
          <menulist id="pref-${this._getSafeIdForProvider(name)}-model" data-pref="${modelPrefKey}" value="${currentModel}">
            <menupopup>
              ${modelOptionsXUL}
            </menupopup>
          </menulist>`, modelPlaceholder = this._modalElement.querySelector(`#llm-model-selector-placeholder-${this._getSafeIdForProvider(name)}`);
      if (modelPlaceholder) {
        let modelSelectorXulElement = parseElement(modelMenulistXul, "xul");
        modelPlaceholder.replaceWith(modelSelectorXulElement);
      }
    }
    return this._attachEventListeners(), container;
  },
  _attachEventListeners() {
    if (!this._modalElement)
      return;
    this._modalElement.querySelector("#close-settings").addEventListener("click", () => {
      this.hide();
    }), this._modalElement.querySelector("#save-settings").addEventListener("click", () => {
      if (this.saveSettings(), this.hide(), browseBotFindbar.enabled)
        browseBotFindbar.show();
      else
        browseBotFindbar.destroy();
    }), this._modalElement.addEventListener("click", (e) => {
      if (e.target === this._modalElement)
        this.hide();
    }), this._modalElement.querySelectorAll(".accordion-header").forEach((header) => {
      header.addEventListener("click", () => {
        let section = header.closest(".settings-accordion"), isExpanded = section.dataset.expanded === "true";
        section.dataset.expanded = isExpanded ? "false" : "true";
      });
    }), this._modalElement.querySelectorAll("[data-pref]").forEach((control) => {
      let prefKey = control.dataset.pref;
      if (control.type === "checkbox")
        control.checked = PREFS2.getPref(prefKey);
      else if (control.tagName.toLowerCase() === "menulist")
        control.value = PREFS2.getPref(prefKey);
      else
        control.value = PREFS2.getPref(prefKey);
      if (this._currentPrefValues[prefKey] = PREFS2.getPref(prefKey), control.tagName.toLowerCase() === "menulist")
        control.addEventListener("command", (e) => {
          if (this._currentPrefValues[prefKey] = e.target.value, PREFS2.debugLog(`Settings form value for ${prefKey} changed to: ${this._currentPrefValues[prefKey]}`), prefKey === PREFS2.LLM_PROVIDER)
            this._updateProviderSpecificSettings(this._modalElement, this._currentPrefValues[prefKey]);
        });
      else
        control.addEventListener("change", (e) => {
          if (control.type === "checkbox")
            this._currentPrefValues[prefKey] = e.target.checked;
          else if (control.type === "number")
            try {
              this._currentPrefValues[prefKey] = Number(e.target.value);
            } catch {
              this._currentPrefValues[prefKey] = 0;
            }
          else
            this._currentPrefValues[prefKey] = e.target.value;
          PREFS2.debugLog(`Settings form value for ${prefKey} changed to: ${this._currentPrefValues[prefKey]}`);
        });
    }), this._modalElement.querySelectorAll(".get-api-key-link").forEach((link) => {
      link.addEventListener("click", (e) => {
        e.preventDefault();
        let url = e.target.dataset.url;
        if (url)
          openTrustedLinkIn(url, "tab"), this.hide();
      });
    }), this._modalElement.querySelectorAll(".shortcut-input").forEach((input) => {
      input.addEventListener("focus", (e) => {
        this._currentShortcutTarget = e.target, e.target.classList.add("recording"), e.target.placeholder = "Press keys...", window.addEventListener("keydown", this._boundHandleShortcutKeyDown, !0);
      }), input.addEventListener("blur", () => {
        if (this._currentShortcutTarget)
          this._currentShortcutTarget.classList.remove("recording"), this._currentShortcutTarget.placeholder = "Click to set", this._currentShortcutTarget = null, window.removeEventListener("keydown", this._boundHandleShortcutKeyDown, !0);
      }), input.addEventListener("keydown", (e) => {
        e.preventDefault(), e.stopPropagation();
      });
    }), this._updateProviderSpecificSettings(this._modalElement, PREFS2.llmProvider), this._modalElement.querySelectorAll(".reset-section-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation(), btn.dataset.resetPrefs.split(",").forEach((prefKey) => {
          if (!prefKey)
            return;
          let defVal = PREFS2.defaultValues[prefKey];
          this._currentPrefValues[prefKey] = defVal;
          let control = this._modalElement.querySelector(`[data-pref="${prefKey}"]`);
          if (control) {
            if (control.type === "checkbox")
              control.checked = defVal;
            else if (control.tagName.toLowerCase() === "menulist")
              control.value = defVal;
            else
              control.value = defVal;
            if (prefKey === PREFS2.LLM_PROVIDER)
              this._updateProviderSpecificSettings(this._modalElement, defVal);
          }
        });
      });
    });
  },
  saveSettings() {
    for (let prefKey in this._currentPrefValues)
      if (Object.prototype.hasOwnProperty.call(this._currentPrefValues, prefKey)) {
        if (prefKey.endsWith("api-key")) {
          if (this._currentPrefValues[prefKey]) {
            let maskedKey = "*".repeat(this._currentPrefValues[prefKey].length);
            PREFS2.debugLog(`Saving pref ${prefKey} to: ${maskedKey}`);
          }
        } else
          PREFS2.debugLog(`Saving pref ${prefKey} to: ${this._currentPrefValues[prefKey]}`);
        try {
          PREFS2.setPref(prefKey, this._currentPrefValues[prefKey]);
        } catch (e) {
          PREFS2.debugError(`Error Saving pref for ${prefKey} ${e}`);
        }
      }
    if (!browseBotFindbarLLM.currentProvider.apiKey)
      browseBotFindbar.expanded = !1;
  },
  show() {
    this.createModalElement(), this._modalElement.querySelectorAll("[data-pref]").forEach((control) => {
      let prefKey = control.dataset.pref;
      if (control.type === "checkbox")
        control.checked = PREFS2.getPref(prefKey);
      else if (control.tagName.toLowerCase() === "menulist")
        control.value = PREFS2.getPref(prefKey);
      else
        control.value = PREFS2.getPref(prefKey);
      this._currentPrefValues[prefKey] = PREFS2.getPref(prefKey);
    }), this._updateProviderSpecificSettings(this._modalElement, PREFS2.llmProvider), document.documentElement.appendChild(this._modalElement);
  },
  hide() {
    if (this._modalElement && this._modalElement.parentNode)
      this._modalElement.remove();
  },
  _updateProviderSpecificSettings(container, selectedProviderName) {
    container.querySelectorAll(".provider-settings-group").forEach((group) => {
      group.style.display = "none";
    });
    let activeGroup = container.querySelector(`#${this._getSafeIdForProvider(selectedProviderName)}-settings-group`);
    if (activeGroup) {
      activeGroup.style.display = "block";
      let modelPrefKey = PREFS2[`${selectedProviderName.toUpperCase()}_MODEL`];
      if (modelPrefKey) {
        let modelSelect = activeGroup.querySelector(`#pref-${this._getSafeIdForProvider(selectedProviderName)}-model`);
        if (modelSelect)
          modelSelect.value = this._currentPrefValues[modelPrefKey] || PREFS2.getPref(modelPrefKey);
      }
      let provider = browseBotFindbarLLM.AVAILABLE_PROVIDERS[selectedProviderName], getApiKeyLink = activeGroup.querySelector(".get-api-key-link");
      if (getApiKeyLink)
        if (provider.apiKeyUrl)
          getApiKeyLink.style.display = "inline-block", getApiKeyLink.dataset.url = provider.apiKeyUrl;
        else
          getApiKeyLink.style.display = "none", delete getApiKeyLink.dataset.url;
    }
  },
  _generateCheckboxSettingHtml(label, prefConstant) {
    let prefId = `pref-${prefConstant.toLowerCase().replace(/_/g, "-")}`;
    return `
      <div class="setting-item">
        <label for="${prefId}">${label}</label>
        <input type="checkbox" id="${prefId}" data-pref="${prefConstant}" />
      </div>
    `;
  },
  _generateNumberSettingHtml(label, prefConstant, min, max, step, tooltip) {
    let prefId = `pref-${prefConstant.toLowerCase().replace(/_/g, "-")}`, infoIconHtml = tooltip ? `<span class="info-icon-wrapper" data-tooltip="${escapeXmlAttribute(tooltip)}"><img class="info-icon" src="chrome://global/skin/icons/info.svg" /></span>` : "";
    return `
      <div class="setting-item">
        <label for="${prefId}" style="display: flex; align-items: center; gap: 6px;">
          ${label}
          ${infoIconHtml}
        </label>
        <input type="number" id="${prefId}" data-pref="${prefConstant}" min="${min}" max="${max}" step="${step}" />
      </div>
    `;
  },
  _createCheckboxSectionHtml(title, settingsArray, expanded = !0, contentBefore = "", contentAfter = "", resetPrefs = []) {
    let settingsHtml = settingsArray.map((s) => {
      if (s.type === "number")
        return this._generateNumberSettingHtml(s.label, s.pref, s.min, s.max, s.step, s.tooltip);
      return this._generateCheckboxSettingHtml(s.label, s.pref);
    }).join(""), prefsToReset = (resetPrefs.length > 0 ? resetPrefs : settingsArray.map((s) => s.pref)).join(",");
    return `
    <section class="settings-section settings-accordion" data-expanded="${expanded}" >
      <h4 class="accordion-header">
        ${title}
        <div class="reset-section-btn" data-reset-prefs="${prefsToReset}" title="Reset Section" role="button">
            <img src="chrome://global/skin/icons/reload.svg" />
        </div>
      </h4>
      <div class="accordion-content">
        ${contentBefore}
        ${settingsHtml}
        ${contentAfter}
      </div>
    </section>
  `;
  },
  _generateSettingsHtml() {
    let findbarSettings = [
      { label: "Enable AI Findbar", pref: PREFS2.ENABLED },
      { label: "Minimal Mode (similar to arc)", pref: PREFS2.MINIMAL },
      { label: "Persist Chat (don't persist when browser closes)", pref: PREFS2.PERSIST },
      { label: "Enable Drag and Drop", pref: PREFS2.DND_ENABLED },
      { label: "Remember Dimensions", pref: PREFS2.REMEMBER_DIMENSIONS }
    ], positionOptionsHTML = Object.entries({
      "top-left": "Top Left",
      "top-right": "Top Right",
      "bottom-left": "Bottom Left",
      "bottom-right": "Bottom Right"
    }).map(([value, label]) => `<option value="${value}">${escapeXmlAttribute(label)}</option>`).join(""), positionSelectorHtml = `
      <div class="setting-item">
        <label for="pref-position">Position</label>
        <select id="pref-position" data-pref="${PREFS2.POSITION}">
          ${positionOptionsHTML}
        </select>
      </div>
    `, backgroundStyleOptionsHTML = Object.entries({
      solid: "Solid",
      acrylic: "Acrylic",
      pseudo: "Pseudo"
    }).map(([value, label]) => `<option value="${value}">${escapeXmlAttribute(label)}</option>`).join(""), backgroundStyleSelectorHtml = `
      <div class="setting-item">
        <label for="pref-background-style">Background Style</label>
        <select id="pref-background-style" data-pref="${PREFS2.BACKGROUND_STYLE}">
          ${backgroundStyleOptionsHTML}
        </select>
      </div>
    `, findbarResetPrefs = [
      ...findbarSettings.map((s) => s.pref),
      PREFS2.POSITION,
      PREFS2.BACKGROUND_STYLE
    ], findbarSectionHtml = this._createCheckboxSectionHtml("Findbar AI", findbarSettings, !0, "", positionSelectorHtml + backgroundStyleSelectorHtml, findbarResetPrefs), urlbarSettings = [
      { label: "Enable URLBar AI", pref: PREFS2.URLBAR_AI_ENABLED },
      { label: "Enable Animations", pref: PREFS2.URLBAR_AI_ANIMATIONS_ENABLED },
      { label: "Hide Suggestions", pref: PREFS2.URLBAR_AI_HIDE_SUGGESTIONS }
    ], urlbarSectionHtml = this._createCheckboxSectionHtml("URLBar AI", urlbarSettings, !1, "", "", urlbarSettings.map((s) => s.pref)), shortcutFindbarHtml = this._generateShortcutInputHtml(PREFS2.SHORTCUT_FINDBAR, "Open Findbar AI"), shortcutUrlbarHtml = this._generateShortcutInputHtml(PREFS2.SHORTCUT_URLBAR, "Toggle URLBar AI"), shortcutsSectionHtml = `
      <section class="settings-section settings-accordion" data-expanded="true">
        <h4 class="accordion-header">
          Keyboard Shortcuts
          <div class="reset-section-btn" data-reset-prefs="${PREFS2.SHORTCUT_FINDBAR},${PREFS2.SHORTCUT_URLBAR}" title="Reset Section" role="button">
            <img src="chrome://global/skin/icons/reload.svg" />
          </div>
        </h4>
        <div class="accordion-content">
          ${shortcutFindbarHtml}
          ${shortcutUrlbarHtml}
        </div>
      </section>
    `, aiBehaviorSettings = [
      { label: "Enable Citations", pref: PREFS2.CITATIONS_ENABLED },
      { label: "Stream Response", pref: PREFS2.STREAM_ENABLED },
      { label: "Agentic Mode (AI can use tool calls)", pref: PREFS2.AGENTIC_MODE },
      { label: "Conformation before tool call", pref: PREFS2.CONFORMATION }
    ], aiBehaviorWarningHtml = `
      <div id="citations-agentic-mode-warning" class="warning-message" >
        Warning: Enabling both Citations and Agentic Mode may lead to unexpected behavior or errors.
      </div>
    `, maxToolCallsHtml = `
   <div class="setting-item">
     <label for="pref-max-tool-calls">Max Tool Calls (Maximum number of messages to send AI back to back)</label>
     <input type="number" id="pref-max-tool-calls" data-pref="${PREFS2.MAX_TOOL_CALLS}" />
   </div>
 `, customSystemPromptHtml = `
   <div class="setting-item">
     <label for="pref-custom-system-prompt">Custom System Prompt</label>
     <textarea id="pref-custom-system-prompt" data-pref="${PREFS2.CUSTOM_SYSTEM_PROMPT}" rows="3" placeholder="Pretend like ...."></textarea>
   </div>
 `, aiBehaviorResetPrefs = [
      ...aiBehaviorSettings.map((s) => s.pref),
      PREFS2.MAX_TOOL_CALLS,
      PREFS2.CUSTOM_SYSTEM_PROMPT
    ], aiBehaviorSectionHtml = this._createCheckboxSectionHtml("AI Behavior", aiBehaviorSettings, !0, `
      <div id="citations-agentic-mode-warning" class="warning-message" >
        Warning: Enabling both Citations and Agentic Mode may lead to unexpected behavior or errors.
      </div>
    `, maxToolCallsHtml + customSystemPromptHtml, aiBehaviorResetPrefs), contextMenuSettings = [
      { label: "Enable Context Menu (right click menu)", pref: PREFS2.CONTEXT_MENU_ENABLED },
      {
        label: "Auto Send from Context Menu",
        pref: PREFS2.CONTEXT_MENU_AUTOSEND
      }
    ], contextMenuCommandsHtml = `
      <div class="setting-item">
        <label for="pref-context-menu-command-no-selection">Command when no text is selected</label>
        <textarea id="pref-context-menu-command-no-selection" data-pref="${PREFS2.CONTEXT_MENU_COMMAND_NO_SELECTION}" rows="3"></textarea>
      </div>
      <div class="setting-item">
        <label for="pref-context-menu-command-with-selection">Command when text is selected. Use {selection} for the selected text.</label>
        <textarea id="pref-context-menu-command-with-selection" data-pref="${PREFS2.CONTEXT_MENU_COMMAND_WITH_SELECTION}" rows="3"></textarea>
      </div>
    `, contextMenuResetPrefs = [
      ...contextMenuSettings.map((s) => s.pref),
      PREFS2.CONTEXT_MENU_COMMAND_NO_SELECTION,
      PREFS2.CONTEXT_MENU_COMMAND_WITH_SELECTION
    ], contextMenuSectionHtml = this._createCheckboxSectionHtml("Context Menu", contextMenuSettings, !1, "", contextMenuCommandsHtml, contextMenuResetPrefs), llmProviderSettingsHtml = "";
    for (let [name, provider] of Object.entries(browseBotFindbarLLM.AVAILABLE_PROVIDERS)) {
      let modelPrefKey = provider.modelPref, apiInputHtml;
      if (name === "ollama")
        apiInputHtml = `
        <div class="setting-item">
          <label for="pref-ollama-base-url">Base URL</label>
          <input type="text" id="pref-ollama-base-url" data-pref="${PREFS2.OLLAMA_BASE_URL}" placeholder="http://localhost:11434/api" />
        </div>
      `;
      else {
        let apiPrefKey = PREFS2[`${name.toUpperCase()}_API_KEY`];
        apiInputHtml = apiPrefKey ? `
        <div class="setting-item">
          <label for="pref-${this._getSafeIdForProvider(name)}-api-key">API Key</label>
          <input type="password" id="pref-${this._getSafeIdForProvider(name)}-api-key" data-pref="${apiPrefKey}" placeholder="Enter ${provider.label} API Key" />
        </div>
      ` : "";
      }
      let modelSelectPlaceholderHtml = modelPrefKey ? `
        <div class="setting-item">
          <label for="pref-${this._getSafeIdForProvider(name)}-model">Model</label>
          <div id="llm-model-selector-placeholder-${this._getSafeIdForProvider(name)}"></div>
        </div>
      ` : "";
      llmProviderSettingsHtml += `
        <div id="${this._getSafeIdForProvider(name)}-settings-group" class="provider-settings-group">
          <div class="provider-header-group">
            <h5>${provider.label}</h5>
            <button class="get-api-key-link" data-url="${provider.apiKeyUrl || ""}" style="display: ${provider.apiKeyUrl ? "inline-block" : "none"};">Get API Key</button>
          </div>
          ${apiInputHtml}
          ${modelSelectPlaceholderHtml}
        </div>
      `;
    }
    let llmProvidersSectionHtml = `
      <section class="settings-section settings-accordion" data-expanded="false">
        <h4 class="accordion-header">
            LLM Providers
            <div class="reset-section-btn" data-reset-prefs="${[
      PREFS2.LLM_PROVIDER,
      PREFS2.OLLAMA_BASE_URL,
      ...Object.values(browseBotFindbarLLM.AVAILABLE_PROVIDERS).flatMap((p) => [p.modelPref, PREFS2[`${p.name.toUpperCase()}_API_KEY`]]).filter(Boolean)
    ].join(",")}" title="Reset Section" role="button">
                <img src="chrome://global/skin/icons/reload.svg" />
            </div>
        </h4>
        <div class="setting-item accordion-content" class="">
          <label for="pref-llm-provider">Select Provider</label>
          <div id="llm-provider-selector-placeholder"></div>
        </div>
        ${llmProviderSettingsHtml}
      </section>`, advancedLLMSettings = [
      {
        label: "Temperature",
        pref: PREFS2.LLM_TEMPERATURE,
        type: "number",
        step: 0.1,
        min: 0,
        max: 2,
        tooltip: "Controls randomness. Lower values are more deterministic."
      },
      {
        label: "Top P  -----",
        pref: PREFS2.LLM_TOP_P,
        type: "number",
        step: 0.1,
        min: 0,
        max: 1,
        tooltip: "Nucleus sampling. Limits token selection to top cumulative probability."
      },
      {
        label: "Top K  ----- ",
        pref: PREFS2.LLM_TOP_K,
        type: "number",
        step: 1,
        min: 0,
        max: 200,
        tooltip: "Limits sampling to the top K tokens. Removes low probability responses."
      },
      {
        label: "Presence Penalty",
        pref: PREFS2.LLM_PRESENCE_PENALTY,
        type: "number",
        step: 0.1,
        min: -2,
        max: 2,
        tooltip: "Penalizes repeated tokens. Reduces repetition of information already in the context."
      },
      {
        label: "Frequency Penalty",
        pref: PREFS2.LLM_FREQUENCY_PENALTY,
        type: "number",
        step: 0.1,
        min: -2,
        max: 2,
        tooltip: "Penalizes frequent tokens. Discourages repetition of the same words/phrases."
      },
      {
        label: "Max Output Tokens",
        pref: PREFS2.LLM_MAX_OUTPUT_TOKENS,
        type: "number",
        step: 1,
        min: 1,
        max: 32000,
        tooltip: "Maximum number of tokens to generate."
      }
    ], advancedLLMResetPrefs = advancedLLMSettings.map((s) => s.pref), advancedLLMSectionHtml = this._createCheckboxSectionHtml("Advanced LLM Settings", advancedLLMSettings, !1, "", "", advancedLLMResetPrefs), browserFindbarSettings = [
      { label: "Find as you Type", pref: "accessibility.typeaheadfind" },
      {
        label: "Enable sound (when word not found)",
        pref: "accessibility.typeaheadfind.enablesound"
      },
      { label: "Entire Word", pref: "findbar.entireword" },
      { label: "Highlight All", pref: "findbar.highlightAll" }
    ], browserSettingsHtml = this._createCheckboxSectionHtml("Browser Findbar", browserFindbarSettings, !1, "", "", browserFindbarSettings.map((s) => s.pref)), devSettings = [{ label: "Debug Mode (logs in console)", pref: PREFS2.DEBUG_MODE }], devSectionHtml = this._createCheckboxSectionHtml("Development", devSettings, !1);
    return `
      <div id="ai-settings-modal-overlay">
        <div class="browse-bot-settings-modal">
          <div class="ai-settings-header">
            <h3>Settings</h3>
            <div>
              <button id="close-settings" class="settings-close-btn">Close</button>
              <button id="save-settings" class="settings-save-btn">Save</button>
            </div>
          </div>
          <div class="ai-settings-content">
            ${findbarSectionHtml}
            ${urlbarSectionHtml}
            ${shortcutsSectionHtml}
            ${aiBehaviorSectionHtml}
            ${contextMenuSectionHtml}
            ${llmProvidersSectionHtml}
            ${advancedLLMSectionHtml}
            ${browserSettingsHtml}
            ${devSectionHtml}
          </div>
        </div>
      </div>
    `;
  }
};

// findbar-ai/llm/tools.js
import { tool } from "./vercel-ai-sdk.uc.mjs";
import { z } from "./vercel-ai-sdk.uc.mjs";

// utils/toast.js
function debugLog(...args) {}
function showToast(options = {}) {
  debugLog("showToast called with options:", options);
  let { title, description, preset = 0, onClick, buttonText, timeout = 3000, id } = options;
  if (debugLog("Parsed options:", { title, description, preset, buttonText, timeout, id }), !title) {
    console.error("Toast: title is required");
    return;
  }
  let toastId = id || `custom-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
  debugLog("Generated toast ID:", toastId);
  try {
    debugLog("Importing uc_api module...");
    let ucAPI = ChromeUtils.importESModule("chrome://userscripts/content/engine/utils/uc_api.sys.mjs").default;
    debugLog("uc_api module imported successfully:", !!ucAPI);
    let showToastOptions = {
      id: toastId,
      preset,
      clickEvent: onClick,
      name: description ? description.replace(/\s+/g, " ").trim() : void 0,
      timeout
    };
    debugLog("Calling ucAPI.showToast with:", showToastOptions), ucAPI.showToast(showToastOptions), debugLog("ucAPI.showToast called successfully");
    let retryCount = 0, maxRetries = 10, retryInterval = 50, tryReplaceText = () => {
      debugLog(`Starting text replacement attempt ${retryCount + 1}/${maxRetries}...`);
      let windows = Services.wm.getEnumerator("navigator:browser"), windowCount = 0, foundToast = !1;
      while (windows.hasMoreElements()) {
        let win = windows.getNext();
        windowCount++, debugLog(`Checking window ${windowCount}:`, !!win);
        let toast = win.document.querySelector(`.sineToast[data-id="${toastId}"]`);
        if (debugLog(`Toast found in window ${windowCount}:`, !!toast), toast) {
          foundToast = !0, debugLog("Toast element found, starting text replacement...");
          let titleElement = toast.querySelector("span[data-l10n-id]");
          if (debugLog("Title element found:", !!titleElement), titleElement)
            titleElement.removeAttribute("data-l10n-id"), titleElement.removeAttribute("data-l10n-args"), titleElement.textContent = title, debugLog("Title text replaced with:", title);
          else {
            debugLog("Title element not found, trying alternative selectors...");
            let altTitleElement = toast.querySelector("span");
            if (altTitleElement)
              altTitleElement.textContent = title, debugLog("Title text replaced using alternative selector");
          }
          if (description) {
            let descElement = toast.querySelector(".description");
            if (debugLog("Description element found:", !!descElement), descElement)
              descElement.removeAttribute("data-l10n-id"), descElement.textContent = description, debugLog("Description text replaced with:", description);
            else
              debugLog("Description element not found");
          }
          if (buttonText) {
            let button = toast.querySelector("button");
            if (debugLog("Button element found:", !!button), button)
              button.removeAttribute("data-l10n-id"), button.textContent = buttonText, debugLog("Button text replaced with:", buttonText);
            else
              debugLog("Button element not found");
          }
          if (preset === 0) {
            let button = toast.querySelector("button");
            if (debugLog("Button element for hiding found:", !!button), button)
              button.style.display = "none", debugLog("Button hidden due to preset=0");
            else
              debugLog("No button found to hide");
          }
          debugLog("Text replacement completed for this toast");
          return;
        }
      }
      if (debugLog(`Checked ${windowCount} windows, found toast: ${foundToast}`), !foundToast && retryCount < maxRetries) {
        retryCount++, debugLog("Toast not found, retrying...");
        let browserWindow2 = Services.wm.getMostRecentWindow("navigator:browser");
        if (browserWindow2)
          browserWindow2.setTimeout(tryReplaceText, retryInterval);
        else
          debugLog("No browser window found for retry");
      } else if (!foundToast)
        debugLog("Max retries reached or no toast found with ID:", toastId);
    }, browserWindow = Services.wm.getMostRecentWindow("navigator:browser");
    if (browserWindow)
      browserWindow.setTimeout(tryReplaceText, 50);
    else
      debugLog("No browser window found for setTimeout");
  } catch (error) {
    debugLog("Error in showToast:", error), console.error("Toast API error:", error);
  }
}

// findbar-ai/llm/tools.js
var TabIdManager = new class {
  #tabIdMap = /* @__PURE__ */ new WeakMap;
  #idTabMap = /* @__PURE__ */ new Map;
  #nextId = 1;
  _getOrCreateId(tab) {
    if (!this.#tabIdMap.has(tab)) {
      let id = this.#nextId++;
      this.#tabIdMap.set(tab, id), this.#idTabMap.set(id, tab);
    }
    return this.#tabIdMap.get(tab);
  }
  getTabById(id) {
    let numericId = Number(id), tab = this.#idTabMap.get(numericId);
    if (tab && tab.ownerGlobal && !tab.ownerGlobal.closed && gBrowser.tabs.includes(tab))
      return tab;
    return this.#idTabMap.delete(numericId), null;
  }
  mapTab(tab) {
    if (!tab)
      return null;
    let id = this._getOrCreateId(tab), splitGroup = tab.group?.hasAttribute("split-view-group") ? tab.group : null, workspaceId = tab.getAttribute("zen-workspace-id"), workspace = workspaceId ? gZenWorkspaces.getWorkspaceFromId(workspaceId) : null, activeWorkspaceId = gZenWorkspaces.activeWorkspace, isEssential = tab.hasAttribute("zen-essential"), workspaceInfos = {
      workspaceId,
      workspaceName: workspace?.name || null,
      workspaceIcon: workspace?.icon || null
    };
    return {
      id: String(id),
      title: tab.label,
      url: tab.linkedBrowser?.currentURI?.spec,
      isCurrent: tab === gBrowser.selectedTab,
      inCurrentWorkspace: workspaceId === activeWorkspaceId,
      pinned: tab.pinned,
      isGroup: gBrowser.isTabGroup(tab),
      isEssential,
      parentFolderId: tab.group && !splitGroup ? tab.group.id : null,
      parentFolderName: tab.group && !splitGroup ? tab.group.label : null,
      isSplitView: !!splitGroup,
      splitViewId: splitGroup ? splitGroup.id : null,
      ...isEssential ? {} : workspaceInfos
    };
  }
}, createStringParameter = (description, isOptional = !1) => {
  let schema = z.string().describe(description);
  return isOptional ? schema.optional() : schema;
}, createStringArrayParameter = (description, isOptional = !1) => {
  let schema = z.array(z.string()).describe(description);
  return isOptional ? schema.optional() : schema;
}, createTool = (description, parameters, executeFn) => {
  return tool({
    description,
    inputSchema: z.object(parameters),
    execute: executeFn
  });
};
function getTabsByIds(tabIds) {
  if (!Array.isArray(tabIds))
    tabIds = [tabIds];
  return tabIds.map((id) => TabIdManager.getTabById(id)).filter(Boolean);
}
function mapTabToObject(tab) {
  return TabIdManager.mapTab(tab);
}
async function getSearchURL(engineName, searchTerm) {
  try {
    let engine = await Services.search.getEngineByName(engineName);
    if (!engine)
      return PREFS2.debugError(`No search engine found with name: ${engineName}`), null;
    let submission = engine.getSubmission(searchTerm.trim());
    if (!submission)
      return PREFS2.debugError(`No submission found for term: ${searchTerm} and engine: ${engineName}`), null;
    return submission.uri.spec;
  } catch (e) {
    return PREFS2.debugError(`Error getting search URL for engine "${engineName}".`, e), null;
  }
}
async function search(args) {
  let { searchTerm, engineName, where } = args, defaultEngineName = Services.search.defaultEngine.name, searchEngineName = engineName || defaultEngineName;
  if (!searchTerm)
    return { error: "Search tool requires a searchTerm." };
  let url = await getSearchURL(searchEngineName, searchTerm);
  if (url)
    return await openLink({ link: url, where });
  else
    return {
      error: `Could not find search engine named '${searchEngineName}'.`
    };
}
async function openLink(args) {
  let { link, where = "new tab" } = args;
  if (!link)
    return { error: "openLink requires a link." };
  let whereNormalized = where?.toLowerCase()?.trim();
  try {
    switch (whereNormalized) {
      case "current tab":
        openTrustedLinkIn(link, "current");
        break;
      case "new tab":
        openTrustedLinkIn(link, "tab");
        break;
      case "new window":
        openTrustedLinkIn(link, "window");
        break;
      case "incognito":
      case "private":
        window.openTrustedLinkIn(link, "window", { private: !0 });
        break;
      case "glance":
        if (window.gZenGlanceManager)
          window.gZenGlanceManager.openGlance({
            url: link
          });
        else
          return openTrustedLinkIn(link, "tab"), { result: "Glance not available. Opened in a new tab." };
        break;
      case "vsplit":
      case "hsplit":
        if (window.gZenViewSplitter) {
          let sep = whereNormalized === "vsplit" ? "vsep" : "hsep", tab1 = gBrowser.selectedTab;
          await openTrustedLinkIn(link, "tab");
          let tab2 = gBrowser.selectedTab;
          gZenViewSplitter.splitTabs([tab1, tab2], sep, 1);
        } else
          return { error: "Split view is not available." };
        break;
      default:
        return openTrustedLinkIn(link, "tab"), {
          result: `Unknown location "${where}". Opened in a new tab as fallback.`
        };
    }
    return { result: `Successfully opened ${link} in ${where}.` };
  } catch (e) {
    return PREFS2.debugError(`Failed to open link "${link}" in "${where}".`, e), { error: "Failed to open link." };
  }
}
async function newSplit(args) {
  let { links, type = "vertical" } = args;
  if (!window.gZenViewSplitter)
    return { error: "Split view function is not available." };
  if (!links || !Array.isArray(links) || links.length < 2)
    return { error: "newSplit requires an array of at least two links." };
  try {
    let tabs = [];
    for (let link of links)
      await openTrustedLinkIn(link, "tab"), tabs.push(gBrowser.selectedTab);
    let gridType, lowerType = type.toLowerCase();
    if (lowerType === "grid")
      gridType = "grid";
    else if (lowerType === "horizontal")
      gridType = "hsep";
    else
      gridType = "vsep";
    return gZenViewSplitter.splitTabs(tabs, gridType), {
      result: `Successfully created split view with ${links.length} tabs.`
    };
  } catch (e) {
    return PREFS2.debugError("Failed to create split view.", e), { error: "Failed to create split view." };
  }
}
async function getAllTabs() {
  try {
    return { tabs: gZenWorkspaces.allStoredTabs.map(mapTabToObject).filter(Boolean) };
  } catch (e) {
    return PREFS2.debugError("Failed to get all tabs:", e), { error: "Failed to retrieve tabs." };
  }
}
async function closeTabs(args) {
  let { tabIds } = args;
  if (!tabIds || tabIds.length === 0)
    return { error: "closeTabs requires an array of tabIds." };
  try {
    let tabsToClose = getTabsByIds(tabIds);
    if (tabsToClose.length === 0)
      return { error: "No matching tabs found to close." };
    return gBrowser.removeTabs(tabsToClose), { result: `Successfully closed ${tabsToClose.length} tab(s).` };
  } catch (e) {
    return PREFS2.debugError("Failed to close tabs:", e), { error: "An error occurred while closing tabs." };
  }
}
async function splitExistingTabs(args) {
  let { tabIds, type = "vertical" } = args;
  if (!window.gZenViewSplitter)
    return { error: "Split view function is not available." };
  if (!tabIds || tabIds.length < 2)
    return { error: "splitExistingTabs requires at least two tabIds." };
  try {
    let tabs = getTabsByIds(tabIds);
    if (tabs.length < 2)
      return { error: "Could not find at least two tabs to split." };
    let gridType, lowerType = type.toLowerCase();
    if (lowerType === "grid")
      gridType = "grid";
    else if (lowerType === "horizontal")
      gridType = "hsep";
    else
      gridType = "vsep";
    return gZenViewSplitter.splitTabs(tabs, gridType), { result: `Successfully created split view with ${tabs.length} tabs.` };
  } catch (e) {
    return PREFS2.debugError("Failed to split existing tabs.", e), { error: "Failed to create split view." };
  }
}
async function searchTabs(args) {
  let { query } = args;
  if (!query)
    return { error: "searchTabs requires a query." };
  let lowerCaseQuery = query.toLowerCase();
  try {
    return { tabs: gZenWorkspaces.allStoredTabs.filter((tab) => {
      let title = tab.label?.toLowerCase() || "", url = tab.linkedBrowser?.currentURI?.spec?.toLowerCase() || "";
      return title.includes(lowerCaseQuery) || url.includes(lowerCaseQuery);
    }).map(mapTabToObject).filter(Boolean) };
  } catch (e) {
    return PREFS2.debugError(`Error searching tabs for query "${query}":`, e), { error: "Failed to search tabs." };
  }
}
async function addTabsToFolder(args) {
  let { tabIds, folderId } = args;
  if (!tabIds || !folderId)
    return { error: "addTabsToFolder requires tabIds and a folderId." };
  try {
    let tabs = getTabsByIds(tabIds), folder = document.getElementById(folderId);
    if (!folder || !folder.isZenFolder)
      return { error: `Folder with ID "${folderId}" not found or is not a valid folder.` };
    if (tabs.length === 0)
      return { error: "No valid tabs found to add to the folder." };
    for (let tab of tabs)
      if (!tab.pinned)
        gBrowser.pinTab(tab);
    return folder.addTabs(tabs), { result: `Successfully added ${tabs.length} tab(s) to folder "${folder.label}".` };
  } catch (e) {
    return PREFS2.debugError("Failed to add tabs to folder:", e), { error: "Failed to add tabs to folder." };
  }
}
async function removeTabsFromFolder(args) {
  let { tabIds } = args;
  if (!tabIds)
    return { error: "removeTabsFromFolder requires tabIds." };
  try {
    let tabs = getTabsByIds(tabIds);
    if (tabs.length === 0)
      return { error: "No valid tabs found." };
    let ungroupedCount = 0;
    return tabs.forEach((tab) => {
      if (tab.group)
        gBrowser.ungroupTab(tab), ungroupedCount++;
    }), { result: `Successfully ungrouped ${ungroupedCount} tab(s).` };
  } catch (e) {
    return PREFS2.debugError("Failed to remove tabs from folder:", e), { error: "Failed to remove tabs from folder." };
  }
}
async function createTabFolder(args) {
  let { name } = args;
  if (!name)
    return { error: "createTabFolder requires a name." };
  try {
    let folder = gZenFolders.createFolder([], { label: name, renameFolder: !1 });
    return {
      result: `Successfully created folder "${folder.label}".`,
      folder: {
        id: folder.id,
        name: folder.label
      }
    };
  } catch (e) {
    return PREFS2.debugError("Failed to create tab folder:", e), { error: "Failed to create tab folder." };
  }
}
async function reorderTab(args) {
  let { tabId, newIndex } = args;
  if (!tabId || typeof newIndex !== "number")
    return { error: "reorderTab requires a tabId and a newIndex." };
  try {
    let tab = TabIdManager.getTabById(tabId);
    if (!tab)
      return { error: `Tab with id ${tabId} not found.` };
    return gBrowser.moveTabTo(tab, { tabIndex: newIndex }), { result: `Successfully moved tab to index ${newIndex}.` };
  } catch (e) {
    return PREFS2.debugError("Failed to reorder tab:", e), { error: "Failed to reorder tab." };
  }
}
async function addTabsToEssentials(args) {
  let { tabIds } = args;
  if (!tabIds || tabIds.length === 0)
    return { error: "addTabsToEssentials requires at least one tabId." };
  try {
    let tabs = getTabsByIds(tabIds);
    if (tabs.length === 0)
      return { error: "No matching tabs found." };
    if (window.gZenPinnedTabManager)
      return gZenPinnedTabManager.addToEssentials(tabs), { result: `Successfully added ${tabs.length} tab(s) to essentials.` };
    else
      return { error: "Essentials manager is not available." };
  } catch (e) {
    return PREFS2.debugError("Failed to add tabs to essentials:", e), { error: "An error occurred while adding tabs to essentials." };
  }
}
async function removeTabsFromEssentials(args) {
  let { tabIds } = args;
  if (!tabIds || tabIds.length === 0)
    return { error: "removeTabsFromEssentials requires at least one tabId." };
  try {
    let tabs = getTabsByIds(tabIds);
    if (tabs.length === 0)
      return { error: "No matching tabs found." };
    if (window.gZenPinnedTabManager)
      return tabs.forEach((tab) => gZenPinnedTabManager.removeFromEssentials(tab)), { result: `Successfully removed ${tabs.length} tab(s) from essentials.` };
    else
      return { error: "Essentials manager is not available." };
  } catch (e) {
    return PREFS2.debugError("Failed to remove tabs from essentials:", e), { error: "An error occurred while removing tabs from essentials." };
  }
}
async function searchBookmarks(args) {
  let { query } = args;
  if (!query)
    return { error: "searchBookmarks requires a query." };
  try {
    let searchParams = { query }, results = (await PlacesUtils.bookmarks.search(searchParams)).map((bookmark) => ({
      id: bookmark.guid,
      title: bookmark.title,
      url: bookmark?.url?.href,
      parentID: bookmark.parentGuid
    }));
    return PREFS2.debugLog(`Found ${results.length} bookmarks for query "${query}":`, results), { bookmarks: results };
  } catch (e) {
    return PREFS2.debugError(`Error searching bookmarks for query "${query}":`, e), { error: "Failed to search bookmarks." };
  }
}
async function getAllBookmarks() {
  try {
    let results = (await PlacesUtils.bookmarks.search({})).map((bookmark) => ({
      id: bookmark.guid,
      title: bookmark.title,
      url: bookmark?.url?.href,
      parentID: bookmark.parentGuid
    }));
    return PREFS2.debugLog(`Read ${results.length} total bookmarks.`), { bookmarks: results };
  } catch (e) {
    return PREFS2.debugError("Error reading all bookmarks:", e), { error: "Failed to read all bookmarks." };
  }
}
async function createBookmark(args) {
  let { url, title, parentID } = args;
  if (!url)
    return { error: "createBookmark requires a URL." };
  try {
    let bookmarkInfo = {
      parentGuid: parentID || PlacesUtils.bookmarks.toolbarGuid,
      url: new URL(url),
      title: title || url
    }, bm = await PlacesUtils.bookmarks.insert(bookmarkInfo);
    return PREFS2.debugLog("Bookmark created successfully:", JSON.stringify(bm)), { result: `Successfully bookmarked "${bm.title}".` };
  } catch (e) {
    return PREFS2.debugError(`Error creating bookmark for URL "${url}":`, e), { error: "Failed to create bookmark." };
  }
}
async function addBookmarkFolder(args) {
  let { title, parentID } = args;
  if (!title)
    return { error: "addBookmarkFolder requires a title." };
  try {
    let folderInfo = {
      parentGuid: parentID || PlacesUtils.bookmarks.toolbarGuid,
      type: PlacesUtils.bookmarks.TYPE_FOLDER,
      title
    }, folder = await PlacesUtils.bookmarks.insert(folderInfo);
    return PREFS2.debugLog("Bookmark folder created successfully:", JSON.stringify(folderInfo)), { result: `Successfully created folder "${folder.title}".` };
  } catch (e) {
    return PREFS2.debugError(`Error creating bookmark folder "${title}":`, e), { error: "Failed to create folder." };
  }
}
async function updateBookmark(args) {
  let { id, url, title, parentID } = args;
  if (!id)
    return { error: "updateBookmark requires a bookmark id (guid)." };
  if (!url && !title && !parentID)
    return {
      error: "updateBookmark requires either a new url, title, or parentID."
    };
  try {
    let oldBookmark = await PlacesUtils.bookmarks.fetch(id);
    if (!oldBookmark)
      return { error: `No bookmark found with id "${id}".` };
    let bm = await PlacesUtils.bookmarks.update({
      guid: id,
      url: url ? new URL(url) : oldBookmark.url,
      title: title || oldBookmark.title,
      parentGuid: parentID || oldBookmark.parentGuid
    });
    return PREFS2.debugLog("Bookmark updated successfully:", JSON.stringify(bm)), { result: `Successfully updated bookmark to "${bm.title}".` };
  } catch (e) {
    return PREFS2.debugError(`Error updating bookmark with id "${id}":`, e), { error: "Failed to update bookmark." };
  }
}
async function deleteBookmark(args) {
  let { id } = args;
  if (!id)
    return { error: "deleteBookmark requires a bookmark id (guid)." };
  try {
    return await PlacesUtils.bookmarks.remove(id), PREFS2.debugLog(`Bookmark with id "${id}" deleted successfully.`), { result: "Successfully deleted bookmark." };
  } catch (e) {
    return PREFS2.debugError(`Error deleting bookmark with id "${id}":`, e), { error: "Failed to delete bookmark." };
  }
}
async function getAllWorkspaces() {
  try {
    let { workspaces } = await gZenWorkspaces._workspaces(), activeWorkspaceId = gZenWorkspaces.activeWorkspace;
    return { workspaces: workspaces.map((ws) => ({
      id: ws.uuid,
      name: ws.name,
      icon: ws.icon,
      position: ws.position,
      isActive: ws.uuid === activeWorkspaceId
    })) };
  } catch (e) {
    return PREFS2.debugError("Failed to get all workspaces:", e), { error: "Failed to retrieve workspaces." };
  }
}
async function createWorkspace(args) {
  let { name, icon } = args;
  if (!name)
    return { error: "createWorkspace requires a name." };
  try {
    let ws = await gZenWorkspaces.createAndSaveWorkspace(name, icon, !1);
    return {
      result: `Successfully created workspace "${name}".`,
      workspace: { id: ws.uuid, name: ws.name, icon: ws.icon }
    };
  } catch (e) {
    return PREFS2.debugError("Failed to create workspace:", e), { error: "Failed to create workspace." };
  }
}
async function updateWorkspace(args) {
  let { id, name, icon } = args;
  if (!id)
    return { error: "updateWorkspace requires a workspace id." };
  if (!name && !icon)
    return { error: "updateWorkspace requires a new name or icon." };
  try {
    let workspace = gZenWorkspaces.getWorkspaceFromId(id);
    if (!workspace)
      return { error: `Workspace with id ${id} not found.` };
    if (name)
      workspace.name = name;
    if (icon)
      workspace.icon = icon;
    return await gZenWorkspaces.saveWorkspace(workspace), { result: "Successfully updated workspace." };
  } catch (e) {
    return PREFS2.debugError("Failed to update workspace:", e), { error: "Failed to update workspace." };
  }
}
async function deleteWorkspace(args) {
  let { id } = args;
  if (!id)
    return { error: "deleteWorkspace requires a workspace id." };
  try {
    return await gZenWorkspaces.removeWorkspace(id), { result: "Successfully deleted workspace." };
  } catch (e) {
    return PREFS2.debugError("Failed to delete workspace:", e), { error: "Failed to delete workspace." };
  }
}
async function moveTabsToWorkspace(args) {
  let { tabIds, workspaceId } = args;
  if (!tabIds || !workspaceId)
    return { error: "moveTabsToWorkspace requires tabIds and a workspaceId." };
  try {
    let tabs = getTabsByIds(tabIds);
    if (tabs.length === 0)
      return { error: "No valid tabs found to move." };
    return gZenWorkspaces.moveTabsToWorkspace(tabs, workspaceId), { result: `Successfully moved ${tabs.length} tab(s) to workspace.` };
  } catch (e) {
    return PREFS2.debugError("Failed to move tabs to workspace:", e), { error: "Failed to move tabs to workspace." };
  }
}
async function reorderWorkspace(args) {
  let { id, newPosition } = args;
  if (!id || typeof newPosition !== "number")
    return { error: "reorderWorkspace requires a workspace id and a newPosition." };
  try {
    return await gZenWorkspaces.reorderWorkspace(id, newPosition), { result: "Successfully reordered workspace." };
  } catch (e) {
    return PREFS2.debugError("Failed to reorder workspace:", e), { error: "Failed to reorder workspace." };
  }
}
async function clickElement(args) {
  let { selector } = args;
  if (!selector)
    return { error: "clickElement requires a selector." };
  return messageManagerAPI.clickElement(selector);
}
async function fillForm(args) {
  let { selector, value } = args;
  if (!selector)
    return { error: "fillForm requires a selector." };
  if (value === void 0)
    return { error: "fillForm requires a value." };
  return messageManagerAPI.fillForm(selector, value);
}
async function showCustomToast(args) {
  let { title, description } = args;
  if (!title)
    return { error: "showToast requires a title." };
  try {
    return showToast({
      title,
      description,
      preset: 0
    }), { result: "Toast displayed successfully." };
  } catch (e) {
    return PREFS2.debugError("Failed to show toast:", e), { error: "An error occurred while displaying the toast." };
  }
}
async function getYoutubeComments(args) {
  return messageManagerAPI.getYoutubeComments(args.count);
}
var toolNameMapping = {
  search: "Searching the web",
  openLink: "Opening a link",
  newSplit: "Creating a split view",
  splitExistingTabs: "Splitting existing tabs",
  getAllTabs: "Reading tabs",
  searchTabs: "Searching tabs",
  closeTabs: "Closing tabs",
  reorderTab: "Reordering a tab",
  addTabsToFolder: "Adding tabs to a folder",
  removeTabsFromFolder: "Removing tabs from a folder",
  createTabFolder: "Creating a tab folder",
  addTabsToEssentials: "Adding tabs to Essentials",
  removeTabsFromEssentials: "Removing tabs from Essentials",
  getPageTextContent: "Reading page content",
  getHTMLContent: "Reading page source code",
  clickElement: "Clicking an element",
  fillForm: "Filling a form",
  getYoutubeTranscript: "Getting YouTube transcript",
  getYoutubeDescription: "Getting YouTube description",
  getYoutubeComments: "Getting YouTube comments",
  searchBookmarks: "Searching bookmarks",
  getAllBookmarks: "Reading bookmarks",
  createBookmark: "Creating a bookmark",
  addBookmarkFolder: "Creating a bookmark folder",
  updateBookmark: "Updating a bookmark",
  deleteBookmark: "Deleting a bookmark",
  getAllWorkspaces: "Reading workspaces",
  createWorkspace: "Creating a workspace",
  updateWorkspace: "Updating a workspace",
  deleteWorkspace: "Deleting a workspace",
  moveTabsToWorkspace: "Moving tabs to a workspace",
  reorderWorkspace: "Reordering a workspace",
  showToast: "Showing a notification"
}, tabsInstructions = "If you open tab in glace it will create new small popup window to show the tab, vsplit and hsplit means it will open new tab in vertical and horizontal split with current tab respectively.", toolGroups = {
  search: {
    moreInstructions: async () => {
      let engineNames = (await Services.search.getVisibleEngines()).map((e) => e.name).join(", "), defaultEngineName = Services.search.defaultEngine.name;
      return `For the search tool, available engines are: ${engineNames}. The default is '${defaultEngineName}'.
` + tabsInstructions;
    },
    tools: {
      search: createTool("Performs a web search using a specified search engine and opens the results.", {
        searchTerm: createStringParameter("The term to search for."),
        engineName: createStringParameter("The name of the search engine to use.", !0),
        where: createStringParameter("Where to open results. Options: 'current tab', 'new tab', 'new window', 'incognito', 'glance', 'vsplit', 'hsplit'. Default: 'new tab'.", !0)
      }, search)
    },
    example: async () => {
      return `#### Searching and Spliting: 
-   **User Prompt:** "search cat in google and dog in youtube open them in vertical split"
-   **Your first Tool Call:** \`{"functionCall": {"name": "search", "args": {"searchTerm": "cat", "engineName": "google", where: "new tab"}}}\`
-   **Your second Tool Call:** \`{"functionCall": {"name": "search", "args": {"searchTerm": "dog", "engineName": "youtube", where: "vsplit"}}}\`
Note: Only second search is open in split (vertial by default), this will make it split with first search.
`;
    }
  },
  navigation: {
    moreInstructions: tabsInstructions + "While opening tab make sure it has valid URL.",
    tools: {
      openLink: createTool("Opens a given URL in a specified location. Can also create a split view with the current tab.", {
        link: createStringParameter("The URL to open."),
        where: createStringParameter("Where to open the link. Options: 'current tab', 'new tab', 'new window', 'incognito', 'glance', 'vsplit', 'hsplit'. Default: 'new tab'.", !0)
      }, openLink),
      newSplit: createTool("Creates a split view by opening multiple new URLs in new tabs, then arranging them side-by-side.", {
        links: createStringArrayParameter("An array of URLs for the new tabs."),
        type: createStringParameter("The split type: 'vertical', 'horizontal', or 'grid'. Defaults to 'vertical'.", !0)
      }, newSplit),
      splitExistingTabs: createTool("Creates a split view from existing open tabs.", {
        tabIds: createStringArrayParameter("An array of tab session IDs to split."),
        type: createStringParameter("The split type: 'vertical', 'horizontal', or 'grid'. Defaults to 'vertical'.", !0)
      }, splitExistingTabs)
    },
    example: async () => `#### Opening a Single Link:
-   **User Prompt:** "open github"
-   **Your Tool Call:** \`{"functionCall": {"name": "openLink", "args": {"link": "https://github.com", "where": "new tab"}}}\`

#### Creating a Split View with New Pages:
-   **User Prompt:** "show me youtube and twitch side by side"
-   **Your Tool Call:** \`{"functionCall": {"name": "newSplit", "args": {"links": ["https://youtube.com", "https://twitch.tv"], "type": "vertical"}}}\`

#### Splitting Existing Tabs:
-   **User Prompt:** "Make all my open youtube tabs in grid"
-   **Your First Tool Call:** \`{"functionCall": {"name": "getAllTabs", "args": {}}}\`
-   **Your Second Tool Call (after getting tab IDs):** \`{"functionCall": {"name": "splitExistingTabs", "args": {"tabIds": ["x", "y", ...]}, "type": "grid"}}\``
  },
  tabs: {
    moreInstructions: `Zen browser has advanced tab management features they are:
- Workspaces: Different workspace can contain different tabs (pinned and unpinned).
- Essential: Essential tabs are not workspace specific, they are most important tabs and they are always shown dispite of current workspace.
- Tab folders: Similar tabs can be made in folders to organize it in better way (it is also called tab group).
- Split tabs: Zen allows to view multiple tabs at same time by splitting.

The tool getAllTabs is super super useful, tool you can use it in multiple case for tab/workspace management. Don't ask conformative questions to user like when user's input is clear. Like when user asks you to close tabs don't ask them "Do you really want to close those tabs ... ".
More importantly, please don't use IDs of folder/tabs/workspace while talking to user, refere them by name not id. User might not know the ids of tabs.
**Never** mention tabId or groupId with the user. Don't ask for Id if you need Id to filfill user's request you have to read it yourself.
`,
    tools: {
      getAllTabs: createTool("Retrieves all open tabs. Also provides more information about tabs like id, title, url, isCurrent, inCurrentWorkspace, workspace, workspaceName, workspaceIcon, pinned, isGroup, isEssential, parentFolderId, parentFolderName, isSplitView, splitViewId.", {}, getAllTabs),
      searchTabs: createTool("Searches open tabs by title or URL. Similar to `getAllTabs` this will also provide more information about tab.", { query: createStringParameter("The search term for tabs.") }, searchTabs),
      closeTabs: createTool("Closes one or more tabs.", { tabIds: createStringArrayParameter("An array of tab session IDs to close.") }, closeTabs),
      reorderTab: createTool("Reorders a tab to a new index.", {
        tabId: createStringParameter("The session ID of the tab to reorder."),
        newIndex: z.number().describe("The new index for the tab.")
      }, reorderTab),
      addTabsToFolder: createTool("Adds one or more tabs to a folder.", {
        tabIds: createStringArrayParameter("The session IDs of the tabs to add."),
        folderId: createStringParameter("The ID of the folder to add the tabs to.")
      }, addTabsToFolder),
      removeTabsFromFolder: createTool("Removes one or more tabs from their folder.", {
        tabIds: createStringArrayParameter("The session IDs of the tabs to remove from their folder.")
      }, removeTabsFromFolder),
      createTabFolder: createTool("Creates a new, empty tab folder.", {
        name: createStringParameter("The name for the new folder.")
      }, createTabFolder),
      addTabsToEssentials: createTool("Adds one or more tabs to the essentials.", { tabIds: createStringArrayParameter("An array of session IDs to add to essentials.") }, addTabsToEssentials),
      removeTabsFromEssentials: createTool("Removes one or more tabs from the essentials.", {
        tabIds: createStringArrayParameter("An array of session IDs to remove from essentials.")
      }, removeTabsFromEssentials)
    },
    example: async () => `#### Finding and Closing Tabs:
-   **User Prompt:** "close all youtube tabs"
-   **Your First Tool Call:** \`{"functionCall": {"name": "searchTabs", "args": {"query": "youtube.com"}}}\`
-   **Your Second Tool Call (after receiving tab IDs):** \`{"functionCall": {"name": "closeTabs", "args": {"tabIds": ["1", "2"]}}}\`

#### Creating a Folder and Adding Tabs:
-   **User Prompt:** "create a new folder called 'Social Media' and add all my facebook tab to it"
-   **Your First Tool Call (to get tab ID):** \`{"functionCall": {"name": "searchTabs", "args": {"query": "facebook.com"}}}\`
-   **Your Second Tool Call (to create folder):** \`{"functionCall": {"name": "createTabFolder", "args": {"name": "Social Media"}}}\`
-   **Your Third Tool Call (after getting IDs):** \`{"functionCall": {"name": "addTabsToFolder", "args": {"tabIds": ["3", ...], "folderId": "folder-123"}}}\`

#### Making a Tab Essential:
-   **User Prompt:** "make my current tab essential"
-   **Your First Tool Call:** \`{"functionCall": {"name": "getAllTabs", "args": {}}}\`
-   **Your Second Tool Call (after finding the current tab ID):** \`{"functionCall": {"name": "addTabsToEssentials", "args": {"tabIds": ["5"]}}}\``
  },
  pageInteraction: {
    tools: {
      getPageTextContent: createTool("Retrieves the text content of the current web page to answer questions. Only use if the initial context is insufficient to answer user's question or fulfill user's command.", {}, messageManagerAPI.getPageTextContent.bind(messageManagerAPI)),
      getHTMLContent: createTool("Retrieves the full HTML source of the current web page for detailed analysis. Use this tool very rarely, only when text content is insufficient.", {}, messageManagerAPI.getHTMLContent.bind(messageManagerAPI)),
      clickElement: createTool("Clicks an element on the page.", {
        selector: createStringParameter("The CSS selector of the element to click.")
      }, clickElement),
      fillForm: createTool("Fills a form input on the page.", {
        selector: createStringParameter("The CSS selector of the input element to fill."),
        value: createStringParameter("The value to fill the input with.")
      }, fillForm)
    },
    example: async () => `#### Reading the Current Page for Context
-   **User Prompt:** "summarize this page for me"
-   **Your Tool Call:** \`{"functionCall": {"name": "getPageTextContent", "args": {}}}\`
-   And you summarize the page as per user's requirements.

#### Finding and Clicking a Link on the Current Page
-   **User Prompt:** "click on the contact link"
-   **Your First Tool Call:** \`{"functionCall": {"name": "getHTMLContent", "args": {}}}\`
-   **Your Second Tool Call (after receiving HTML and finding the link):** \`{"functionCall": {"name": "clickElement", "args": {"selector": "#contact-link"}}}\`

#### Filling a form:
-   **User Prompt:** "Fill the name with John and submit"
-   **Your First Tool Call:** \`{"functionCall": {"name": "getHTMLContent", "args": {}}}\`
-   **Your Second Tool Call:** \`{"functionCall": {"name": "fillForm", "args": {"selector": "#name", "value": "John"}}}\`
-   **Your Third Tool Call:** \`{"functionCall": {"name": "clickElement", "args": {"selector": "#submit-button"}}}\`
Note: you must run tool getHTMLContent before clicking button or filling form to make sure element exists.
`
  },
  youtube: {
    tools: {
      getYoutubeTranscript: createTool("Retrieves the transcript of the current YouTube video. Only use if the current page is a YouTube video.", {}, messageManagerAPI.getYoutubeTranscript.bind(messageManagerAPI)),
      getYoutubeDescription: createTool("Retrieves the description of the current YouTube video. Only use if the current page is a YouTube video.", {}, messageManagerAPI.getYoutubeDescription.bind(messageManagerAPI)),
      getYoutubeComments: createTool("Retrieves top-level comments from the current YouTube video. Only use if the current page is a YouTube video.", {
        count: z.number().optional().describe("The maximum number of comments to retrieve. Defaults to 10.")
      }, getYoutubeComments)
    },
    example: async () => `#### Getting YouTube Video Details:
-   **User Prompt:** "Summarize this Youtube Video in 5 bullet points"
-   **Your Tool Call:** \`{"functionCall": {"name": "getYoutubeTranscript"}}\`
-   And you summarize the video as per user's requirements.

#### Reading Youtube Comments:
-   **User Prompt:** "What are the user's feedback on this video"
-   **Your Tool Call:** \`{"functionCall": {"name": "getYoutubeComments", count: 20}}\`
-   And Based on comments you tell user about the user's feedback on video.
`
  },
  bookmarks: {
    tools: {
      searchBookmarks: createTool("Searches bookmarks based on a query.", {
        query: createStringParameter("The search term for bookmarks.")
      }, searchBookmarks),
      getAllBookmarks: createTool("Retrieves all bookmarks.", {}, getAllBookmarks),
      createBookmark: createTool("Creates a new bookmark.", {
        url: createStringParameter("The URL to bookmark."),
        title: createStringParameter("The title for the bookmark.", !0),
        parentID: createStringParameter("The GUID of the parent folder.", !0)
      }, createBookmark),
      addBookmarkFolder: createTool("Creates a new bookmark folder.", {
        title: createStringParameter("The title for the new folder."),
        parentID: createStringParameter("The GUID of the parent folder.", !0)
      }, addBookmarkFolder),
      updateBookmark: createTool("Updates an existing bookmark.", {
        id: createStringParameter("The GUID of the bookmark to update."),
        url: createStringParameter("The new URL for the bookmark.", !0),
        title: createStringParameter("The new title for the bookmark.", !0),
        parentID: createStringParameter("The GUID of the parent folder.", !0)
      }, updateBookmark),
      deleteBookmark: createTool("Deletes a bookmark.", {
        id: createStringParameter("The GUID of the bookmark to delete.")
      }, deleteBookmark)
    },
    example: async () => `#### Finding and Editing a bookmark by folder name:
-   **User Prompt:** "Move bookmark titled 'Example' to folder 'MyFolder'"
-   **Your First Tool Call:** \`{"functionCall": {"name": "searchBookmarks", "args": {"query": "Example"}}}\`
-   **Your Second Tool Call:** \`{"functionCall": {"name": "searchBookmarks", "args": {"query": "MyFolder"}}}\`
-   **Your Third Tool Call (after receiving the bookmark and folder ids):** \`{"functionCall": {"name": "updateBookmark", "args": {"id": "xxxxxxxxxxxx", "parentID": "yyyyyyyyyyyy"}}}\`
Note that first and second tool clls can be made in parallel, but the third tool call needs output from the first and second tool calls so it must be made after first and second.`
  },
  workspaces: {
    moreInstructions: `Zen browser has advanced tab management features and one of them is workspace.
Different workspace can contain different tabs (pinned and unpinned). A workspace has it's own icon (most likely a emoji sometimes even URL), name and it has tabs inside workspace. While creating new workspace if user don't specify icon use most logical emoji you could find but don't use text make sure to use emoji.
If tab is essential which means does not belong to any specific workspace.

**Never** mention worksapceId with the user. Don't ask for Id if you need Id to filfill user's request you have to read it yourself.
`,
    tools: {
      getAllWorkspaces: createTool("Retrieves all workspaces with id, name, icon, position and isActive.", {}, getAllWorkspaces),
      createWorkspace: createTool("Creates a new workspace.", {
        name: createStringParameter("The name for the new workspace."),
        icon: createStringParameter("The icon (emoji or URL) for the new workspace.", !0)
      }, createWorkspace),
      updateWorkspace: createTool("Updates an existing workspace (name and icon).", {
        id: createStringParameter("The ID of the workspace to update."),
        name: createStringParameter("The new name for the workspace.", !0),
        icon: createStringParameter("The new icon for the workspace.", !0)
      }, updateWorkspace),
      deleteWorkspace: createTool("Deletes a workspace.", { id: createStringParameter("The ID of the workspace to delete.") }, deleteWorkspace),
      moveTabsToWorkspace: createTool("Moves tabs to a specified workspace.", {
        tabIds: createStringArrayParameter("The session IDs of the tabs to move."),
        workspaceId: createStringParameter("The ID of the target workspace.")
      }, moveTabsToWorkspace),
      reorderWorkspace: createTool("Reorders a workspace to a new position.", {
        id: createStringParameter("The ID of the workspace to reorder."),
        newPosition: z.number().describe("The new zero-based index for the workspace.")
      }, reorderWorkspace)
    }
  },
  uiFeedback: {
    tools: {
      showToast: createTool("Shows a temporary toast message to the user.", {
        title: createStringParameter("The main title of the toast message."),
        description: createStringParameter("Optional secondary text for the toast.", !0)
      }, showCustomToast)
    },
    example: async () => '#### Showing a Toast Notification:\n-   **User Prompt:** "let me know when the download is complete"\n-   **Your Tool Call (after a long-running task):** `{"functionCall": {"name": "showToast", "args": {"title": "Download Complete", "description": "The file has been saved to your downloads folder."}}}`'
  },
  misc: {
    example: async (activeGroups) => {
      let example = "";
      if (activeGroups.has("workspaces") && activeGroups.has("tabs"))
        example += `#### Creating and Managing a Workspace:
-   **User Prompt:** "make a new workspace called 'Research', then move all tabs related to animals in that workspace."
-   **Your First Tool Call:** \`{"functionCall": {"name": "getAllTabs", "args": {}}}\`
-   **Your Second Tool Call:** \`{"functionCall": {"name": "createWorkspace", "args": {"name": "Research"}}}\`
-   **Your Third Tool Call (after getting the new workspace ID and reading all tabs):** \`{"functionCall": {"name": "moveTabsToWorkspace", "args": {"tabIds": ["x", "y", ...], "workspaceId": "e1f2a3b4-c5d6..."}}}\`

#### Advanced tabs management (using tools related to folder and workspace to manage tabs)
-   **User Prompt:** "Manage my tabs"
-   **Your First Tool Call:** \`{"functionCall": {"name": "getAllTabs", "args": {}}}\`
-   **Your Second Tool Call:**(based on all tabs) \`{"functionCall": {"name": "createTabFolder", "args": {"name": "..."}}}\`
-   **Your Third Tool Call (based on all tabs):** \`{"functionCall": {"name": "addTabsToFolder", "args": {"tabIds": ["x", "y", ...] }}}\`
-   **Your Fourth Tool Call (based on all tabs):** \`{"functionCall": {"name": "moveTabsToWorkspace", "args": {"tabIds": ["x", "y", ...], "workspaceId": "e1f2a3b4-c5d6..."}}}\`
-   Go on keep making tool calls until tabs are managed (note here you should not ask any question to user for conformation).

`;
      return example;
    }
  }
}, getTools = (groups, { shouldToolBeCalled, afterToolCall } = {}) => {
  let selectedTools = (() => {
    if (!groups || !Array.isArray(groups) || groups.length === 0)
      return Object.entries(toolGroups).reduce((acc, [name, group]) => {
        if (name !== "misc" && group.tools)
          return { ...acc, ...group.tools };
        return acc;
      }, {});
    return groups.reduce((acc, groupName) => {
      if (toolGroups[groupName] && toolGroups[groupName].tools)
        return { ...acc, ...toolGroups[groupName].tools };
      return acc;
    }, {});
  })();
  if (!shouldToolBeCalled && !afterToolCall)
    return selectedTools;
  let wrappedTools = {};
  for (let toolName in selectedTools) {
    let originalTool = selectedTools[toolName], newTool = { ...originalTool }, originalExecute = originalTool.execute;
    newTool.execute = async (args) => {
      if (shouldToolBeCalled && !await shouldToolBeCalled(toolName))
        return PREFS2.debugLog(`Tool execution for '${toolName}' was denied by shouldToolBeCalled.`), { error: `Tool execution for '${toolName}' was denied by user.` };
      let result = await originalExecute(args);
      if (afterToolCall)
        afterToolCall(toolName, result);
      return result;
    }, wrappedTools[toolName] = newTool;
  }
  return wrappedTools;
}, getToolSystemPrompt = async (groups, includeExamples = !0) => {
  try {
    let activeGroupNames = groups && Array.isArray(groups) && groups.length > 0 ? groups : Object.keys(toolGroups).filter((g) => g !== "misc"), activeGroups = new Set(activeGroupNames), availableTools = [], toolExamples = [];
    for (let groupName of activeGroupNames) {
      let group = toolGroups[groupName];
      if (group) {
        if (group.tools)
          for (let toolName in group.tools) {
            let tool2 = group.tools[toolName], params = Object.keys(tool2.inputSchema.shape).join(", ");
            availableTools.push(`- \`${toolName}(${params})\`: ${tool2.description}`);
          }
        if (group.moreInstructions) {
          let instructions = typeof group.moreInstructions === "function" ? await group.moreInstructions() : group.moreInstructions;
          availableTools.push(instructions);
        }
        if (includeExamples && group.example)
          toolExamples.push(await group.example(activeGroups));
      }
    }
    if (includeExamples && toolGroups.misc && toolGroups.misc.example) {
      let miscExample = await toolGroups.misc.example(activeGroups);
      if (miscExample)
        toolExamples.push(miscExample);
    }
    let systemPrompt = `
## Available Tools:
${availableTools.join(`
`)}
`;
    if (includeExamples && toolExamples.length > 0)
      systemPrompt += `
## Tool Call Examples:
These are just examples for you on how you can use tools calls, each example gives you some concept, the concept is not specific to single tool.

${toolExamples.join(`

`)}
`;
    return systemPrompt;
  } catch (error) {
    return PREFS2.debugError("Error in getToolSystemPrompt:", error), "";
  }
};

// findbar-ai/findbar-ai.uc.js
var icons = {
  loading: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="var(--browse-bot-muted)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" width="100%" height="100%"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>',
  success: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="var(--browse-bot-success)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" width="100%" height="100%"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>',
  error: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="var(--browse-bot-error)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" width="100%" height="100%"><circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/></svg>',
  declined: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="var(--browse-bot-warning)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" width="100%" height="100%"><circle cx="12" cy="12" r="10"/><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"/></svg>'
}, getSidebarWidth = () => {
  if (gZenCompactModeManager && (!gZenCompactModeManager?.preference || !PREFS2.getPref("zen.view.compact.hide-tabbar")) && !gZenCompactModeManager.sidebarIsOnRight)
    return gZenCompactModeManager.getAndApplySidebarWidth();
  else
    return 0;
};
function updateSidebarWidth() {
  if (!PREFS2.pseudoBg)
    return;
  let mainWindow = document.getElementById("main-window"), width = getSidebarWidth();
  if (width)
    mainWindow.style.setProperty("--zen-sidebar-width", width + "px");
  setTimeout(() => browseBotFindbar._updateFindbarDimensions(), 2);
}
var sidebarWidthUpdate = function() {
  let mainWindow = document.getElementById("main-window"), attributes = ["zen-compact-mode", "zen-sidebar-expanded", "zen-right-side"];
  new MutationObserver((mutationsList) => {
    if (!PREFS2.pseudoBg)
      return;
    for (let mutation of mutationsList)
      if (mutation.type === "attributes" && attributes.includes(mutation.attributeName))
        updateSidebarWidth();
  }).observe(mainWindow, {
    attributes: !0,
    attributeFilter: attributes
  }), updateSidebarWidth();
};
sidebarWidthUpdate();
function parseMD(markdown, convertHTML = !0) {
  let htmlContent = parseElement('<div class="markdown-body"></div>');
  try {
    let parse = ChromeUtils.importESModule("chrome://userscripts/content/engine/utils/dom.mjs").default.parseMD, browserWindow = Services.wm.getMostRecentWindow("navigator:browser");
    parse(htmlContent, markdown, "", browserWindow || window);
  } catch {
    PREFS2.debugLog("Parsing markdown failed"), htmlContent.innerHTML = markdown;
  }
  if (convertHTML)
    return htmlContent;
  else
    return htmlContent.innerHTML;
}
PREFS2.setInitialPrefs();
var browseBotFindbar = {
  findbar: null,
  expandButton: null,
  chatContainer: null,
  apiKeyContainer: null,
  _updateFindbar: null,
  _addKeymaps: null,
  _handleInputKeyPress: null,
  _handleFindFieldInput: null,
  _handleFindbarOpenEvent: null,
  _handleFindbarCloseEvent: null,
  _isExpanded: !1,
  _updateContextMenuText: null,
  _agenticModeListener: null,
  _backgroundStylesListener: null,
  _citationsListener: null,
  _contextMenuEnabledListener: null,
  _persistListener: null,
  _minimalListener: null,
  _dndListener: null,
  contextMenuItem: null,
  _matchesObserver: null,
  _isDragging: !1,
  _startDrag: null,
  _stopDrag: null,
  _handleDrag: null,
  _initialContainerCoor: { x: null, y: null },
  _initialMouseCoor: { x: null, y: null },
  _startWidth: null,
  _resizeHandle: null,
  _isResizing: !1,
  _startResize: null,
  _stopResize: null,
  _handleResize: null,
  _handleResizeEnd: null,
  _toolConfirmationDialog: null,
  _highlightTimeout: null,
  _originalOnMatchesCountResult: null,
  _currentAIMessageDiv: null,
  _updateFindbarDimensions() {
    if (!this.findbar) {
      document.documentElement.style.removeProperty("--findbar-width"), document.documentElement.style.removeProperty("--findbar-height"), document.documentElement.style.removeProperty("--findbar-x"), document.documentElement.style.removeProperty("--findbar-y");
      return;
    }
    let rect = this.findbar.getBoundingClientRect(), _findbarDimension = { width: rect.width, height: rect.height }, _findbarCoors = { x: rect.left, y: rect.top };
    document.documentElement.style.setProperty("--findbar-width", `${_findbarDimension.width}px`), document.documentElement.style.setProperty("--findbar-height", `${_findbarDimension.height}px`), document.documentElement.style.setProperty("--findbar-x", `${_findbarCoors.x}px`), document.documentElement.style.setProperty("--findbar-y", `${_findbarCoors.y}px`);
  },
  _saveFindbarDimensions() {
    if (!this.findbar || !PREFS2.rememberDimensions)
      return;
    let rect = this.findbar.getBoundingClientRect();
    PREFS2.width = rect.width;
  },
  _applyFindbarDimensions() {
    if (!this.findbar || !PREFS2.rememberDimensions)
      return;
    let width = PREFS2.width;
    if (width)
      this.findbar.style.width = `${width}px`;
  },
  _isStreaming: !1,
  _abortController: null,
  get expanded() {
    return this._isExpanded;
  },
  set expanded(value) {
    let isChanged = value !== this._isExpanded;
    if (this._isExpanded = value, !this.findbar)
      return;
    if (this.findbar.expanded = value, isChanged)
      setTimeout(() => this._updateFindbarDimensions(), 2), setTimeout(() => this._updateFindbarDimensions(), 20);
    if (value) {
      if (this.findbar.classList.add("ai-expanded"), this.show(), this.showAIInterface(), isChanged)
        this.focusPrompt();
      let messagesContainer = this?.chatContainer?.querySelector("#chat-messages");
      if (messagesContainer)
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    } else {
      if (this._isStreaming)
        this._abortController?.abort();
      if (this.findbar.classList.remove("ai-expanded"), this.removeAIInterface(), isChanged && !this.minimal)
        this.focusInput();
    }
  },
  get enabled() {
    return PREFS2.enabled;
  },
  set enabled(value) {
    if (typeof value === "boolean")
      PREFS2.enabled = value;
  },
  handleEnabledChange(enabled) {
    if (enabled.value)
      this.init();
    else
      this.destroy();
  },
  get minimal() {
    return PREFS2.minimal;
  },
  set minimal(value) {
    if (typeof value === "boolean")
      PREFS2.minimal = value;
  },
  handleMinimalPrefChange: function() {
    this.removeExpandButton(), this.addExpandButton(), this.removeAIInterface(), this.showAIInterface();
  },
  createToolConfirmationDialog(toolNames) {
    return new Promise((resolve) => {
      let dialog = parseElement(`
        <div class="tool-confirmation-dialog">
          <div class="tool-confirmation-content">
            <p>Allow AI to do following tasks: ${toolNames?.join(", ")}?</p>
            <div class="buttons">
              <button class="not-again">Don't ask again</button>
              <div class="right-side-buttons">
                <button class="confirm-tool">Yes</button>
                <button class="cancel-tool">No</button>
              </div>
            </div>
          </div>
        </div>
      `);
      this._toolConfirmationDialog = dialog;
      let removeDilog = () => {
        dialog.remove(), this._toolConfirmationDialog = null;
      };
      dialog.querySelector(".confirm-tool").addEventListener("click", () => {
        removeDilog(), resolve(!0);
      }), dialog.querySelector(".cancel-tool").addEventListener("click", () => {
        removeDilog(), resolve(!1);
      }), dialog.querySelector(".not-again").addEventListener("click", () => {
        removeDilog(), PREFS2.conformation = !1, resolve(!0);
      }), document.body.appendChild(dialog);
    });
  },
  updateFindbar() {
    if (SettingsModal.hide(), this.removeExpandButton(), this.removeAIInterface(), this.disableResize(), !PREFS2.persistChat)
      this.hide(), this.expanded = !1, this.clear();
    gBrowser.getFindBar().then((findbar) => {
      if (this.findbar = findbar, this._applyFindbarDimensions(), this.addExpandButton(), PREFS2.persistChat) {
        if (this?.findbar?.history) {
          if (browseBotFindbarLLM.history = this.findbar.history, this?.findbar?.aiStatus && JSON.stringify(this.aiStatus) !== JSON.stringify(this.findbar.aiStatus))
            browseBotFindbarLLM.history = [], this.findbar.history = [];
        } else
          browseBotFindbarLLM.history = [];
        if (this?.findbar?.expanded && !this?.findbar?.hidden)
          setTimeout(() => this.expanded = !0, 200);
        else
          this.hide(), this.expanded = !1;
      } else
        this.hide(), this.expanded = !1;
      this.updateFindbarStatus(), setTimeout(() => {
        if (PREFS2.dndEnabled)
          this.enableResize();
        this._updateFindbarDimensions();
      }, 0);
      let matches = this.findbar.querySelector(".found-matches"), status = this.findbar.querySelector(".findbar-find-status"), wrapper = this.findbar.querySelector('hbox[anonid="findbar-textbox-wrapper"]');
      if (wrapper) {
        if (matches && matches.parentElement !== wrapper)
          wrapper.appendChild(matches);
        if (status && status.parentElement !== wrapper)
          wrapper.appendChild(status);
      }
      this.findbar._findField.removeEventListener("keypress", this._handleInputKeyPress), this.findbar._findField.addEventListener("keypress", this._handleInputKeyPress), this.findbar._findField.removeEventListener("input", this._handleFindFieldInput), this.findbar._findField.addEventListener("input", this._handleFindFieldInput);
    });
  },
  highlight(word) {
    if (!this.findbar)
      return;
    if (this._highlightTimeout)
      clearTimeout(this._highlightTimeout);
    this.findbar._find(word), this._highlightTimeout = setTimeout(() => {
      this.findbar.browser.finder.highlight(!1), this._highlightTimeout = null;
    }, 2000);
  },
  show() {
    if (!this.findbar)
      return !1;
    return this.findbar.open(), this.focusInput(), setTimeout(() => this._updateFindbarDimensions(), 0), !0;
  },
  hide() {
    if (!this.findbar)
      return !1;
    return this.findbar.close(), this.findbar.toggleHighlight(!1), setTimeout(() => this._updateFindbarDimensions(), 0), !0;
  },
  toggleVisibility() {
    if (!this.findbar)
      return;
    if (this.findbar.hidden)
      this.show();
    else
      this.hide();
  },
  clear() {
    if (browseBotFindbarLLM.clearData(), this.findbar)
      this.findbar.history = null;
    let messages = this?.chatContainer?.querySelector("#chat-messages");
    if (messages)
      messages.innerHTML = "";
    setTimeout(() => this._updateFindbarDimensions(), 1);
  },
  aiStatus: {
    citationsEnabled: PREFS2.citationsEnabled,
    agenticMode: PREFS2.agenticMode
  },
  updateFindbarStatus() {
    if (this.aiStatus = {
      agenticMode: PREFS2.agenticMode,
      citationsEnabled: PREFS2.citationsEnabled
    }, this.findbar)
      this.findbar.aiStatus = this.aiStatus;
  },
  createAPIKeyInterface() {
    let currentProviderName = browseBotFindbarLLM.currentProvider.name, menuItems = Object.entries(browseBotFindbarLLM.AVAILABLE_PROVIDERS).map(([name, provider]) => `
                  <menuitem
                    value="${name}"
                    label="${escapeXmlAttribute(provider.label)}"
                    ${name === currentProviderName ? 'selected="true"' : ""}
                    ${provider.faviconUrl ? `image="${escapeXmlAttribute(provider.faviconUrl)}"` : ""}
                  />
                `).join(""), menulistXul = `
        <menulist id="provider-selector" class="provider-selector" value="${currentProviderName}">
          <menupopup>
            ${menuItems}
          </menupopup>
        </menulist>`, providerSelectorXulElement = parseElement(menulistXul, "xul"), html = `
        <div class="browse-bot-setup">
          <div class="ai-setup-content">
            <h3>AI Setup Required</h3>
            <p>To use AI features, you need to set up your API key and select a provider.</p>
            <div class="provider-selection-group">
              <label for="provider-selector">Select Provider:</label>
            </div>
            <div class="api-key-input-group">
              <input type="password" id="api-key" placeholder="Enter your API key" />
              <button id="save-api-key">Save</button>
            </div>
            <div class="api-key-links">
              <button id="get-api-key-link">Get API Key</button>
            </div>
          </div>
        </div>`, container = parseElement(`
        <div class="browse-bot-setup">
          <div class="ai-setup-content">
            <h3>AI Setup Required</h3>
            <p>To use AI features, you need to set up your API key and select a provider.</p>
            <div class="provider-selection-group">
              <label for="provider-selector">Select Provider:</label>
            </div>
            <div class="api-key-input-group">
              <input type="password" id="api-key" placeholder="Enter your API key" />
              <button id="save-api-key">Save</button>
            </div>
            <div class="api-key-links">
              <button id="get-api-key-link">Get API Key</button>
            </div>
          </div>
        </div>`);
    container.querySelector(".provider-selection-group").appendChild(providerSelectorXulElement);
    let providerSelector = container.querySelector("#provider-selector"), input = container.querySelector("#api-key"), saveBtn = container.querySelector("#save-api-key"), getApiKeyLink = container.querySelector("#get-api-key-link"), description = container.querySelector(".ai-setup-content").querySelector("p"), updateUIForProvider = (providerName) => {
      let provider = browseBotFindbarLLM.AVAILABLE_PROVIDERS[providerName];
      if (providerName === "ollama")
        description.textContent = "Ollama is selected. You can customize the Base URL below or use the default.", input.type = "text", input.placeholder = "Enter Ollama Base URL", input.value = PREFS2.ollamaBaseUrl || "", getApiKeyLink.style.display = "none";
      else
        description.textContent = "To use AI features, you need to set up your API key and select a provider.", input.type = "password", input.placeholder = "Enter your API key", input.value = provider.apiKey || "", getApiKeyLink.style.display = provider.apiKeyUrl ? "inline-block" : "none", getApiKeyLink.disabled = !provider.apiKeyUrl, getApiKeyLink.title = provider.apiKeyUrl ? "Get API Key" : "No API key link available for this provider.";
    };
    return updateUIForProvider(currentProviderName), providerSelector.addEventListener("command", (e) => {
      let selectedProviderName = e.target.value;
      browseBotFindbarLLM.setProvider(selectedProviderName), updateUIForProvider(selectedProviderName);
    }), getApiKeyLink.addEventListener("click", () => {
      openTrustedLinkIn(browseBotFindbarLLM.currentProvider.apiKeyUrl, "tab");
    }), saveBtn.addEventListener("click", () => {
      let value = input.value.trim();
      if (browseBotFindbarLLM.currentProvider.name === "ollama") {
        if (value)
          PREFS2.ollamaBaseUrl = value;
        this.showAIInterface();
      } else if (value)
        browseBotFindbarLLM.currentProvider.apiKey = value, this.showAIInterface();
    }), input.addEventListener("keypress", (e) => {
      if (e.key === "Enter")
        saveBtn.click();
    }), container;
  },
  _removeToolCallUI() {
    if (!this._currentAIMessageDiv)
      return;
    let container = this._currentAIMessageDiv.querySelector(".tool-calls-container");
    if (container)
      container.remove(), setTimeout(() => this._updateFindbarDimensions(), 0);
  },
  _createOrUpdateToolCallUI(toolName, status, errorMsg = null) {
    let messageDiv = this._currentAIMessageDiv;
    if (!messageDiv)
      return;
    let container = messageDiv.querySelector(".tool-calls-container"), messageContent = messageDiv.querySelector(".message-content");
    if (!container)
      if (container = parseElement('<div class="tool-calls-container"></div>'), messageContent)
        messageDiv.insertBefore(container, messageContent);
      else
        messageDiv.appendChild(container);
    let friendlyName = toolNameMapping[toolName] || toolName;
    container.querySelectorAll('.tool-call-status[data-status="loading"]').forEach((item) => item.remove());
    let toolDiv = parseElement(`
<div class="tool-call-status" data-tool-name="${toolName} data-status="${status}">
  <span class="tool-call-icon">${icons[status] || ""}</span>
  <span class="tool-call-name">${friendlyName}</span>
</div>
`);
    container.appendChild(toolDiv);
    let title = friendlyName;
    if (status === "error" && errorMsg)
      title += `
Error: ${errorMsg}`;
    else if (status === "declined")
      title += `
Declined by user.`;
    toolDiv.setAttribute("tooltiptext", title), messageDiv.scrollTop = messageDiv.scrollHeight, setTimeout(() => this._updateFindbarDimensions(), 0);
  },
  async sendMessage(prompt) {
    if (!prompt || this._isStreaming)
      return;
    this.show(), this.expanded = !0, this.addChatMessage({ role: "user", content: prompt });
    let messagesContainer = this.chatContainer.querySelector("#chat-messages");
    this._abortController = new AbortController, this._toggleStreamingControls(!0);
    let aiMessageDiv = parseElement(`<div class="chat-message chat-message-ai">
        <div class="message-content">
          <div class="markdown-body"></div>
        </div>
      </div>`), contentDiv = aiMessageDiv.querySelector(".markdown-body");
    if (messagesContainer)
      messagesContainer.appendChild(aiMessageDiv), messagesContainer.scrollTop = messagesContainer.scrollHeight;
    this._currentAIMessageDiv = aiMessageDiv;
    try {
      let resultPromise = browseBotFindbarLLM.sendMessage(prompt, this._abortController.signal);
      if (PREFS2.citationsEnabled || !PREFS2.streamEnabled) {
        let loadingIndicator = this.createLoadingIndicator();
        messagesContainer.appendChild(loadingIndicator), messagesContainer.scrollTop = messagesContainer.scrollHeight;
        try {
          let result = await resultPromise;
          if (loadingIndicator.parentNode)
            loadingIndicator.remove();
          if (PREFS2.citationsEnabled) {
            let { answer, citations } = result;
            if (citations && citations.length > 0)
              aiMessageDiv.dataset.citations = JSON.stringify(citations);
            let textToParse = answer.replace(/\[(\d+)\]/g, '<span class="citation-link" data-citation-id="$1">[$1]</span>');
            contentDiv.appendChild(parseMD(textToParse));
          } else if (result.text.trim() === "" && aiMessageDiv.querySelector(".tool-calls-container"))
            contentDiv.innerHTML = parseMD("*(Tool actions performed)*", !1);
          else if (result.text.trim() === "" && !aiMessageDiv.querySelector(".tool-calls-container"))
            aiMessageDiv.remove();
          else
            contentDiv.appendChild(parseMD(result.text));
        } finally {
          if (loadingIndicator.parentNode)
            loadingIndicator.remove();
          messagesContainer.scrollTop = messagesContainer.scrollHeight, setTimeout(() => this._updateFindbarDimensions(), 0);
        }
      } else {
        let result = await resultPromise, fullText = "";
        for await (let delta of result.textStream) {
          fullText += delta;
          try {
            contentDiv.innerHTML = parseMD(fullText, !1);
          } catch (e) {
            PREFS2.debugError("innerHTML assignment failed:", e.message);
          }
          if (setTimeout(() => this._updateFindbarDimensions(), 0), messagesContainer)
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        if (fullText.trim() === "" && aiMessageDiv.querySelector(".tool-calls-container"))
          contentDiv.innerHTML = parseMD("*(Tool actions performed)*", !1);
        else if (fullText.trim() === "" && !aiMessageDiv.querySelector(".tool-calls-container"))
          aiMessageDiv.remove();
      }
    } catch (e) {
      if (e.name !== "AbortError") {
        if (PREFS2.debugError("Error sending message:", e), aiMessageDiv)
          aiMessageDiv.remove();
        this.addChatMessage({ role: "error", content: `**Error**: ${e.message}` });
      } else if (PREFS2.debugLog("Streaming aborted by user."), aiMessageDiv)
        aiMessageDiv.remove();
    } finally {
      this._toggleStreamingControls(!1), this._abortController = null, this._removeToolCallUI(), this._currentAIMessageDiv = null;
    }
  },
  _toggleStreamingControls(isStreaming) {
    if (this._isStreaming = isStreaming, !this.chatContainer)
      return;
    let sendBtn = this.chatContainer.querySelector("#send-prompt"), stopBtn = this.chatContainer.querySelector("#stop-generation"), promptInput = this.chatContainer.querySelector("#ai-prompt");
    if (isStreaming)
      sendBtn.style.display = "none", stopBtn.style.display = "flex", promptInput.disabled = !0;
    else
      sendBtn.style.display = "flex", stopBtn.style.display = "none", promptInput.disabled = !1, this.focusPrompt();
  },
  _overrideFindbarMatchesDisplay(retry = 0) {
    if (PREFS2.debugLog(`_overrideFindbarMatchesDisplay called, retry: ${retry}`), this._originalOnMatchesCountResult) {
      PREFS2.debugLog("Prototype already overridden.");
      return;
    }
    let findbarClass = customElements.get("findbar")?.prototype;
    if (!findbarClass) {
      if (PREFS2.debugLog("findbarClass not found."), retry < 10)
        setTimeout(() => this._overrideFindbarMatchesDisplay(retry + 1), 100), PREFS2.debugLog(`Retrying _overrideFindbarMatchesDisplay in 100ms, retry: ${retry + 1}`);
      else
        PREFS2.debugError("Failed to override findbar matches display: findbar custom element not found after multiple retries.");
      return;
    }
    PREFS2.debugLog("findbarClass found. Overriding onMatchesCountResult."), this._originalOnMatchesCountResult = findbarClass.onMatchesCountResult, findbarClass.onMatchesCountResult = function(result) {
      if (!PREFS2.enabled)
        return;
      let foundMatchesElement = this._foundMatches;
      if (typeof result?.current !== "number" || typeof result?.total !== "number")
        return;
      let next = this.querySelector(".findbar-find-next"), previous = this.querySelector(".findbar-find-previous");
      if (next && previous)
        if (result.searchString.trim() === "" || result.total <= 1)
          next.disabled = !0, previous.disabled = !0;
        else if (result.current <= 1)
          next.disabled = !1, previous.disabled = !0;
        else if (result.current >= result.total)
          next.disabled = !0, previous.disabled = !1;
        else
          next.disabled = !1, previous.disabled = !1;
      if (!foundMatchesElement)
        return;
      if (result.searchString.trim() === "") {
        foundMatchesElement.setAttribute("value", "");
        return;
      }
      foundMatchesElement.hidden = !1;
      let newLabel = `${result.current}/${result.total}`;
      foundMatchesElement.setAttribute("value", newLabel);
    }, PREFS2.debugLog("onMatchesCountResult successfully overridden.");
  },
  _restoreFindbarMatchesDisplay() {
    if (this._originalOnMatchesCountResult) {
      let findbarClass = customElements.get("findbar")?.prototype;
      if (findbarClass)
        findbarClass.onMatchesCountResult = this._originalOnMatchesCountResult;
      if (this._originalOnMatchesCountResult = null, this.findbar) {
        let foundMatchesElement = this.findbar._foundMatches;
        if (foundMatchesElement)
          foundMatchesElement.setAttribute("value", ""), foundMatchesElement.hidden = !0;
      }
    }
  },
  createChatInterface() {
    let container = parseElement(`
        <div class="browse-bot-chat">
          <div class="ai-chat-header">
            <div class="findbar-drag-handle"></div>
          </div>
          <div class="ai-chat-messages" id="chat-messages"></div>
          <div class="ai-chat-input-group">
          <textarea id="ai-prompt" placeholder="Ask AI anything..." rows="2"></textarea>
          <button id="send-prompt" class="send-btn">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path fill="currentColor" d="M17.991 6.01L5.399 10.563l4.195 2.428l3.699-3.7a1 1 0 0 1 1.414 1.415l-3.7 3.7l2.43 4.194L17.99 6.01Zm.323-2.244c1.195-.433 2.353.725 1.92 1.92l-5.282 14.605c-.434 1.198-2.07 1.344-2.709.241l-3.217-5.558l-5.558-3.217c-1.103-.639-.957-2.275.241-2.709z" />
            </svg>
          </button>
          <button id="stop-generation" class="stop-btn" style="display: none;">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                  <path fill="currentColor" d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2m2 6h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2" />
              </svg>
          </button>
        </div>
        </div>`), chatHeader = container.querySelector(".ai-chat-header"), clearBtn = parseElement(`
        <toolbarbutton 
          id="clear-chat" 
          class="clear-chat-btn" 
          image="chrome://global/skin/icons/delete.svg" 
          tooltiptext="Clear Chat"
        />`, "xul"), settingsBtn = parseElement(`
        <toolbarbutton 
          id="open-settings-btn" 
          class="settings-btn" 
          image="chrome://global/skin/icons/settings.svg" 
          tooltiptext="Settings"
        />`, "xul"), collapseBtn = parseElement(`
        <toolbarbutton 
          id="findbar-collapse-btn" 
          class="findbar-collapse-btn" 
          image="chrome://browser/skin/zen-icons/unpin.svg" 
          tooltiptext="Collapse"
        />`, "xul");
    chatHeader.appendChild(clearBtn), chatHeader.appendChild(settingsBtn), chatHeader.appendChild(collapseBtn);
    let chatMessages = container.querySelector("#chat-messages"), promptInput = container.querySelector("#ai-prompt"), sendBtn = container.querySelector("#send-prompt"), stopBtn = container.querySelector("#stop-generation"), handleSend = () => {
      let prompt = promptInput.value.trim();
      this.sendMessage(prompt), promptInput.value = "";
    };
    return sendBtn.addEventListener("click", handleSend), stopBtn.addEventListener("click", () => {
      this._abortController?.abort();
    }), promptInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter" && !e.shiftKey)
        e.preventDefault(), handleSend();
    }), clearBtn.addEventListener("click", () => {
      this.clear(), this.expanded = !1;
    }), settingsBtn.addEventListener("click", () => {
      SettingsModal.show();
    }), collapseBtn.addEventListener("click", () => {
      this.expanded = !1;
    }), chatMessages.addEventListener("click", async (e) => {
      if (e.target.classList.contains("citation-link")) {
        let button = e.target, citationId = button.dataset.citationId, messageEl = button.closest(".chat-message[data-citations]");
        if (messageEl) {
          let citation = JSON.parse(messageEl.dataset.citations).find((c) => c.id == citationId);
          if (citation && citation.source_quote)
            PREFS2.debugLog(`Citation [${citationId}] clicked. Requesting highlight for:`, citation.source_quote), this.highlight(citation.source_quote);
        }
      } else if (e.target?.href) {
        e.preventDefault();
        try {
          openTrustedLinkIn(e.target.href, "tab");
        } catch {}
      }
    }), container;
  },
  createLoadingIndicator() {
    return parseElement('<div class="chat-message chat-message-loading"><div class="message-content">Loading...</div></div>');
  },
  addChatMessage(message) {
    let { role, content: content2 } = message;
    if (!this.chatContainer || content2 === void 0 || content2 === null)
      return;
    let messagesContainer = this.chatContainer.querySelector("#chat-messages");
    if (!messagesContainer)
      return;
    let type;
    switch (role) {
      case "user":
        type = "user";
        break;
      case "assistant":
        type = "ai";
        break;
      case "error":
        type = "error";
        break;
      default:
        return;
    }
    let messageDiv = parseElement(`<div class="chat-message chat-message-${type}"></div>`), contentDiv = parseElement('<div class="message-content"></div>');
    if (role === "assistant" && typeof content2 === "object" && content2.answer !== void 0) {
      let { answer, citations } = content2;
      if (citations && citations.length > 0)
        messageDiv.dataset.citations = JSON.stringify(citations);
      let textToParse = answer.replace(/\[(\d+)\]/g, '<span class="citation-link" data-citation-id="$1">[$1]</span>');
      contentDiv.appendChild(parseMD(textToParse));
    } else {
      let textContent = typeof content2 === "string" ? content2 : content2[0]?.text ?? "";
      if (role === "assistant" && PREFS2.citationsEnabled) {
        let { answer, citations } = browseBotFindbarLLM.parseModelResponseText(textContent);
        if (citations && citations.length > 0)
          messageDiv.dataset.citations = JSON.stringify(citations);
        let textToParse = answer.replace(/\[(\d+)\]/g, '<span class="citation-link" data-citation-id="$1">[$1]</span>');
        contentDiv.appendChild(parseMD(textToParse));
      } else
        contentDiv.appendChild(parseMD(textContent));
    }
    messageDiv.appendChild(contentDiv), messagesContainer.appendChild(messageDiv), messagesContainer.scrollTop = messagesContainer.scrollHeight, setTimeout(() => this._updateFindbarDimensions(), 10);
  },
  showAIInterface() {
    if (!this.findbar)
      return;
    if (this.removeAIInterface(), this.findbar.classList.remove("ai-settings-active"), !browseBotFindbarLLM.currentProvider.apiKey && browseBotFindbarLLM.currentProvider.name !== "ollama")
      this.apiKeyContainer = this.createAPIKeyInterface(), this.findbar.insertBefore(this.apiKeyContainer, this.findbar.firstChild);
    else {
      if (this.chatContainer = this.createChatInterface(), PREFS2.dndEnabled)
        this.enableDND();
      let history = browseBotFindbarLLM.getHistory();
      for (let message of history)
        this.addChatMessage(message);
      this.findbar.insertBefore(this.chatContainer, this.findbar.firstChild);
    }
    setTimeout(() => this._updateFindbarDimensions(), 10);
  },
  focusInput() {
    if (this.findbar)
      setTimeout(() => this.findbar._findField.focus(), 10);
  },
  focusPrompt() {
    let promptInput = this.chatContainer?.querySelector("#ai-prompt");
    if (promptInput)
      setTimeout(() => promptInput.focus(), 10);
  },
  setPromptText(text) {
    let promptInput = this?.chatContainer?.querySelector("#ai-prompt");
    if (promptInput && text)
      promptInput.value = text;
  },
  async setPromptTextFromSelection() {
    let text = "", selection = await messageManagerAPI.getSelectedText();
    if (!selection || !selection.hasSelection)
      text = this?.findbar?._findField?.value;
    else
      text = selection.selectedText;
    this.setPromptText(text);
  },
  removeAIInterface() {
    if (this.apiKeyContainer)
      this.apiKeyContainer.remove(), this.apiKeyContainer = null;
    if (this.chatContainer)
      this.chatContainer.remove(), this.chatContainer = null;
  },
  init() {
    if (!this.enabled)
      return;
    if (this.updateFindbar(), this.addListeners(), PREFS2.contextMenuEnabled)
      this.addContextMenuItem();
    this._overrideFindbarMatchesDisplay();
  },
  destroy() {
    this.findbar = null, setTimeout(() => this._updateFindbarDimensions(), 10), this.expanded = !1;
    try {
      this.removeListeners();
    } catch {}
    this.removeExpandButton(), this.removeContextMenuItem(), this.removeAIInterface(), this._toolConfirmationDialog?.remove(), this._toolConfirmationDialog = null, SettingsModal.hide(), this._restoreFindbarMatchesDisplay();
  },
  addExpandButton() {
    if (!this.findbar)
      return !1;
    if (this.removeExpandButton(), this.minimal) {
      let container = this.findbar.querySelector(".findbar-container");
      if (container && !container.querySelector("#findbar-ask")) {
        let askBtn = parseElement('<button id="findbar-ask" anonid="findbar-ask">Ask</button>');
        askBtn.addEventListener("click", () => {
          let inpText = this.findbar._findField.value.trim();
          this.sendMessage(inpText), this.findbar._findField.value = "", this.focusInput();
        }), container.appendChild(askBtn), this.askButton = askBtn;
      }
    } else {
      let button = parseElement('<button id="findbar-expand" anonid="findbar-expand">Expand</button>');
      button.addEventListener("click", () => this.expanded = !0), button.textContent = "Expand", this.findbar.appendChild(button), this.expandButton = button;
    }
    return !0;
  },
  removeExpandButton() {
    if (this.askButton)
      this.askButton.remove(), this.askButton = null;
    if (this.expandButton)
      this.expandButton.remove(), this.expandButton = null;
    return !0;
  },
  handleInputKeyPress: function(e) {
    if (e?.key === "Enter" && e?.altKey) {
      e.preventDefault();
      let inpText = this.findbar._findField.value.trim();
      this.sendMessage(inpText), this.findbar._findField.value = "", this.focusInput();
    }
  },
  addContextMenuItem(retryCount = 0) {
    if (this.contextMenuItem)
      return;
    if (!PREFS2.contextMenuEnabled)
      return;
    let contextMenu = document.getElementById("contentAreaContextMenu");
    if (!contextMenu) {
      if (retryCount < 5)
        PREFS2.debugLog(`Context menu not found, retrying... (attempt ${retryCount + 1}/5)`), setTimeout(() => this.addContextMenuItem(retryCount + 1), 200);
      else
        PREFS2.debugError("Failed to add context menu item after 5 attempts: Context menu not found.");
      return;
    }
    let menuItem = document.createXULElement("menuitem");
    menuItem.id = "browse-bot-context-menu-item", menuItem.setAttribute("label", "Ask AI"), menuItem.setAttribute("accesskey", "A"), menuItem.addEventListener("command", this.handleContextMenuClick.bind(this)), this.contextMenuItem = menuItem;
    let searchSelectItem = contextMenu.querySelector("#context-searchselect");
    if (searchSelectItem)
      if (searchSelectItem.nextSibling)
        contextMenu.insertBefore(menuItem, searchSelectItem.nextSibling);
      else
        contextMenu.appendChild(menuItem);
    else {
      let redoSeparator = contextMenu.querySelector("#context-sep-redo");
      if (redoSeparator)
        if (redoSeparator.nextSibling)
          contextMenu.insertBefore(menuItem, redoSeparator.nextSibling);
        else
          contextMenu.appendChild(menuItem);
      else
        return;
    }
    this._updateContextMenuText = this.updateContextMenuText.bind(this), contextMenu.addEventListener("popupshowing", this._updateContextMenuText);
  },
  removeContextMenuItem: function() {
    this?.contextMenuItem?.remove(), this.contextMenuItem = null, document?.getElementById("contentAreaContextMenu")?.removeEventListener("popupshowing", this._updateContextMenuText);
  },
  handleContextMenuClick: async function() {
    let selection = await messageManagerAPI.getSelectedText(), finalMessage = "";
    if (selection.hasSelection)
      finalMessage = PREFS2.contextMenuCommandWithSelection.replace("{selection}", selection.selectedText);
    else
      finalMessage = PREFS2.contextMenuCommandNoSelection;
    if (this.expanded = !0, PREFS2.contextMenuAutoSend)
      this.sendMessage(finalMessage), this.focusPrompt();
    else
      this.setPromptText(finalMessage), this.show(), this.focusPrompt();
  },
  handleContextMenuPrefChange: function(pref) {
    if (pref.value)
      this.addContextMenuItem();
    else
      this.removeContextMenuItem();
  },
  updateContextMenuText() {
    if (!PREFS2.contextMenuEnabled || !this.contextMenuItem)
      return;
    let hasSelection = gContextMenu?.isTextSelected === !0;
    this.contextMenuItem.label = hasSelection ? "Ask AI" : "Summarize with AI";
  },
  enableResize() {
    if (!this.findbar || this._resizeHandle)
      return;
    let resizeHandle = parseElement('<div class="findbar-resize-handle"></div>');
    this.findbar.appendChild(resizeHandle), this._resizeHandle = resizeHandle, this._startResize = this.startResize.bind(this), this._resizeHandle.addEventListener("mousedown", this._startResize);
  },
  startResize(e) {
    if (e.button !== 0 || !this.findbar)
      return;
    this._isResizing = !0, this._initialMouseCoor = { x: e.clientX, y: e.clientY };
    let rect = this.findbar.getBoundingClientRect();
    this.startWidth = rect.width, this._handleResize = this.doResize.bind(this), this._stopResize = this.stopResize.bind(this), document.addEventListener("mousemove", this._handleResize), document.addEventListener("mouseup", this._stopResize);
  },
  doResize(e) {
    if (!this._isResizing || !this.findbar)
      return;
    let minWidth = 300, maxWidth = 800, directionFactor = PREFS2.position.includes("right") ? -1 : 1, newWidth = this.startWidth + (e.clientX - this._initialMouseCoor.x) * directionFactor;
    newWidth = Math.min(Math.max(newWidth, minWidth), maxWidth), this.findbar.style.width = `${newWidth}px`, this._updateFindbarDimensions();
  },
  stopResize() {
    this._isResizing = !1, document.removeEventListener("mousemove", this._handleResize), document.removeEventListener("mouseup", this._stopResize), this._handleResize = null, this._stopResize = null, this._updateFindbarDimensions(), this._saveFindbarDimensions();
  },
  disableResize() {
    this._resizeHandle?.remove(), this._resizeHandle = null, this.stopResize();
  },
  startDrag(e) {
    if (!this.chatContainer || e.button !== 0)
      return;
    this._isDragging = !0, this._initialMouseCoor = { x: e.clientX, y: e.clientY };
    let rect = this.findbar.getBoundingClientRect();
    this._initialContainerCoor = { x: rect.left, y: rect.top }, this._handleDrag = this.doDrag.bind(this), this._stopDrag = this.stopDrag.bind(this), document.addEventListener("mousemove", this._handleDrag), document.addEventListener("mouseup", this._stopDrag);
  },
  doDrag(e) {
    if (!this._isDragging)
      return;
    let minCoors = { x: 15, y: 35 }, rect = this.findbar.getBoundingClientRect(), maxCoors = {
      x: window.innerWidth - rect.width - 33,
      y: window.innerHeight - rect.height - 33
    }, newCoors = {
      x: this._initialContainerCoor.x + (e.clientX - this._initialMouseCoor.x),
      y: this._initialContainerCoor.y + (e.clientY - this._initialMouseCoor.y)
    };
    if (newCoors.x -= getSidebarWidth(), newCoors.x = Math.max(minCoors.x, Math.min(newCoors.x, maxCoors.x)), newCoors.y = Math.max(minCoors.y, Math.min(newCoors.y, maxCoors.y)), PREFS2.pseudoBg)
      this._updateFindbarDimensions();
    this.findbar.style.setProperty("left", `${newCoors.x}px`, "important"), this.findbar.style.setProperty("top", `${newCoors.y}px`, "important"), this.findbar.style.setProperty("right", "unset", "important"), this.findbar.style.setProperty("bottom", "unset", "important");
  },
  stopDrag() {
    if (this._isDragging = !1, !PREFS2.pseudoBg)
      this.findbar.style.setProperty("transition", "all 0.3s ease", "important"), setTimeout(() => this.findbar.style.removeProperty("transition"), 400), setTimeout(() => this._updateFindbarDimensions(), 401);
    this.snapToClosestCorner(), this._initialMouseCoor = { x: null, y: null }, this._initialContainerCoor = { x: null, y: null }, document.removeEventListener("mouseup", this._stopDrag), document.removeEventListener("mousemove", this._handleDrag), this._handleDrag = null, this._stopDrag = null, setTimeout(() => this._updateFindbarDimensions(), 0);
  },
  snapToClosestCorner() {
    if (!this.findbar || !PREFS2.dndEnabled)
      return;
    let rect = this.findbar.getBoundingClientRect(), currentX = rect.left, currentY = rect.top, findbarWidth = rect.width, findbarHeight = rect.height, snapPoints = {
      "top-left": { x: 0, y: 0 },
      "top-right": { x: window.innerWidth - findbarWidth, y: 0 },
      "bottom-left": { x: 0, y: window.innerHeight - findbarHeight },
      "bottom-right": {
        x: window.innerWidth - findbarWidth,
        y: window.innerHeight - findbarHeight
      }
    }, closestPointName = PREFS2.position, minDistance = 1 / 0;
    for (let name in snapPoints) {
      let p = snapPoints[name], distance = Math.sqrt(Math.pow(currentX - p.x, 2) + Math.pow(currentY - p.y, 2));
      if (distance < minDistance)
        minDistance = distance, closestPointName = name;
    }
    if (closestPointName !== PREFS2.position)
      PREFS2.position = closestPointName;
    this.findbar.style.removeProperty("left"), this.findbar.style.removeProperty("top"), this.findbar.style.removeProperty("bottom"), this.findbar.style.removeProperty("right");
  },
  enableDND() {
    if (!this.chatContainer)
      return;
    let handle = this.chatContainer.querySelector(".findbar-drag-handle");
    if (!handle)
      return;
    this._startDrag = this.startDrag.bind(this), handle.addEventListener("mousedown", this._startDrag);
  },
  disableDND() {
    if (this._isDragging = !1, !this.chatContainer)
      return;
    let handle = this.chatContainer.querySelector(".findbar-drag-handle");
    if (!handle)
      return;
    handle.removeEventListener("mousedown", this._startDrag), document.removeEventListener("mouseup", this._stopDrag), document.removeEventListener("mousemove", this._handleDrag), this._startDrag = null, this._stopDrag = null;
  },
  addKeymaps: function(e) {
    if (e.key?.toLowerCase() === "escape") {
      if (SettingsModal._modalElement && SettingsModal._modalElement.parentNode)
        e.preventDefault(), e.stopPropagation(), SettingsModal.hide();
      else if (this._toolConfirmationDialog)
        this._toolConfirmationDialog.querySelector(".cancel-tool")?.click();
      else if (this.expanded)
        e.preventDefault(), e.stopPropagation(), this.expanded = !1, this.focusInput();
    }
  },
  addListeners() {
    this._updateFindbar = this.updateFindbar.bind(this), this._addKeymaps = this.addKeymaps.bind(this), this._handleInputKeyPress = this.handleInputKeyPress.bind(this);
    let _clearLLMData = () => {
      this.updateFindbarStatus(), this.clear();
    }, _handleContextMenuPrefChange = this.handleContextMenuPrefChange.bind(this), _handleMinimalPrefChange = this.handleMinimalPrefChange.bind(this), _handleBackgroundStyleChange = () => {
      updateSidebarWidth();
    };
    gBrowser.tabContainer.addEventListener("TabSelect", this._updateFindbar), document.addEventListener("keydown", this._addKeymaps), this._handleFindbarOpenEvent = this.handleFindbarOpenEvent.bind(this), this._handleFindbarCloseEvent = this.handleFindbarCloseEvent.bind(this), window.addEventListener("findbaropen", this._handleFindbarOpenEvent), window.addEventListener("findbarclose", this._handleFindbarCloseEvent), this._agenticModeListener = addPrefListener(PREFS2.AGENTIC_MODE, _clearLLMData), this._backgroundStylesListener = addPrefListener(PREFS2.BACKGROUND_STYLE, _handleBackgroundStyleChange), this._citationsListener = addPrefListener(PREFS2.CITATIONS_ENABLED, _clearLLMData), this._minimalListener = addPrefListener(PREFS2.MINIMAL, _handleMinimalPrefChange), this._contextMenuEnabledListener = addPrefListener(PREFS2.CONTEXT_MENU_ENABLED, _handleContextMenuPrefChange), this._persistListener = addPrefListener(PREFS2.PERSIST, (pref) => {
      if (!this.findbar)
        return;
      if (pref.value)
        this.findbar.history = browseBotFindbarLLM.history;
      else
        this.findbar.history = null;
    }), this._dndListener = addPrefListener(PREFS2.DND_ENABLED, (pref) => {
      if (pref.value)
        this.enableDND(), this.enableResize();
      else
        this.disableDND(), this.disableResize();
    });
  },
  removeListeners() {
    if (this.findbar)
      this.findbar._findField.removeEventListener("keypress", this._handleInputKeyPress), this.findbar._findField.removeEventListener("input", this._handleFindFieldInput);
    gBrowser.tabContainer.removeEventListener("TabSelect", this._updateFindbar), document.removeEventListener("keydown", this._addKeymaps), window.removeEventListener("findbaropen", this._handleFindbarOpenEvent), window.removeEventListener("findbarclose", this._handleFindbarCloseEvent), removePrefListener(this._agenticModeListener), removePrefListener(this._backgroundStylesListener), removePrefListener(this._citationsListener), removePrefListener(this._contextMenuEnabledListener), removePrefListener(this._minimalListener), removePrefListener(this._persistListener), removePrefListener(this._dndListener), this.disableDND(), this._handleInputKeyPress = null, this._updateFindbar = null, this._addKeymaps = null, this._agenticModeListener = null, this._citationsListener = null, this._contextMenuEnabledListener = null, this._minimalListener = null, this._dndListener = null, this._handleFindbarOpenEvent = null, this._handleFindbarCloseEvent = null;
  },
  handleFindbarOpenEvent: function() {
    if (this.enabled)
      PREFS2.debugLog("Findbar is being opened"), setTimeout(() => this.findbar._findField.placeholder = "Press Alt + Enter to ask AI", 100), setTimeout(() => this._updateFindbarDimensions(), 1);
  },
  handleFindbarCloseEvent: function() {
    if (this.enabled) {
      if (PREFS2.debugLog("Findbar is being closed"), this._isStreaming)
        this._abortController?.abort();
    }
  }
};

// findbar-ai/llm/index.js
import { z as z2 } from "./vercel-ai-sdk.uc.mjs";

// findbar-ai/llm/providers.js
import { createMistral } from "./vercel-ai-sdk.uc.mjs";
import { createGoogleGenerativeAI } from "./vercel-ai-sdk.uc.mjs";
import { createOpenAI } from "./vercel-ai-sdk.uc.mjs";
import { createAnthropic } from "./vercel-ai-sdk.uc.mjs";
import { xai as createGrok } from "./vercel-ai-sdk.uc.mjs";
import { createPerplexity } from "./vercel-ai-sdk.uc.mjs";
import { createCerebras } from "./vercel-ai-sdk.uc.mjs";
import { createOllama } from "./vercel-ai-sdk.uc.mjs";

// utils/favicon.js
function googleFaviconAPI(domainOrUrl, size = 32) {
  let domain;
  try {
    domain = new URL(domainOrUrl).hostname;
  } catch {
    domain = domainOrUrl;
  }
  return `https://s2.googleusercontent.com/s2/favicons?domain_url=https://${domain}&sz=${size}`;
}

// findbar-ai/llm/providers.js
var providerPrototype = {
  get apiKey() {
    return prefs_default.getPref(this.apiPref);
  },
  set apiKey(v) {
    if (typeof v === "string" && this.apiPref)
      prefs_default.setPref(this.apiPref, v);
  },
  get model() {
    return prefs_default.getPref(this.modelPref);
  },
  set model(v) {
    if (this.AVAILABLE_MODELS.includes(v))
      prefs_default.setPref(this.modelPref, v);
  },
  getModel() {
    return this.create({ apiKey: this.apiKey })(this.model);
  }
}, mistral = Object.assign(Object.create(providerPrototype), {
  name: "mistral",
  label: "Mistral AI",
  faviconUrl: googleFaviconAPI("mistral.ai"),
  apiKeyUrl: "https://console.mistral.ai/api-keys/",
  AVAILABLE_MODELS: [
    "pixtral-large-latest",
    "mistral-large-latest",
    "mistral-medium-latest",
    "mistral-medium-2505",
    "mistral-small-latest",
    "magistral-small-2506",
    "magistral-medium-2506",
    "ministral-3b-latest",
    "ministral-8b-latest",
    "pixtral-12b-2409",
    "open-mistral-7b",
    "open-mixtral-8x7b",
    "open-mixtral-8x22b"
  ],
  AVAILABLE_MODELS_LABELS: {
    "pixtral-large-latest": "Pixtral Large (Latest)",
    "mistral-large-latest": "Mistral Large (Latest)",
    "mistral-medium-latest": "Mistral Medium (Latest)",
    "mistral-medium-2505": "Mistral Medium (2505)",
    "mistral-small-latest": "Mistral Small(Latest)",
    "magistral-small-2506": "Magistral Small (2506)",
    "magistral-medium-2506": "Magistral Medium (2506)",
    "ministral-3b-latest": "Ministral 3B (Latest)",
    "ministral-8b-latest": "Ministral 8B (Latest)",
    "pixtral-12b-2409": "Pixtral 12B (2409)",
    "open-mistral-7b": "Open Mistral 7B",
    "open-mixtral-8x7b": "Open Mixtral 8x7B",
    "open-mixtral-8x22b": "Open Mixtral 8x22B"
  },
  modelPref: prefs_default.MISTRAL_MODEL,
  apiPref: prefs_default.MISTRAL_API_KEY,
  create: createMistral
}), gemini = Object.assign(Object.create(providerPrototype), {
  name: "gemini",
  label: "Google Gemini",
  faviconUrl: googleFaviconAPI("gemini.google.com"),
  apiKeyUrl: "https://aistudio.google.com/app/apikey",
  AVAILABLE_MODELS: [
    "gemini-3-pro-preview",
    "gemini-2.5-pro",
    "gemini-2.5-flash",
    "gemini-2.5-flash-lite",
    "gemini-2.0-flash",
    "gemini-1.5-pro",
    "gemini-1.5-pro-latest",
    "gemini-1.5-flash",
    "gemini-1.5-flash-latest",
    "gemini-1.5-flash-8b",
    "gemini-1.5-flash-8b-latest"
  ],
  AVAILABLE_MODELS_LABELS: {
    "gemini-3-pro-preview": "Gemini 3 Pro Preview",
    "gemini-2.5-pro": "Gemini 2.5 Pro",
    "gemini-2.5-flash": "Gemini 2.5 Flash",
    "gemini-2.5-flash-lite": "Gemini 2.5 Flash Lite",
    "gemini-2.0-flash": "Gemini 2.0 Flash",
    "gemini-1.5-pro": "Gemini 1.5 Pro",
    "gemini-1.5-pro-latest": "Gemini 1.5 Pro Latest",
    "gemini-1.5-flash": "Gemini 1.5 Flash",
    "gemini-1.5-flash-latest": "Gemini 1.5 Flash Latest",
    "gemini-1.5-flash-8b": "Gemini 1.5 Flash 8B",
    "gemini-1.5-flash-8b-latest": "Gemini 1.5 Flash 8B Latest"
  },
  modelPref: prefs_default.GEMINI_MODEL,
  apiPref: prefs_default.GEMINI_API_KEY,
  create: createGoogleGenerativeAI
}), openai = Object.assign(Object.create(providerPrototype), {
  name: "openai",
  label: "OpenAI GPT",
  faviconUrl: googleFaviconAPI("chatgpt.com"),
  apiKeyUrl: "https://platform.openai.com/account/api-keys",
  AVAILABLE_MODELS: [
    "gpt-5.2-pro",
    "gpt-5.2-chat-latest",
    "gpt-5.2",
    "gpt-5.1-codex-mini",
    "gpt-5.1-codex",
    "gpt-5.1-chat-latest",
    "gpt-5.1",
    "gpt-5-pro",
    "gpt-4.1",
    "gpt-4.1-mini",
    "gpt-4.1-nano",
    "gpt-4o",
    "gpt-4o-mini",
    "gpt-4-turbo",
    "gpt-4",
    "gpt-3.5-turbo",
    "o1",
    "o3-mini",
    "o3",
    "o4-mini",
    "gpt-5",
    "gpt-5-mini",
    "gpt-5-nano",
    "gpt-5-chat-latest",
    "gpt-5-codex"
  ],
  AVAILABLE_MODELS_LABELS: {
    "gpt-5.2-pro": "GPT 5.2 Pro",
    "gpt-5.2-chat-latest": "GPT 5.2 Latest",
    "gpt-5.2": "GPT 5.2",
    "gpt-5.1-codex-mini": "GPT 5.1 Mini",
    "gpt-5.1-codex": "GPT 5.1 Codex",
    "gpt-5.1-chat-latest": "GPT 5.1 Latest",
    "gpt-5.1": "GPT 5.1",
    "gpt-5-pro": "GPT 5 Pro",
    "gpt-4.1": "GPT 4.1",
    "gpt-4.1-mini": "GPT 4.1 Mini",
    "gpt-4.1-nano": "GPT 4.1 Nano",
    "gpt-4o": "GPT 4o",
    "gpt-4o-mini": "GPT 4o Mini",
    "gpt-4-turbo": "GPT 4 Turbo",
    "gpt-4": "GPT 4",
    "gpt-3.5-turbo": "GPT 3.5 Turbo",
    o1: "O1",
    "o3-mini": "O3 Mini",
    o3: "O3",
    "o4-mini": "O4 Mini",
    "gpt-5": "GPT 5",
    "gpt-5-mini": "GPT 5 Mini",
    "gpt-5-nano": "GPT 5 Nano",
    "gpt-5-chat-latest": "GPT 5 Latest",
    "gpt-5-codex": "GPT 5 Codex"
  },
  modelPref: prefs_default.OPENAI_MODEL,
  apiPref: prefs_default.OPENAI_API_KEY,
  create: createOpenAI
}), claude = Object.assign(Object.create(providerPrototype), {
  name: "claude",
  label: "Anthropic Claude",
  faviconUrl: googleFaviconAPI("anthropic.com"),
  apiKeyUrl: "https://console.anthropic.com/dashboard",
  AVAILABLE_MODELS: [
    "claude-opus-4-5",
    "claude-hiku-4-5",
    "claude-sonnet-4-5",
    "claude-opus-4-1",
    "claude-opus-4-0",
    "claude-sonnet-4-0",
    "claude-3-7-sonnet-latest",
    "claude-3-5-haiku-latest"
  ],
  AVAILABLE_MODELS_LABELS: {
    "claude-opus-4-5": "Claude Opus 4.5",
    "claude-hiku-4-5": "Claude Hiku 4.5",
    "claude-sonnet-4-5": "Claude Sonnet 4.5",
    "claude-opus-4-1": "Claude Opus 4.1",
    "claude-opus-4-0": "Claude Opus 4.0",
    "claude-sonnet-4-0": "Claude Sonnet 4.0",
    "claude-3-7-sonnet-latest": "Claude 3.7 Sonnet Latest",
    "claude-3-5-haiku-latest": "Claude 3.5 Haiku Latest"
  },
  modelPref: prefs_default.CLAUDE_MODEL,
  apiPref: prefs_default.CLAUDE_API_KEY,
  create: createAnthropic
}), grok = Object.assign(Object.create(providerPrototype), {
  name: "grok",
  label: "xAI Grok",
  faviconUrl: googleFaviconAPI("x.ai"),
  apiKeyUrl: "https://x.ai/api",
  AVAILABLE_MODELS: [
    "grok-4-fast-non-reasoning",
    "grok-4-fast-reasoning",
    "grok-code-fast-1",
    "grok-4",
    "grok-3",
    "grok-3-latest",
    "grok-3-fast",
    "grok-3-fast-latest",
    "grok-3-mini",
    "grok-3-mini-latest",
    "grok-3-mini-fast",
    "grok-3-mini-fast-latest",
    "grok-2",
    "grok-2-latest"
  ],
  AVAILABLE_MODELS_LABELS: {
    "grok-4-fast-non-reasoning": "Grok 4 Fast (Non-Reasoning)",
    "grok-4-fast-reasoning": "Grok 4 Fast (Reasoning)",
    "grok-code-fast-1": "Grok Code Fast 1",
    "grok-4": "Grok 4",
    "grok-3": "Grok 3",
    "grok-3-latest": "Grok 3 Latest",
    "grok-3-fast": "Grok 3 Fast",
    "grok-3-fast-latest": "Grok 3 Fast Latest",
    "grok-3-mini": "Grok 3 Mini",
    "grok-3-mini-latest": "Grok 3 Mini Latest",
    "grok-3-mini-fast": "Grok 3 Mini Fast",
    "grok-3-mini-fast-latest": "Grok 3 Mini Fast Latest",
    "grok-2": "Grok 2",
    "grok-2-latest": "Grok 2 Latest"
  },
  modelPref: prefs_default.GROK_MODEL,
  apiPref: prefs_default.GROK_API_KEY,
  create: createGrok
}), perplexity = Object.assign(Object.create(providerPrototype), {
  name: "perplexity",
  label: "Perplexity AI",
  faviconUrl: googleFaviconAPI("perplexity.ai"),
  apiKeyUrl: "https://perplexity.ai",
  AVAILABLE_MODELS: [
    "sonar-deep-research",
    "sonar-reasoning-pro",
    "sonar-reasoning",
    "sonar-pro",
    "sonar"
  ],
  AVAILABLE_MODELS_LABELS: {
    "sonar-deep-research": "Sonar Deep Research",
    "sonar-reasoning-pro": "Sonar Reasoning Pro",
    "sonar-reasoning": "Sonar Reasoning",
    "sonar-pro": "Sonar Pro",
    sonar: "Sonar"
  },
  modelPref: prefs_default.PERPLEXITY_MODEL,
  apiPref: prefs_default.PERPLEXITY_API_KEY,
  create: createPerplexity
}), cerebras = Object.assign(Object.create(providerPrototype), {
  name: "cerebras",
  label: "Cerebras AI",
  faviconUrl: "https://www.google.com/s2/favicons?sz=32&domain_url=cerebras.ai",
  apiKeyUrl: "https://cerebras.ai",
  AVAILABLE_MODELS: [
    "llama3.1-8b",
    "llama-3.3-70b",
    "gpt-oss-120b",
    "qwen-3-32b",
    "qwen-3-235b-a22b-instruct-2507",
    "zai-glm-4.6"
  ],
  AVAILABLE_MODELS_LABELS: {
    "llama3.1-8b": "Llama 3.1 8B",
    "llama-3.3-70b": "Llama 3.3 70B",
    "gpt-oss-120b": "OpenAI GPT OSS 120B",
    "qwen-3-32b": "Qwen 3 32B",
    "qwen-3-235b-a22b-instruct-2507": "Qwen 3 235B Instruct (Preview)",
    "zai-glm-4.6": "Z.ai GLM 4.6 (Preview)"
  },
  modelPref: prefs_default.CEREBRAS_MODEL,
  apiPref: prefs_default.CEREBRAS_API_KEY,
  create: createCerebras
}), ollama = Object.assign(Object.create(providerPrototype), {
  name: "ollama",
  label: "Ollama (local)",
  faviconUrl: googleFaviconAPI("ollama.com"),
  apiKeyUrl: "",
  baseUrlPref: prefs_default.OLLAMA_BASE_URL,
  get baseUrl() {
    return prefs_default.ollamaBaseUrl;
  },
  set baseUrl(v) {
    if (typeof v === "string")
      prefs_default.ollamaBaseUrl = v;
  },
  AVAILABLE_MODELS: [
    "deepseek-r1:8b",
    "deepseek-r1:1.5b",
    "deepseek-r1:7b",
    "deepseek-r1:14b",
    "deepseek-r1:32b",
    "deepseek-r1:70b",
    "mixtral:8x22b",
    "mixtral:8x7b",
    "qwen3:0.6b",
    "qwen3:1.7b",
    "qwen3:4b",
    "qwen3:8b",
    "qwen3:14b",
    "qwen3:32b",
    "qwen3:30b-a3b",
    "qwen3:235b-a22b",
    "llama4:scout",
    "llama4:maverick"
  ],
  AVAILABLE_MODELS_LABELS: {
    "deepseek-r1:8b": "DeepSeek R1 (8B parameters)",
    "deepseek-r1:1.5b": "DeepSeek R1 (1.5B parameters)",
    "deepseek-r1:7b": "DeepSeek R1 (7B parameters)",
    "deepseek-r1:14b": "DeepSeek R1 (14B parameters)",
    "deepseek-r1:32b": "DeepSeek R1 (32B parameters)",
    "deepseek-r1:70b": "DeepSeek R1 (70B parameters)",
    "mixtral:8x22b": "Mixtral (8x22B)",
    "mixtral:8x7b": "Mixtral (8x7B)",
    "qwen3:0.6b": "Qwen3 (0.6B parameters)",
    "qwen3:1.7b": "Qwen3 (1.7B parameters)",
    "qwen3:4b": "Qwen3 (4B parameters)",
    "qwen3:8b": "Qwen3 (8B parameters)",
    "qwen3:14b": "Qwen3 (14B parameters)",
    "qwen3:32b": "Qwen3 (32B parameters)",
    "qwen3:30b-a3b": "Qwen3 (30B-A3B)",
    "qwen3:235b-a22b": "Qwen3 (235B-A22B)",
    "llama4:scout": "Llama 4 Scout",
    "llama4:maverick": "Llama 4 Maverick"
  },
  modelPref: prefs_default.OLLAMA_MODEL,
  get apiKey() {
    return "not_required";
  },
  set apiKey(v) {
    return;
  },
  getModel() {
    return createOllama({
      baseURL: this.baseUrl
    })(this.model);
  }
});

// findbar-ai/llm/index.js
var citationSchema = z2.object({
  answer: z2.string().describe("The conversational answer to the user's query."),
  citations: z2.array(z2.object({
    id: z2.number().describe("Unique identifier for the citation, corresponding to the marker in the answer text."),
    source_quote: z2.string().describe("The exact, verbatim quote from the source text that supports the information.")
  })).describe("An array of citation objects from the source text.")
});

class LLM {
  constructor() {
    this.history = [], this.AVAILABLE_PROVIDERS = {
      claude,
      gemini,
      grok,
      mistral,
      ollama,
      openai,
      perplexity,
      cerebras
    };
  }
  get llmProvider() {
    return prefs_default.llmProvider;
  }
  get currentProvider() {
    return this.AVAILABLE_PROVIDERS[this.llmProvider || "gemini"] || this.AVAILABLE_PROVIDERS.gemini;
  }
  setProvider(providerName) {
    if (this.AVAILABLE_PROVIDERS[providerName])
      prefs_default.llmProvider = providerName, prefs_default.debugLog(`Switched LLM provider to: ${providerName}`);
    else
      prefs_default.debugError(`Provider "${providerName}" not found.`);
  }
  async getSystemPrompt() {
    return "";
  }
  async generateText(options) {
    let { prompt, ...rest } = options;
    if (prompt)
      this.history.push({ role: "user", content: prompt });
    let config = {
      model: this.currentProvider.getModel(),
      system: await this.getSystemPrompt(),
      messages: this.history,
      temperature: prefs_default.llmTemperature,
      topP: prefs_default.llmTopP,
      topK: prefs_default.llmTopK,
      frequencyPenalty: prefs_default.llmFrequencyPenalty,
      presencePenalty: prefs_default.llmPresencePenalty,
      maxOutputTokens: prefs_default.llmMaxOutputTokens,
      ...rest
    }, result = await generateText(config);
    if (!rest.messages)
      this.history.push(...result.response.messages);
    return result;
  }
  async streamText(options) {
    let { prompt, onFinish, ...rest } = options;
    if (prompt)
      this.history.push({ role: "user", content: prompt });
    let self = this, config = {
      model: this.currentProvider.getModel(),
      system: await this.getSystemPrompt(),
      messages: this.history,
      temperature: prefs_default.llmTemperature,
      topP: prefs_default.llmTopP,
      topK: prefs_default.llmTopK,
      frequencyPenalty: prefs_default.llmFrequencyPenalty,
      presencePenalty: prefs_default.llmPresencePenalty,
      maxOutputTokens: prefs_default.llmMaxOutputTokens,
      ...rest,
      async onFinish(result) {
        if (!rest.messages)
          self.history.push(...result.response.messages);
        if (onFinish)
          onFinish(result);
      }
    };
    return streamText(config);
  }
  async generateTextWithCitations(options) {
    let { prompt, ...rest } = options;
    if (prompt)
      this.history.push({ role: "user", content: prompt });
    let config = {
      model: this.currentProvider.getModel(),
      system: await this.getSystemPrompt(),
      messages: this.history,
      output: Output.object({ schema: citationSchema }),
      temperature: prefs_default.llmTemperature,
      topP: prefs_default.llmTopP,
      topK: prefs_default.llmTopK,
      frequencyPenalty: prefs_default.llmFrequencyPenalty,
      presencePenalty: prefs_default.llmPresencePenalty,
      maxOutputTokens: prefs_default.llmMaxOutputTokens,
      ...rest
    }, { output } = await generateText(config);
    if (!rest.messages)
      this.history.push({ role: "assistant", content: JSON.stringify(output) });
    return output;
  }
  getHistory() {
    return [...this.history];
  }
  clearData() {
    prefs_default.debugLog("Clearing LLM history and system prompt."), this.history = [];
  }
  getLastMessage() {
    return this.history.length > 0 ? this.history[this.history.length - 1] : null;
  }
}

class BrowseBotLLM extends LLM {
  constructor() {
    super();
    this.systemInstruction = "";
  }
  get agenticMode() {
    return prefs_default.agenticMode;
  }
  get streamEnabled() {
    return prefs_default.streamEnabled;
  }
  get citationsEnabled() {
    return prefs_default.citationsEnabled;
  }
  get maxToolCalls() {
    return prefs_default.maxToolCalls;
  }
  async updateSystemPrompt() {
    prefs_default.debugLog("Updating system prompt..."), this.systemInstruction = await this.getSystemPrompt();
  }
  async getSystemPrompt() {
    let systemPrompt = "";
    if (prefs_default.customSystemPrompt)
      systemPrompt = prefs_default.customSystemPrompt + `

`;
    if (systemPrompt += `You are a helpful AI assistant integrated into Zen Browser, a minimal and modern fork of Firefox. Your primary purpose is to answer user questions based on the content of the current webpage.

## Your Instructions:
- Be concise, accurate, and helpful.`, this.agenticMode)
      systemPrompt += `

## AGENTIC MODE ENABLED - TOOL USAGE:
You have access to browser functions. The user knows you have these abilities.
- **CRITICAL**: When you decide to call a tool, give short summary of what tool are you calling and why?
- Use tools when the user explicitly asks, or when it is the only logical way to fulfill their request (e.g., "search for...").
- When asked about your own abilities, describe the functions you can perform based on the tools listed below.
`, systemPrompt += await getToolSystemPrompt(), systemPrompt += "\n## More instructions for Running tools\n- While running tool like `openLink` and `newSplit` make sure URL is valid.\n- User will provide URL and title of current of webpage. If you need more context, use the `getPageTextContent` or `getHTMLContent` tools.\n- When the user asks you to \"read the current page\", use the `getPageTextContent()` or `getHTMLContent` tool.\n- Don't use search tool unless user explicitely asks.\n- When user asks you to manage tabs (close/group/move tabs) do it smartly first read tabs and take action don't ask too many question for confirmation.\n- If the user asks you to open a link by its text (e.g., \"click the 'About Us' link\"), you must first use `getHTMLContent()` to find the link's full URL, then use `openLink()` to open it.";
    if (this.citationsEnabled)
      systemPrompt += '\n\n## Citation Instructions\n- **Output Format**: Your entire response **MUST** be a single, valid JSON object with two keys: `"answer"` and `"citations"`.\n- **Answer**: The `"answer"` key holds the conversational text. Use Markdown Syntax for formatting like lists, bolding, etc.\n- **Citations**: The `"citations"` key holds an array of citation objects.\n- **When to Cite**: For any statement of fact that is directly supported by the provided page content, you **SHOULD** provide a citation. It is not mandatory for every sentence.\n- **How to Cite**: In your `"answer"`, append a marker like `[1]`, `[2]`. Each marker must correspond to a citation object in the array.\n- **CRITICAL RULES FOR CITATIONS**:\n    1.  **source_quote**: This MUST be the **exact, verbatim, and short** text from the page content.\n    2.  **Accuracy**: The `"source_quote"` field must be identical to the text on the page, including punctuation and casing.\n    3.  **Multiple Citations**: If multiple sources support one sentence, format them like `[1][2]`, not `[1,2]`.\n    4.  **Unique IDs**: Each citation object **must** have a unique `"id"` that matches its marker in the answer text.\n    5.  **Short**: The source quote must be short no longer than one sentence and should not contain line brakes.\n- **Do Not Cite**: Do not cite your own abilities, general greetings, or information not from the provided text. Make sure the text is from page text content not from page title or URL.\n- **Tool Calls**: If you call a tool, you **must not** provide citations in the same turn.\n\n### Citation Examples\n\nHere are some examples demonstrating the correct JSON output format.\n\n**Example 1: General Question with a List and Multiple Citations**\n-   **User Prompt:** "What are the main benefits of using this library?"\n-   **Your JSON Response:**\n    ```json\n    {\n      "answer": "This library offers several key benefits:\n\n*   **High Performance**: It is designed to be fast and efficient for large-scale data processing [1].\n*   **Flexibility**: You can integrate it with various frontend frameworks [2].\n*   **Ease of Use**: The API is well-documented and simple to get started with [3].",\n      "citations": [\n        {\n          "id": 1,\n          "source_quote": "The new architecture provides significant performance gains, especially for large-scale data processing."\n        },\n        {\n          "id": 2,\n          "source_quote": "It is framework-agnostic, offering adapters for React, Vue, and Svelte."\n        },\n        {\n          "id": 3,\n          "source_quote": "Our extensive documentation and simple API make getting started a breeze."\n        }\n      ]\n    }\n    ```\n\n**Example 2: A Sentence Supported by Two Different Sources**\n-   **User Prompt:** "Tell me about the project\'s history."\n-   **Your JSON Response:**\n    ```json\n    {\n      "answer": "The project was initially created in 2021 [1] and later became open-source in 2022 [2].",\n      "citations": [\n        {\n          "id": 1,\n          "source_quote": "Development began on the initial prototype in early 2021."\n        },\n        {\n          "id": 2,\n          "source_quote": "We are proud to announce that as of September 2022, the project is fully open-source."\n        }\n      ]\n    }\n    ```\n';
    if (!this.agenticMode) {
      systemPrompt += `
- Strictly base all your answers on the webpage content provided below.
- If the user's question cannot be answered from the content, state that the information is not available on the page.

Here is the initial info about the current page:
`;
      let pageContext = await messageManagerAPI.getPageTextContent(!this.citationsEnabled);
      systemPrompt += JSON.stringify(pageContext);
    }
    return systemPrompt;
  }
  parseModelResponseText(responseText) {
    let answer = responseText, citations = [];
    if (prefs_default.citationsEnabled)
      try {
        let jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/), jsonString = jsonMatch ? jsonMatch[1] : responseText, parsedContent = JSON.parse(jsonString);
        if (typeof parsedContent.answer === "string") {
          if (answer = parsedContent.answer, Array.isArray(parsedContent.citations))
            citations = parsedContent.citations;
        } else
          prefs_default.debugLog("AI response JSON missing 'answer' field or not a string:", parsedContent);
      } catch (e) {
        prefs_default.debugError("Failed to parse AI message content as JSON:", e, "Raw Text:", responseText);
      }
    return { answer, citations };
  }
  async sendMessage(prompt, abortSignal) {
    if (prefs_default.debugLog("Current history before sending:", this.history), this.citationsEnabled) {
      let object = await super.generateTextWithCitations({
        prompt,
        abortSignal
      });
      if (browseBotFindbar?.findbar)
        browseBotFindbar.findbar.history = this.getHistory();
      return object;
    }
    if (!this.agenticMode)
      if (this.streamEnabled) {
        let self = this, streamResult = await super.streamText({ prompt, abortSignal });
        return (async () => {
          if (await streamResult.text, browseBotFindbar?.findbar)
            browseBotFindbar.findbar.history = self.getHistory();
        })(), streamResult;
      } else {
        let result = await super.generateText({ prompt, abortSignal });
        if (browseBotFindbar?.findbar)
          browseBotFindbar.findbar.history = this.getHistory();
        return result;
      }
    let shouldToolBeCalled = async (toolName) => {
      if (browseBotFindbar._createOrUpdateToolCallUI(toolName, "loading"), prefs_default.conformation) {
        let friendlyName = toolNameMapping[toolName] || toolName;
        if (!await browseBotFindbar.createToolConfirmationDialog([friendlyName]))
          return prefs_default.debugLog(`Tool execution for '${toolName}' cancelled by user.`), browseBotFindbar._createOrUpdateToolCallUI(toolName, "declined"), !1;
      }
      return !0;
    }, afterToolCall = (toolName, result) => {
      let status = result.error ? "error" : "success";
      browseBotFindbar._createOrUpdateToolCallUI(toolName, status, result.error);
    }, findbarToolGroups = Object.keys(toolGroups).filter((group) => group !== "bookmarks" && group !== "misc"), tools = getTools(findbarToolGroups, { shouldToolBeCalled, afterToolCall }), commonConfig = {
      prompt,
      tools,
      stopWhen: stepCountIs(this.maxToolCalls),
      abortSignal
    };
    if (this.streamEnabled) {
      let self = this;
      return super.streamText({
        ...commonConfig,
        onFinish: () => {
          if (browseBotFindbar?.findbar)
            browseBotFindbar.findbar.history = self.getHistory();
        }
      });
    } else {
      let result = await super.generateText(commonConfig);
      if (browseBotFindbar?.findbar)
        browseBotFindbar.findbar.history = this.getHistory();
      return result;
    }
  }
  clearData() {
    super.clearData(), this.systemInstruction = "";
  }
}
var browseBotFindbarLLM = new BrowseBotLLM;
window.browseBotFindabrLLM = browseBotFindbarLLM;

// findbar-ai/urlbar.uc.js
import { stepCountIs as stepCountIs2 } from "./vercel-ai-sdk.uc.mjs";
var urlBarGroups = ["search", "navigation", "tabs", "workspaces", "uiFeedback"];

class UrlBarLLM extends LLM {
  async getSystemPrompt() {
    let systemPrompt = "";
    if (PREFS2.customSystemPrompt)
      systemPrompt = PREFS2.customSystemPrompt + `

`;
    return systemPrompt += `You are an AI integrated with Zen Browser URL bar, designed to assist users in browsing the web effectively and organizing their workspace in a better way.

Your primary responsibilities include:
1. Making tool calls in each response based on user input.
2. If the user does not provide specific commands, perform a search using the provided terms. You are permitted to correct any grammar or spelling mistakes and refine user queries for better accuracy.
3. If a URL is provided, open it directly.
4. Update the user about your action with a Toast Notification.
5. Managing tabs, if a user asks you to manage the tabs (grouping, closing, splitting) you will do it with tools you have access to.

When to use Toast:
- When you perform a non-default action, like searching or opening a URL, or if you fix a spelling mistake in the search term.
- When you can't fulfill a user's requirement (show a short and clear toast why the user's requirement can't be fulfilled).
- When a long and complicated task is completed.

Your goal is to ensure a seamless and user-friendly browsing experience.`, systemPrompt += await getToolSystemPrompt(urlBarGroups), systemPrompt;
  }
  async sendMessage(prompt) {
    PREFS2.debugLog(`urlBarLLM: Sending prompt: "${prompt}"`);
    let urlBarToolSet = getTools(urlBarGroups, { shouldToolBeCalled: async (toolName) => {
      let friendlyName = toolNameMapping[toolName] || toolName;
      return gURLBar.inputField.setAttribute("placeholder", `${friendlyName}...`), !0;
    } });
    await super.generateText({
      prompt,
      tools: urlBarToolSet,
      stopWhen: stepCountIs2(PREFS2.maxToolCalls)
    });
  }
}
var urlBarLLM = new UrlBarLLM;
window.browseBotURLBarLLM = urlBarLLM;
var urlbarAI = {
  _isAIMode: !1,
  _originalPlaceholder: "",
  _originalHeight: null,
  _initialized: !1,
  _enabled: !1,
  get enabled() {
    return PREFS2.getPref(PREFS2.URLBAR_AI_ENABLED);
  },
  get hideSuggestions() {
    return PREFS2.getPref(PREFS2.URLBAR_AI_HIDE_SUGGESTIONS);
  },
  get animationsEnabled() {
    return PREFS2.getPref(PREFS2.URLBAR_AI_ANIMATIONS_ENABLED);
  },
  _hideSuggestions() {
    gURLBar.setAttribute("hide-suggestions", "true");
  },
  _resetHideSuggestions() {
    gURLBar.removeAttribute("hide-suggestions");
  },
  init() {
    if (!this.enabled) {
      PREFS2.debugLog("urlbarAI: Disabled by preference.");
      return;
    }
    if (PREFS2.debugLog("urlbarAI: Initializing"), this._initialized) {
      PREFS2.debugLog("urlbarAI: Already initialized.");
      return;
    }
    this._originalPlaceholder = gURLBar.inputField.getAttribute("placeholder"), this.addAskButton(), this.addListeners(), this._initialized = !0, PREFS2.debugLog("urlbarAI: Initialization complete");
  },
  destroy() {
    if (PREFS2.debugLog("urlbarAI: Destroying"), this.removeAskButton(), this.removeListeners(), this._isAIMode)
      this.toggleAIMode(!1);
    gURLBar.removeAttribute("ai-mode-active"), gURLBar.removeAttribute("is-ai-thinking"), gURLBar.inputField.setAttribute("placeholder", this._originalPlaceholder), this._initialized = !1, PREFS2.debugLog("urlbarAI: Destruction complete");
  },
  _closeUrlBar() {
    try {
      if (this.clearAnimationPropertiesInUrlBar(), this._resetHideSuggestions(), window.gZenUIManager && typeof window.gZenUIManager.handleUrlbarClose === "function") {
        window.gZenUIManager.handleUrlbarClose(!1, !1);
        return;
      }
      if (gURLBar.selectionStart = gURLBar.selectionEnd = 0, gURLBar.blur(), gURLBar.view.isOpen)
        gURLBar.view.close();
    } catch (e) {
      PREFS2.debugError("urlbarAI: Error in _closeUrlBar", e);
    }
  },
  animateAIOn() {
    if (!this.hideSuggestions)
      return !1;
    if (!this.animationsEnabled)
      return this._hideSuggestions(), !1;
    try {
      let textbox = gURLBar;
      if (!textbox)
        return !1;
      if (!gURLBar.view.isOpen)
        return this._hideSuggestions(), !1;
      let height = textbox.getBoundingClientRect().height;
      if (!height)
        return;
      this._originalHeight = height, textbox.style.setProperty("height", height + "px", "important"), textbox.style.setProperty("overflow", "hidden", "important"), textbox.style.setProperty("transition", "height 0.15s ease", "important");
      let panelHeight = gURLBar.panel.getBoundingClientRect().height, inputHeight = height - panelHeight - 10;
      setTimeout(() => textbox.style.setProperty("height", inputHeight + "px", "important"), 1), setTimeout(() => this._hideSuggestions(), 151);
    } catch (e) {
      return PREFS2.debugError("Error while animating", e), !1;
    }
    return !0;
  },
  animateAIOff() {
    if (!this.hideSuggestions)
      return !1;
    if (!this.animationsEnabled)
      return this._resetHideSuggestions(), !1;
    try {
      let textbox = gURLBar;
      if (!textbox)
        return !1;
      if (!gURLBar.view.isOpen)
        return this._resetHideSuggestions(), !1;
      if (!this._originalHeight)
        return !1;
      let height = textbox.getBoundingClientRect().height;
      if (!height)
        return;
      if (height === this._originalHeight)
        return;
      textbox.style.setProperty("transition", "height 0.15s ease", "important"), textbox.style.setProperty("overflow", "hidden", "important"), setTimeout(() => {
        textbox.style.setProperty("height", this._originalHeight + "px", "important"), this._originalHeight = null;
      }, 1), setTimeout(() => {
        this.clearAnimationPropertiesInUrlBar(), this._resetHideSuggestions();
      }, 151);
    } catch (e) {
      return PREFS2.debugError("Error while animating", e), !1;
    }
    return !0;
  },
  clearAnimationPropertiesInUrlBar() {
    try {
      let textbox = gURLBar;
      if (!textbox)
        return;
      textbox.style.removeProperty("transition"), textbox.style.removeProperty("overflow"), textbox.style.removeProperty("height");
    } catch {}
  },
  toggleAIMode(forceState, forceClose = !1) {
    let newState = typeof forceState === "boolean" ? forceState : !this._isAIMode;
    if (newState === this._isAIMode)
      return;
    if (PREFS2.debugLog(`urlbarAI: Toggling AI mode. Current: ${this._isAIMode}, New: ${newState}`), this._isAIMode = newState, this._isAIMode)
      gURLBar.value = "", gURLBar.setAttribute("ai-mode-active", "true"), gURLBar.inputField.setAttribute("placeholder", "Command to AI"), this.animateAIOn(), gURLBar.startQuery(), gURLBar.focus();
    else {
      if (forceClose)
        this._closeUrlBar();
      else
        this.animateAIOff();
      gURLBar.removeAttribute("ai-mode-active"), gURLBar.removeAttribute("is-ai-thinking"), gURLBar.inputField.setAttribute("placeholder", this._originalPlaceholder), gURLBar.value = "";
    }
    PREFS2.debugLog(`urlbarAI: AI mode is now ${this._isAIMode ? "ON" : "OFF"}`);
  },
  handleUrlbarKeyDown(e) {
    if (this._isAIMode) {
      if ((e.key === "ArrowUp" || e.key === "ArrowDown") && this.hideSuggestions || e.key === "Tab") {
        e.preventDefault(), e.stopPropagation();
        return;
      }
      if (e.key === "Enter")
        PREFS2.debugLog("urlbarAI: Enter key pressed in AI mode"), e.preventDefault(), e.stopPropagation(), this.send();
    }
  },
  addListeners() {
    PREFS2.debugLog("urlbarAI: Adding event listeners"), this._boundHandleUrlbarKeyDown = this.handleUrlbarKeyDown.bind(this), this._boundDisableAIMode = () => {
      if (gURLBar.inputField.setAttribute("placeholder", this._originalPlaceholder), this._isAIMode)
        PREFS2.debugLog("urlbarAI: Disabling AI mode due to blur or popup hide"), this.toggleAIMode(!1), this.clearAnimationPropertiesInUrlBar(), this._resetHideSuggestions();
    }, gURLBar.inputField.addEventListener("keydown", this._boundHandleUrlbarKeyDown, !0), gURLBar.inputField.addEventListener("blur", this._boundDisableAIMode), gURLBar.view.panel.addEventListener("popuphiding", this._boundDisableAIMode);
  },
  removeListeners() {
    if (PREFS2.debugLog("urlbarAI: Removing event listeners"), this._boundHandleUrlbarKeyDown)
      gURLBar.inputField.removeEventListener("keydown", this._boundHandleUrlbarKeyDown, !0), this._boundHandleUrlbarKeyDown = null;
    if (this._boundDisableAIMode)
      gURLBar.inputField.removeEventListener("blur", this._boundDisableAIMode), gURLBar.view.panel.removeEventListener("popuphiding", this._boundDisableAIMode), this._boundDisableAIMode = null;
  },
  send() {
    let prompt = gURLBar.value.trim();
    if (prompt)
      PREFS2.debugLog(`URLbar: Sending prompt: "${prompt}"`), gURLBar.value = "", gURLBar.setAttribute("is-ai-thinking", "true"), gURLBar.inputField.setAttribute("placeholder", "AI thinking..."), urlBarLLM.sendMessage(prompt).finally(() => {
        gURLBar.removeAttribute("is-ai-thinking"), gURLBar.inputField.setAttribute("placeholder", this._originalPlaceholder), this.toggleAIMode(!1, !0), setTimeout(() => urlBarLLM.clearData(), 4000);
      });
    else
      this.toggleAIMode(!1, !0);
  },
  addAskButton() {
    if (PREFS2.debugLog("urlbarAI: Adding 'Ask' button"), document.getElementById("urlbar-ask-ai-button")) {
      PREFS2.debugLog("urlbarAI: 'Ask' button already exists.");
      return;
    }
    let button = parseElement(`
      <toolbarbutton id="urlbar-ask-ai-button" class="urlbar-icon"
        image="chrome://global/skin/icons/highlights.svg" tooltiptext="Ask AI"/>
    `, "xul");
    button.addEventListener("click", () => setTimeout(() => this.send(), 100));
    let insertButton = (retryCount = 0) => {
      let inputContainer = document.querySelector("#urlbar .urlbar-input-container");
      if (inputContainer)
        inputContainer.appendChild(button), PREFS2.debugLog("urlbarAI: 'Ask' button added successfully to .urlbar-input-container");
      else if (retryCount < 10)
        PREFS2.debugError(`Could not find #urlbar .urlbar-input-container to add the 'Ask' button. Retrying in 500ms... (attempt ${retryCount + 1})`), setTimeout(() => insertButton(retryCount + 1), 500);
      else
        PREFS2.debugError("Could not find #urlbar .urlbar-input-container after multiple attempts. Giving up.");
    };
    insertButton();
  },
  removeAskButton() {
    PREFS2.debugLog("urlbarAI: Removing 'Ask' button");
    let button = document.getElementById("urlbar-ask-ai-button");
    if (button)
      button.remove(), PREFS2.debugLog("urlbarAI: 'Ask' button removed.");
  },
  handlePrefChange(pref) {
    if (pref.value)
      this.init();
    else
      this.destroy();
  }
};

// utils/startup-finish.js
function startupFinish(callback) {
  if (document.readyState === "complete")
    callback();
  else
    window.addEventListener("load", callback, { once: !0 });
}

// findbar-ai/index.js
function setupCommandPaletteIntegration(retryCount = 0) {
  if (window.ZenCommandPalette)
    PREFS2.debugLog("Integrating with Zen Command Palette..."), window.ZenCommandPalette.addCommands([
      {
        key: "browsebot:summarize",
        label: "Summarize Page",
        command: () => {
          browseBotFindbar.expanded = !0, browseBotFindbar.sendMessage(PREFS2.contextMenuCommandNoSelection), browseBotFindbar.focusPrompt();
        },
        condition: () => PREFS2.enabled,
        icon: "chrome://global/skin/icons/highlights.svg",
        tags: ["AI", "Summarize", "BrowseBot", "findbar"]
      },
      {
        key: "browsebot:settings",
        label: "Open BrowseBot Settings",
        command: () => SettingsModal.show(),
        icon: "chrome://global/skin/icons/settings.svg",
        tags: ["AI", "BrowseBot", "Settings"]
      },
      {
        key: "browsebot:urlbarAi",
        label: "Toggle URL bar AI mode",
        command: () => urlbarAI.toggleAIMode(),
        condition: () => urlbarAI.enabled,
        icon: "chrome://global/skin/icons/highlights.svg",
        tags: ["AI", "BrowseBot", "URL", "Command"]
      },
      {
        key: "browsebot:expand-findbar",
        label: "Expand findbar AI",
        command: () => browseBotFindbar.expanded = !0,
        condition: () => PREFS2.enabled,
        icon: "chrome://global/skin/icons/highlights.svg",
        tags: ["AI", "BrowseBot", "findbar"]
      }
    ]), PREFS2.debugLog("Zen Command Palette integration successful.");
  else if (PREFS2.debugLog("Zen Command Palette not found, retrying in 1000ms"), retryCount < 10)
    setTimeout(() => setupCommandPaletteIntegration(retryCount + 1), 1000);
  else
    PREFS2.debugError("Could not integrate with Zen Command Palette after 10 retries.");
}
function registerUrlBarShortcut(value = PREFS2.shortcutUrlbar) {
  if (!urlbarAI.enabled)
    return;
  registerShortcut(value, "toggle-url-bar-ai", () => {
    urlbarAI.toggleAIMode();
  });
}
function registerFindbarShortcut(value = PREFS2.shortcutFindbar) {
  if (!browseBotFindbar.enabled)
    return;
  registerShortcut(value, "toggle-findbar-ai-bar", () => {
    browseBotFindbar.expanded = !browseBotFindbar.expanded;
  }), initShortcutRegistry();
}
function setupShortcuts() {
  registerFindbarShortcut(), registerUrlBarShortcut(), addPrefListener(PREFS2.SHORTCUT_URLBAR, (val) => registerUrlBarShortcut(val.value)), addPrefListener(PREFS2.SHORTCUT_FINDBAR, (val) => registerFindbarShortcut(val.value));
}
function init() {
  browseBotFindbar.init(), addPrefListener(PREFS2.ENABLED, (val) => {
    browseBotFindbar.handleEnabledChange(val), registerFindbarShortcut();
  }), window.browseBotFindbar = browseBotFindbar, urlbarAI.init(), addPrefListener(PREFS2.URLBAR_AI_ENABLED, (val) => {
    urlbarAI.handlePrefChange(), registerUrlBarShortcut(val);
  }), setupShortcuts(), setupCommandPaletteIntegration();
}
startupFinish(init);
