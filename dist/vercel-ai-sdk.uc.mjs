var __create = Object.create;
var { getPrototypeOf: __getProtoOf, defineProperty: __defProp, getOwnPropertyNames: __getOwnPropNames } = Object;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: !0
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: !0,
      configurable: !0,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/@vercel/oidc/dist/get-context.js
var require_get_context = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export2 = (target, all) => {
    for (var name15 in all)
      __defProp2(target, name15, { get: all[name15], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), get_context_exports = {};
  __export2(get_context_exports, {
    SYMBOL_FOR_REQ_CONTEXT: () => SYMBOL_FOR_REQ_CONTEXT,
    getContext: () => getContext2
  });
  module.exports = __toCommonJS(get_context_exports);
  var SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
  function getContext2() {
    return globalThis[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
  }
});

// node_modules/@vercel/oidc/dist/index-browser.js
var require_index_browser = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export2 = (target, all) => {
    for (var name15 in all)
      __defProp2(target, name15, { get: all[name15], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), index_browser_exports = {};
  __export2(index_browser_exports, {
    getContext: () => import_get_context.getContext,
    getVercelOidcToken: () => getVercelOidcToken,
    getVercelOidcTokenSync: () => getVercelOidcTokenSync
  });
  module.exports = __toCommonJS(index_browser_exports);
  var import_get_context = require_get_context();
  async function getVercelOidcToken() {
    return "";
  }
  function getVercelOidcTokenSync() {
    return "";
  }
});

// node_modules/@ai-sdk/provider/dist/index.mjs
var marker = "vercel.ai.error", symbol = Symbol.for(marker), _a, _b, AISDKError = class _AISDKError extends (_b = Error, _a = symbol, _b) {
  constructor({
    name: name14,
    message,
    cause
  }) {
    super(message);
    this[_a] = !0, this.name = name14, this.cause = cause;
  }
  static isInstance(error) {
    return _AISDKError.hasMarker(error, marker);
  }
  static hasMarker(error, marker15) {
    let markerSymbol = Symbol.for(marker15);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === !0;
  }
}, name = "AI_APICallError", marker2 = `vercel.ai.error.${name}`, symbol2 = Symbol.for(marker2), _a2, _b2, APICallError = class extends (_b2 = AISDKError, _a2 = symbol2, _b2) {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || statusCode === 409 || statusCode === 429 || statusCode >= 500),
    data
  }) {
    super({ name, message, cause });
    this[_a2] = !0, this.url = url, this.requestBodyValues = requestBodyValues, this.statusCode = statusCode, this.responseHeaders = responseHeaders, this.responseBody = responseBody, this.isRetryable = isRetryable, this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker2);
  }
}, name2 = "AI_EmptyResponseBodyError", marker3 = `vercel.ai.error.${name2}`, symbol3 = Symbol.for(marker3), _a3, _b3, EmptyResponseBodyError = class extends (_b3 = AISDKError, _a3 = symbol3, _b3) {
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name2, message });
    this[_a3] = !0;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker3);
  }
};
function getErrorMessage(error) {
  if (error == null)
    return "unknown error";
  if (typeof error === "string")
    return error;
  if (error instanceof Error)
    return error.message;
  return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError", marker4 = `vercel.ai.error.${name3}`, symbol4 = Symbol.for(marker4), _a4, _b4, InvalidArgumentError = class extends (_b4 = AISDKError, _a4 = symbol4, _b4) {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = !0, this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4);
  }
}, name4 = "AI_InvalidPromptError", marker5 = `vercel.ai.error.${name4}`, symbol5 = Symbol.for(marker5), _a5, _b5, InvalidPromptError = class extends (_b5 = AISDKError, _a5 = symbol5, _b5) {
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name4, message: `Invalid prompt: ${message}`, cause });
    this[_a5] = !0, this.prompt = prompt;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker5);
  }
}, name5 = "AI_InvalidResponseDataError", marker6 = `vercel.ai.error.${name5}`, symbol6 = Symbol.for(marker6), _a6, _b6, InvalidResponseDataError = class extends (_b6 = AISDKError, _a6 = symbol6, _b6) {
  constructor({
    data,
    message = `Invalid response data: ${JSON.stringify(data)}.`
  }) {
    super({ name: name5, message });
    this[_a6] = !0, this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker6);
  }
}, name6 = "AI_JSONParseError", marker7 = `vercel.ai.error.${name6}`, symbol7 = Symbol.for(marker7), _a7, _b7, JSONParseError = class extends (_b7 = AISDKError, _a7 = symbol7, _b7) {
  constructor({ text, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = !0, this.text = text;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7);
  }
}, name7 = "AI_LoadAPIKeyError", marker8 = `vercel.ai.error.${name7}`, symbol8 = Symbol.for(marker8), _a8, _b8, LoadAPIKeyError = class extends (_b8 = AISDKError, _a8 = symbol8, _b8) {
  constructor({ message }) {
    super({ name: name7, message });
    this[_a8] = !0;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker8);
  }
}, name8 = "AI_LoadSettingError", marker9 = `vercel.ai.error.${name8}`, symbol9 = Symbol.for(marker9), _a9, _b9, LoadSettingError = class extends (_b9 = AISDKError, _a9 = symbol9, _b9) {
  constructor({ message }) {
    super({ name: name8, message });
    this[_a9] = !0;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker9);
  }
}, name9 = "AI_NoContentGeneratedError", marker10 = `vercel.ai.error.${name9}`, symbol10 = Symbol.for(marker10), _a10, _b10, NoContentGeneratedError = class extends (_b10 = AISDKError, _a10 = symbol10, _b10) {
  constructor({
    message = "No content generated."
  } = {}) {
    super({ name: name9, message });
    this[_a10] = !0;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker10);
  }
}, name10 = "AI_NoSuchModelError", marker11 = `vercel.ai.error.${name10}`, symbol11 = Symbol.for(marker11), _a11, _b11, NoSuchModelError = class extends (_b11 = AISDKError, _a11 = symbol11, _b11) {
  constructor({
    errorName = name10,
    modelId,
    modelType,
    message = `No such ${modelType}: ${modelId}`
  }) {
    super({ name: errorName, message });
    this[_a11] = !0, this.modelId = modelId, this.modelType = modelType;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker11);
  }
}, name11 = "AI_TooManyEmbeddingValuesForCallError", marker12 = `vercel.ai.error.${name11}`, symbol12 = Symbol.for(marker12), _a12, _b12, TooManyEmbeddingValuesForCallError = class extends (_b12 = AISDKError, _a12 = symbol12, _b12) {
  constructor(options) {
    super({
      name: name11,
      message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
    });
    this[_a12] = !0, this.provider = options.provider, this.modelId = options.modelId, this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall, this.values = options.values;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker12);
  }
}, name12 = "AI_TypeValidationError", marker13 = `vercel.ai.error.${name12}`, symbol13 = Symbol.for(marker13), _a13, _b13, TypeValidationError = class _TypeValidationError extends (_b13 = AISDKError, _a13 = symbol13, _b13) {
  constructor({
    value,
    cause,
    context
  }) {
    let contextPrefix = "Type validation failed";
    if (context == null ? void 0 : context.field)
      contextPrefix += ` for ${context.field}`;
    if ((context == null ? void 0 : context.entityName) || (context == null ? void 0 : context.entityId)) {
      contextPrefix += " (";
      let parts = [];
      if (context.entityName)
        parts.push(context.entityName);
      if (context.entityId)
        parts.push(`id: "${context.entityId}"`);
      contextPrefix += parts.join(", "), contextPrefix += ")";
    }
    super({
      name: name12,
      message: `${contextPrefix}: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = !0, this.value = value, this.context = context;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13);
  }
  static wrap({
    value,
    cause,
    context
  }) {
    var _a15, _b15, _c;
    if (_TypeValidationError.isInstance(cause) && cause.value === value && ((_a15 = cause.context) == null ? void 0 : _a15.field) === (context == null ? void 0 : context.field) && ((_b15 = cause.context) == null ? void 0 : _b15.entityName) === (context == null ? void 0 : context.entityName) && ((_c = cause.context) == null ? void 0 : _c.entityId) === (context == null ? void 0 : context.entityId))
      return cause;
    return new _TypeValidationError({ value, cause, context });
  }
}, name13 = "AI_UnsupportedFunctionalityError", marker14 = `vercel.ai.error.${name13}`, symbol14 = Symbol.for(marker14), _a14, _b14, UnsupportedFunctionalityError = class extends (_b14 = AISDKError, _a14 = symbol14, _b14) {
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name13, message });
    this[_a14] = !0, this.functionality = functionality;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker14);
  }
};

// node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  util: () => exports_util,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol15,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeEncode: () => safeEncode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeDecode: () => safeDecode2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse3,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  meta: () => meta2,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  mac: () => mac2,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  fromJSONSchema: () => fromJSONSchema,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  encodeAsync: () => encodeAsync2,
  encode: () => encode2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  decodeAsync: () => decodeAsync2,
  decode: () => decode2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  codec: () => codec,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  safeEncodeAsync: () => safeEncodeAsync,
  safeEncode: () => safeEncode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeDecode: () => safeDecode,
  registry: () => registry,
  regexes: () => exports_regexes,
  process: () => process2,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse,
  meta: () => meta,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  initializeContext: () => initializeContext,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  formatError: () => formatError,
  flattenError: () => flattenError,
  finalize: () => finalize,
  extractDefs: () => extractDefs,
  encodeAsync: () => encodeAsync,
  encode: () => encode,
  describe: () => describe,
  decodeAsync: () => decodeAsync,
  decode: () => decode,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  config: () => config,
  clone: () => clone,
  _xor: () => _xor,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _superRefine: () => _superRefine,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _slugify: () => _slugify,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeEncode: () => _safeEncode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeDecode: () => _safeDecode,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _mac: () => _mac,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _encodeAsync: () => _encodeAsync,
  _encode: () => _encode,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _decodeAsync: () => _decodeAsync,
  _decode: () => _decode,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _check: () => _check,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXor: () => $ZodXor,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodMAC: () => $ZodMAC,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCodec: () => $ZodCodec,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name14, initializer, params) {
  function init(inst, def) {
    if (!inst._zod)
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set
        },
        enumerable: !1
      });
    if (inst._zod.traits.has(name14))
      return;
    inst._zod.traits.add(name14), initializer(inst, def);
    let proto = _.prototype, keys = Object.keys(proto);
    for (let i = 0;i < keys.length; i++) {
      let k = keys[i];
      if (!(k in inst))
        inst[k] = proto[k].bind(inst);
    }
  }
  let Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name14 });
  function _(def) {
    var _a15;
    let inst = params?.Parent ? new Definition : this;
    init(inst, def), (_a15 = inst._zod).deferred ?? (_a15.deferred = []);
    for (let fn of inst._zod.deferred)
      fn();
    return inst;
  }
  return Object.defineProperty(_, "init", { value: init }), Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return !0;
      return inst?._zod?.traits?.has(name14);
    }
  }), Object.defineProperty(_, "name", { value: name14 }), _;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}

class $ZodEncodeError extends Error {
  constructor(name14) {
    super(`Encountered unidirectional transform during encode: ${name14}`);
    this.name = "ZodEncodeError";
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  uint8ArrayToHex: () => uint8ArrayToHex,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  stringifyPrimitive: () => stringifyPrimitive,
  slugify: () => slugify,
  shallowClone: () => shallowClone,
  safeExtend: () => safeExtend,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  parsedType: () => parsedType,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  objectClone: () => objectClone,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  mergeDefs: () => mergeDefs,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  hexToUint8Array: () => hexToUint8Array,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  cloneDef: () => cloneDef,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  base64urlToUint8Array: () => base64urlToUint8Array,
  base64ToUint8Array: () => base64ToUint8Array,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw Error("Unexpected value in exhaustive check");
}
function assert(_) {}
function getEnumValues(entries) {
  let numericValues = Object.values(entries).filter((v) => typeof v === "number");
  return Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  return {
    get value() {
      {
        let value = getter();
        return Object.defineProperty(this, "value", { value }), value;
      }
      throw Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepString = step.toString(), stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    let match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1])
      stepDecCount = Number.parseInt(match[1]);
  }
  let decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
  let value = void 0;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING)
        return;
      if (value === void 0)
        value = EVALUATING, value = getter();
      return value;
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: !0
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function mergeDefs(...defs) {
  let mergedDescriptors = {};
  for (let def of defs) {
    let descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  let keys = Object.keys(promisesObj), promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    let resolvedObj = {};
    for (let i = 0;i < keys.length; i++)
      resolvedObj[keys[i]] = results[i];
    return resolvedObj;
  });
}
function randomString(length = 10) {
  let str = "";
  for (let i = 0;i < length; i++)
    str += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    return new Function(""), !0;
  } catch (_) {
    return !1;
  }
});
function isPlainObject(o) {
  if (isObject(o) === !1)
    return !1;
  let ctor = o.constructor;
  if (ctor === void 0)
    return !0;
  if (typeof ctor !== "function")
    return !0;
  let prot = ctor.prototype;
  if (isObject(prot) === !1)
    return !1;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === !1)
    return !1;
  return !0;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (let key in data)
    if (Object.prototype.hasOwnProperty.call(data, key))
      keyCount++;
  return keyCount;
}
var getParsedType = (data) => {
  let t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data))
        return "array";
      if (data === null)
        return "null";
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function")
        return "promise";
      if (typeof Map < "u" && data instanceof Map)
        return "map";
      if (typeof Set < "u" && data instanceof Set)
        return "set";
      if (typeof Date < "u" && data instanceof Date)
        return "date";
      if (typeof File < "u" && data instanceof File)
        return "file";
      return "object";
    default:
      throw Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]), primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  let cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  let params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  if (delete params.message, typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      return target ?? (target = getter()), Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      return target ?? (target = getter()), Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      return target ?? (target = getter()), Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      return target ?? (target = getter()), Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      return target ?? (target = getter()), Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      return target ?? (target = getter()), Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      return target ?? (target = getter()), Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
}, BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw Error(".pick() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = {};
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw Error(`Unrecognized key: "${key}"`);
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw Error(".omit() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = { ...schema._zod.def.shape };
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw Error(`Unrecognized key: "${key}"`);
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape))
    throw Error("Invalid input to extend: expected a plain object");
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0) {
    let existingShape = schema._zod.def.shape;
    for (let key in shape)
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0)
        throw Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape))
    throw Error("Invalid input to safeExtend: expected a plain object");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  let def = mergeDefs(a._zod.def, {
    get shape() {
      let _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      return assignProp(this, "shape", _shape), _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0)
    throw Error(".partial() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in oldShape))
            throw Error(`Unrecognized key: "${key}"`);
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      else
        for (let key in oldShape)
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
      return assignProp(this, "shape", shape), shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in shape))
            throw Error(`Unrecognized key: "${key}"`);
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      else
        for (let key in oldShape)
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
      return assignProp(this, "shape", shape), shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === !0)
    return !0;
  for (let i = startIndex;i < x.issues.length; i++)
    if (x.issues[i]?.continue !== !0)
      return !0;
  return !1;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a15;
    return (_a15 = iss).path ?? (_a15.path = []), iss.path.unshift(path), iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  let full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    let message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  if (delete full.inst, delete full.continue, !ctx?.reportInput)
    delete full.input;
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  let t = typeof data;
  switch (t) {
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "object": {
      if (data === null)
        return "null";
      if (Array.isArray(data))
        return "array";
      let obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor)
        return obj.constructor.name;
    }
  }
  return t;
}
function issue(...args) {
  let [iss, input, inst] = args;
  if (typeof iss === "string")
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base64) {
  let binaryString = atob(base64), bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++)
    bytes[i] = binaryString.charCodeAt(i);
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++)
    binaryString += String.fromCharCode(bytes[i]);
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  let base64 = base64url.replace(/-/g, "+").replace(/_/g, "/"), padding = "=".repeat((4 - base64.length % 4) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  let cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0)
    throw Error("Invalid hex string length");
  let bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2)
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}

class Class {
  constructor(..._args) {}
}

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError", Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: !1
  }), Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: !1
  }), inst.message = JSON.stringify(def, jsonStringifyReplacer, 2), Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: !1
  });
}, $ZodError = $constructor("$ZodError", initializer), $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  let fieldErrors = {}, formErrors = [];
  for (let sub of error.issues)
    if (sub.path.length > 0)
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [], fieldErrors[sub.path[0]].push(mapper(sub));
    else
      formErrors.push(mapper(sub));
  return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue2) => issue2.message) {
  let fieldErrors = { _errors: [] }, processError = (error2) => {
    for (let issue2 of error2.issues)
      if (issue2.code === "invalid_union" && issue2.errors.length)
        issue2.errors.map((issues) => processError({ issues }));
      else if (issue2.code === "invalid_key")
        processError({ issues: issue2.issues });
      else if (issue2.code === "invalid_element")
        processError({ issues: issue2.issues });
      else if (issue2.path.length === 0)
        fieldErrors._errors.push(mapper(issue2));
      else {
        let curr = fieldErrors, i = 0;
        while (i < issue2.path.length) {
          let el = issue2.path[i];
          if (i !== issue2.path.length - 1)
            curr[el] = curr[el] || { _errors: [] };
          else
            curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2));
          curr = curr[el], i++;
        }
      }
  };
  return processError(error), fieldErrors;
}
function treeifyError(error, mapper = (issue2) => issue2.message) {
  let result = { errors: [] }, processError = (error2, path = []) => {
    var _a15, _b15;
    for (let issue2 of error2.issues)
      if (issue2.code === "invalid_union" && issue2.errors.length)
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      else if (issue2.code === "invalid_key")
        processError({ issues: issue2.issues }, issue2.path);
      else if (issue2.code === "invalid_element")
        processError({ issues: issue2.issues }, issue2.path);
      else {
        let fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result, i = 0;
        while (i < fullpath.length) {
          let el = fullpath[i], terminal = i === fullpath.length - 1;
          if (typeof el === "string")
            curr.properties ?? (curr.properties = {}), (_a15 = curr.properties)[el] ?? (_a15[el] = { errors: [] }), curr = curr.properties[el];
          else
            curr.items ?? (curr.items = []), (_b15 = curr.items)[el] ?? (_b15[el] = { errors: [] }), curr = curr.items[el];
          if (terminal)
            curr.errors.push(mapper(issue2));
          i++;
        }
      }
  };
  return processError(error), result;
}
function toDotPath(_path) {
  let segs = [], path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (let seg of path)
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  return segs.join("");
}
function prettifyError(error) {
  let lines = [], issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (let issue2 of issues)
    if (lines.push(` ${issue2.message}`), issue2.path?.length)
      lines.push(`   at ${toDotPath(issue2.path)}`);
  return lines.join(`
`);
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !1 }) : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError;
  if (result.issues.length) {
    let e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, _params?.callee), e;
  }
  return result.value;
}, parse = /* @__PURE__ */ _parse($ZodRealError), _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    let e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, params?.callee), e;
  }
  return result.value;
}, parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError), _safeParse = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? { ..._ctx, async: !1 } : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError;
  return result.issues.length ? {
    success: !1,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParse = /* @__PURE__ */ _safeParse($ZodRealError), _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: !1,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError), _encode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
}, encode = /* @__PURE__ */ _encode($ZodRealError), _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
}, decode = /* @__PURE__ */ _decode($ZodRealError), _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
}, encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError), _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
}, decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError), _safeEncode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
}, safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError), _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
}, safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError), _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
}, safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError), _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
}, safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  sha512_hex: () => sha512_hex,
  sha512_base64url: () => sha512_base64url,
  sha512_base64: () => sha512_base64,
  sha384_hex: () => sha384_hex,
  sha384_base64url: () => sha384_base64url,
  sha384_base64: () => sha384_base64,
  sha256_hex: () => sha256_hex,
  sha256_base64url: () => sha256_base64url,
  sha256_base64: () => sha256_base64,
  sha1_hex: () => sha1_hex,
  sha1_base64url: () => sha1_base64url,
  sha1_base64: () => sha1_base64,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  md5_hex: () => md5_hex,
  md5_base64url: () => md5_base64url,
  md5_base64: () => md5_base64,
  mac: () => mac,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  idnEmail: () => idnEmail,
  html5Email: () => html5Email,
  hostname: () => hostname,
  hex: () => hex,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
var cuid = /^[cC][^\s-]{8,}$/, cuid2 = /^[0-9a-z]+$/, ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, xid = /^[0-9a-vA-V]{20}$/, ksuid = /^[A-Za-z0-9]{27}$/, nanoid = /^[a-zA-Z0-9_-]{21}$/, duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, uuid4 = /* @__PURE__ */ uuid(4), uuid6 = /* @__PURE__ */ uuid(6), uuid7 = /* @__PURE__ */ uuid(7), email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, idnEmail = unicodeEmail, browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, _emoji = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, mac = (delimiter) => {
  let escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, base64url = /^[A-Za-z0-9_-]*$/, hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, e164 = /^\+[1-9]\d{6,14}$/, dateSource = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  return typeof args.precision === "number" ? args.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : args.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${args.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  let time2 = timeSource({ precision: args.precision }), opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  let regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${regex}$`);
}, bigint = /^-?\d+n?$/, integer = /^-?\d+$/, number = /^-?\d+(?:\.\d+)?$/, boolean = /^(?:true|false)$/i, _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/, uppercase = /^[^a-z]*$/, hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/, md5_base64 = /* @__PURE__ */ fixedBase64(22, "=="), md5_base64url = /* @__PURE__ */ fixedBase64url(22), sha1_hex = /^[0-9a-fA-F]{40}$/, sha1_base64 = /* @__PURE__ */ fixedBase64(27, "="), sha1_base64url = /* @__PURE__ */ fixedBase64url(27), sha256_hex = /^[0-9a-fA-F]{64}$/, sha256_base64 = /* @__PURE__ */ fixedBase64(43, "="), sha256_base64url = /* @__PURE__ */ fixedBase64url(43), sha384_hex = /^[0-9a-fA-F]{96}$/, sha384_base64 = /* @__PURE__ */ fixedBase64(64, ""), sha384_base64url = /* @__PURE__ */ fixedBase64url(64), sha512_hex = /^[0-9a-fA-F]{128}$/, sha512_base64 = /* @__PURE__ */ fixedBase64(86, "=="), sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a15;
  inst._zod ?? (inst._zod = {}), inst._zod.def = def, (_a15 = inst._zod).onattach ?? (_a15.onattach = []);
}), numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr)
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
  }), inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value)
      return;
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr)
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
  }), inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value)
      return;
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    var _a15;
    (_a15 = inst2._zod.bag).multipleOf ?? (_a15.multipleOf = def.value);
  }), inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw Error("Cannot mix number and bigint in multiple_of check.");
    if (typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def), def.format = def.format || "float64";
  let isInt = def.format?.includes("int"), origin = isInt ? "int" : "number", [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    if (bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum, isInt)
      bag.pattern = integer;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: !1,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0)
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: !0,
            continue: !def.abort
          });
        else
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: !0,
            continue: !def.abort
          });
        return;
      }
    }
    if (input < minimum)
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: !0,
        inst,
        continue: !def.abort
      });
    if (input > maximum)
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: !0,
        inst,
        continue: !def.abort
      });
  };
}), $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  let [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input < minimum)
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: !0,
        inst,
        continue: !def.abort
      });
    if (input > maximum)
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: !0,
        inst,
        continue: !def.abort
      });
  };
}), $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def), (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def), (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def), (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.size, bag.maximum = def.size, bag.size = def.size;
  }), inst._zod.check = (payload) => {
    let input = payload.value, size = input.size;
    if (size === def.size)
      return;
    let tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def), (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length <= def.maximum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def), (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length >= def.minimum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a15;
  $ZodCheck.init(inst, def), (_a15 = inst._zod.def).when ?? (_a15.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.length, bag.maximum = def.length, bag.length = def.length;
  }), inst._zod.check = (payload) => {
    let input = payload.value, length = input.length;
    if (length === def.length)
      return;
    let origin = getLengthableOrigin(input), tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a15, _b15;
  if ($ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    if (bag.format = def.format, def.pattern)
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set), bag.patterns.add(def.pattern);
  }), def.pattern)
    (_a15 = inst._zod).check ?? (_a15.check = (payload) => {
      if (def.pattern.lastIndex = 0, def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b15 = inst._zod).check ?? (_b15.check = () => {});
}), $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), inst._zod.check = (payload) => {
    if (def.pattern.lastIndex = 0, def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  let escapedRegex = escapeRegex(def.includes), pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern, inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length)
    payload.issues.push(...prefixIssues(property, result.issues));
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    let result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise)
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
}), $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  let mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  }), inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    if (this.content = [], this.indent = 0, this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1, fn(this), this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" }), arg(this, { execution: "async" });
      return;
    }
    let lines = arg.split(`
`).filter((x) => x), minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length)), dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (let line of dedented)
      this.content.push(line);
  }
  compile() {
    let F = Function, args = this?.args, lines = [...(this?.content ?? [""]).map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a15;
  inst ?? (inst = {}), inst._zod.def = def, inst._zod.bag = inst._zod.bag || {}, inst._zod.version = version;
  let checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck"))
    checks.unshift(inst);
  for (let ch of checks)
    for (let fn of ch._zod.onattach)
      fn(inst);
  if (checks.length === 0)
    (_a15 = inst._zod).deferred ?? (_a15.deferred = []), inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  else {
    let runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload), asyncResult;
      for (let ch of checks2) {
        if (ch._zod.def.when) {
          if (!ch._zod.def.when(payload))
            continue;
        } else if (isAborted)
          continue;
        let currLen = payload.issues.length, _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === !1)
          throw new $ZodAsyncError;
        if (asyncResult || _ instanceof Promise)
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            if (await _, payload.issues.length === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        else {
          if (payload.issues.length === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult)
        return asyncResult.then(() => {
          return payload;
        });
      return payload;
    }, handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary))
        return canary.aborted = !0, canary;
      let checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError;
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks)
        return inst._zod.parse(payload, ctx);
      if (ctx.direction === "backward") {
        let canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: !0 });
        if (canary instanceof Promise)
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        return handleCanaryResult(canary, payload, ctx);
      }
      let result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        let r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag), inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "string")
      return payload;
    return payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), $ZodString.init(inst, def);
}), $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid), $ZodStringFormat.init(inst, def);
}), $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    let v = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[def.version];
    if (v === void 0)
      throw Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
}), $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email), $ZodStringFormat.init(inst, def);
}), $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    try {
      let trimmed = payload.value.trim(), url = new URL(trimmed);
      if (def.hostname) {
        if (def.hostname.lastIndex = 0, !def.hostname.test(url.hostname))
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
      }
      if (def.protocol) {
        if (def.protocol.lastIndex = 0, !def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol))
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
      }
      if (def.normalize)
        payload.value = url.href;
      else
        payload.value = trimmed;
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji()), $ZodStringFormat.init(inst, def);
}), $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid), $ZodStringFormat.init(inst, def);
}), $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid), $ZodStringFormat.init(inst, def);
}), $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2), $ZodStringFormat.init(inst, def);
}), $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid), $ZodStringFormat.init(inst, def);
}), $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid), $ZodStringFormat.init(inst, def);
}), $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid), $ZodStringFormat.init(inst, def);
}), $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date), $ZodStringFormat.init(inst, def);
}), $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration), $ZodStringFormat.init(inst, def);
}), $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv4";
}), $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv6", inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter)), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "mac";
}), $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4), $ZodStringFormat.init(inst, def);
}), $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6), $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    let parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw Error();
      let [address, prefix] = parts;
      if (!prefix)
        throw Error();
      let prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return !0;
  if (data.length % 4 !== 0)
    return !1;
  try {
    return atob(data), !0;
  } catch {
    return !1;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64", inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return !1;
  let base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/"), padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64url", inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164), $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    let tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return !1;
    let [header] = tokensParts;
    if (!header)
      return !1;
    let parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return !1;
    if (!parsedHeader.alg)
      return !1;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return !1;
    return !0;
  } catch {
    return !1;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = inst._zod.bag.pattern ?? number, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    let input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input))
      return payload;
    let received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    return payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    }), payload;
  };
}), $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def), $ZodNumber.init(inst, def);
}), $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = boolean, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    let input = payload.value;
    if (typeof input === "boolean")
      return payload;
    return payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = bigint, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {}
    if (typeof payload.value === "bigint")
      return payload;
    return payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def), $ZodBigInt.init(inst, def);
}), $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    if (typeof input === "symbol")
      return payload;
    return payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _undefined, inst._zod.values = /* @__PURE__ */ new Set([void 0]), inst._zod.optin = "optional", inst._zod.optout = "optional", inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    if (typeof input > "u")
      return payload;
    return payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _null, inst._zod.values = /* @__PURE__ */ new Set([null]), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    if (input === null)
      return payload;
    return payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    return payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    if (typeof input > "u")
      return payload;
    return payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    let input = payload.value, isDate = input instanceof Date;
    if (isDate && !Number.isNaN(input.getTime()))
      return payload;
    return payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    }), payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length)
    final.issues.push(...prefixIssues(index, result.issues));
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = Array(input.length);
    let proms = [];
    for (let i = 0;i < input.length; i++) {
      let item = input[i], result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise)
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      else
        handleArrayResult(result, payload, i);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input))
      return;
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else
    final.value[key] = result.value;
}
function normalizeDef(def) {
  let keys = Object.keys(def.shape);
  for (let k of keys)
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType"))
      throw Error(`Invalid element at key "${k}": expected a Zod schema`);
  let okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  let unrecognized = [], keySet = def.keySet, _catchall = def.catchall._zod, t = _catchall.def.type, isOptionalOut = _catchall.optout === "optional";
  for (let key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    let r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise)
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    else
      handlePropertyResult(r, payload, key, input, isOptionalOut);
  }
  if (unrecognized.length)
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  if ($ZodType.init(inst, def), !Object.getOwnPropertyDescriptor(def, "shape")?.get) {
    let sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        let newSh = { ...sh };
        return Object.defineProperty(def, "shape", {
          value: newSh
        }), newSh;
      }
    });
  }
  let _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    let shape = def.shape, propValues = {};
    for (let key in shape) {
      let field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set);
        for (let v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  let isObject2 = isObject, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    if (!isObject2(input))
      return payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = {};
    let proms = [], shape = value.shape;
    for (let key of value.keys) {
      let el = shape[key], isOptionalOut = el._zod.optout === "optional", r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise)
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      else
        handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
    if (!catchall)
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
}), $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  let superParse = inst._zod.parse, _normalized = cached(() => normalizeDef(def)), generateFastpass = (shape) => {
    let doc = new Doc(["shape", "payload", "ctx"]), normalized = _normalized.value, parseStr = (key) => {
      let k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write("const input = payload.value;");
    let ids = Object.create(null), counter = 0;
    for (let key of normalized.keys)
      ids[key] = `key_${counter++}`;
    doc.write("const newResult = {};");
    for (let key of normalized.keys) {
      let id = ids[key], k = esc(key), isOptionalOut = shape[key]?._zod?.optout === "optional";
      if (doc.write(`const ${id} = ${parseStr(key)};`), isOptionalOut)
        doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      else
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write("payload.value = newResult;"), doc.write("return payload;");
    let fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  }, fastpass, isObject2 = isObject, jit = !globalConfig.jitless, fastEnabled = jit && allowsEval.value, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    if (!isObject2(input))
      return payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      }), payload;
    if (jit && fastEnabled && ctx?.async === !1 && ctx.jitless !== !0) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      if (payload = fastpass(payload, ctx), !catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (let result of results)
    if (result.issues.length === 0)
      return final.value = result.value, final;
  let nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1)
    return final.value = nonaborted[0].value, nonaborted[0];
  return final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }), final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0), defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0), defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values))
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    return;
  }), defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      let patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return;
  });
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise)
        results.push(result), async = !0;
      else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  let successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1)
    return final.value = successes[0].value, final;
  if (successes.length === 0)
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  else
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: !1
    });
  return final;
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def), def.inclusive = !1;
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise)
        results.push(result), async = !0;
      else
        results.push(result);
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
}), $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = !1, $ZodUnion.init(inst, def);
  let _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    let propValues = {};
    for (let option of def.options) {
      let pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (let [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set;
        for (let val of v)
          propValues[k].add(val);
      }
    }
    return propValues;
  });
  let disc = cached(() => {
    let opts = def.options, map = /* @__PURE__ */ new Map;
    for (let o of opts) {
      let values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (let v of values) {
        if (map.has(v))
          throw Error(`Duplicate discriminator value "${String(v)}"`);
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isObject(input))
      return payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      }), payload;
    let opt = disc.value.get(input?.[def.discriminator]);
    if (opt)
      return opt._zod.run(payload, ctx);
    if (def.unionFallback)
      return _super(payload, ctx);
    return payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    }), payload;
  };
}), $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value, left = def.left._zod.run({ value: input, issues: [] }, ctx), right = def.right._zod.run({ value: input, issues: [] }, ctx);
    if (left instanceof Promise || right instanceof Promise)
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b)
    return { valid: !0, data: a };
  if (a instanceof Date && b instanceof Date && +a === +b)
    return { valid: !0, data: a };
  if (isPlainObject(a) && isPlainObject(b)) {
    let bKeys = Object.keys(b), sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length)
      return { valid: !1, mergeErrorPath: [] };
    let newArray = [];
    for (let index = 0;index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  let unrecKeys = /* @__PURE__ */ new Map, unrecIssue;
  for (let iss of left.issues)
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (let k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = !0;
      }
    } else
      result.issues.push(iss);
  for (let iss of right.issues)
    if (iss.code === "unrecognized_keys")
      for (let k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = !0;
      }
    else
      result.issues.push(iss);
  let bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue)
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  if (aborted(result))
    return result;
  let merged = mergeValues(left.value, right.value);
  if (!merged.valid)
    throw Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  return result.value = merged.data, result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  let items = def.items;
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      }), payload;
    payload.value = [];
    let proms = [], reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional"), optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      let tooBig = input.length > items.length, tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall)
        return payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: !0 } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        }), payload;
    }
    let i = -1;
    for (let item of items) {
      if (i++, i >= input.length) {
        if (i >= optStart)
          continue;
      }
      let result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise)
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      else
        handleTupleResult(result, payload, i);
    }
    if (def.rest) {
      let rest = input.slice(items.length);
      for (let el of rest) {
        i++;
        let result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise)
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        else
          handleTupleResult(result, payload, i);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length)
    final.issues.push(...prefixIssues(index, result.issues));
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isPlainObject(input))
      return payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [], values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      let recordKeys = /* @__PURE__ */ new Set;
      for (let key of values)
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise)
            proms.push(result.then((result2) => {
              if (result2.issues.length)
                payload.issues.push(...prefixIssues(key, result2.issues));
              payload.value[key] = result2.value;
            }));
          else {
            if (result.issues.length)
              payload.issues.push(...prefixIssues(key, result.issues));
            payload.value[key] = result.value;
          }
        }
      let unrecognized;
      for (let key in input)
        if (!recordKeys.has(key))
          unrecognized = unrecognized ?? [], unrecognized.push(key);
      if (unrecognized && unrecognized.length > 0)
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
    } else {
      payload.value = {};
      for (let key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise)
          throw Error("Async schemas not supported in object keys currently");
        if (typeof key === "string" && number.test(key) && keyResult.issues.length) {
          let retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise)
            throw Error("Async schemas not supported in object keys currently");
          if (retryResult.issues.length === 0)
            keyResult = retryResult;
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose")
            payload.value[key] = input[key];
          else
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
          continue;
        }
        let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise)
          proms.push(result.then((result2) => {
            if (result2.issues.length)
              payload.issues.push(...prefixIssues(key, result2.issues));
            payload.value[keyResult.value] = result2.value;
          }));
        else {
          if (result.issues.length)
            payload.issues.push(...prefixIssues(key, result.issues));
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
}), $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Map))
      return payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Map;
    for (let [key, value] of input) {
      let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx), valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise)
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      else
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length)
    if (propertyKeyTypes.has(typeof key))
      final.issues.push(...prefixIssues(key, keyResult.issues));
    else
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
  if (valueResult.issues.length)
    if (propertyKeyTypes.has(typeof key))
      final.issues.push(...prefixIssues(key, valueResult.issues));
    else
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Set))
      return payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Set;
    for (let item of input) {
      let result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise)
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length)
    final.issues.push(...result.issues);
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  let values = getEnumValues(def.entries), valuesSet = new Set(values);
  inst._zod.values = valuesSet, inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    if (valuesSet.has(input))
      return payload;
    return payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    }), payload;
  };
}), $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  if ($ZodType.init(inst, def), def.values.length === 0)
    throw Error("Cannot create literal schema with no valid values");
  let values = new Set(def.values);
  inst._zod.values = values, inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    if (values.has(input))
      return payload;
    return payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    }), payload;
  };
}), $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    if (input instanceof File)
      return payload;
    return payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    let _out = def.transform(payload.value, payload);
    if (ctx.async)
      return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output2) => {
        return payload.value = output2, payload;
      });
    if (_out instanceof Promise)
      throw new $ZodAsyncError;
    return payload.value = _out, payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0)
    return { issues: [], value: void 0 };
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", inst._zod.optout = "optional", defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  }), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      let result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
}), $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern), inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
}), $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  }), defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
}), $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    if (payload.value === void 0)
      return payload.value = def.defaultValue, payload;
    let result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise)
      return result.then((result2) => handleDefaultResult(result2, def));
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0)
    payload.value = def.defaultValue;
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    if (payload.value === void 0)
      payload.value = def.defaultValue;
    return def.innerType._zod.run(payload, ctx);
  };
}), $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => {
    let v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    let result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise)
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0)
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError("ZodSuccess");
    let result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise)
      return result.then((result2) => {
        return payload.value = result2.issues.length === 0, payload;
      });
    return payload.value = result.issues.length === 0, payload;
  };
}), $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise)
      return result.then((result2) => {
        if (payload.value = result2.value, result2.issues.length)
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          }), payload.issues = [];
        return payload;
      });
    if (payload.value = result.value, result.issues.length)
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      }), payload.issues = [];
    return payload;
  };
}), $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value))
      return payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      }), payload;
    return payload;
  };
}), $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      let right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise)
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      return handlePipeResult(right, def.in, ctx);
    }
    let left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise)
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length)
    return left.aborted = !0, left;
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if ((ctx.direction || "forward") === "forward") {
      let left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise)
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      return handleCodecAResult(left, def, ctx);
    } else {
      let right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise)
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length)
    return result.aborted = !0, result;
  if ((ctx.direction || "forward") === "forward") {
    let transformed = def.transform(result.value, result);
    if (transformed instanceof Promise)
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    let transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise)
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length)
    return left.aborted = !0, left;
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin), defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise)
      return result.then(handleReadonlyResult);
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  return payload.value = Object.freeze(payload.value), payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  let regexParts = [];
  for (let part of def.parts)
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern)
        throw Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      let source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw Error(`Invalid template literal part: ${part._zod.traits}`);
      let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part))
      regexParts.push(escapeRegex(`${part}`));
    else
      throw Error(`Invalid template literal part: ${part}`);
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`), inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string")
      return payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      }), payload;
    if (inst._zod.pattern.lastIndex = 0, !inst._zod.pattern.test(payload.value))
      return payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      }), payload;
    return payload;
  };
}), $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  return $ZodType.init(inst, def), inst._def = def, inst._zod.def = def, inst.implement = (func) => {
    if (typeof func !== "function")
      throw Error("implement() must be called with a function");
    return function(...args) {
      let parsedArgs = inst._def.input ? parse(inst._def.input, args) : args, result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output)
        return parse(inst._def.output, result);
      return result;
    };
  }, inst.implementAsync = (func) => {
    if (typeof func !== "function")
      throw Error("implementAsync() must be called with a function");
    return async function(...args) {
      let parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args, result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output)
        return await parseAsync(inst._def.output, result);
      return result;
    };
  }, inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function")
      return payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      }), payload;
    if (inst._def.output && inst._def.output._zod.def.type === "promise")
      payload.value = inst.implementAsync(payload.value);
    else
      payload.value = inst.implement(payload.value);
    return payload;
  }, inst.input = (...args) => {
    let F = inst.constructor;
    if (Array.isArray(args[0]))
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  }, inst.output = (output) => {
    return new inst.constructor({
      type: "function",
      input: inst._def.input,
      output
    });
  }, inst;
}), $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
}), $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "innerType", () => def.getter()), defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern), defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues), defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0), defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0), inst._zod.parse = (payload, ctx) => {
    return inst._zod.innerType._zod.run(payload, ctx);
  };
}), $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def), $ZodType.init(inst, def), inst._zod.parse = (payload, _) => {
    return payload;
  }, inst._zod.check = (payload) => {
    let input = payload.value, r = def.fn(input);
    if (r instanceof Promise)
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    let _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  yo: () => yo_default,
  vi: () => vi_default,
  uz: () => uz_default,
  ur: () => ur_default,
  uk: () => uk_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  lt: () => lt_default,
  ko: () => ko_default,
  km: () => km_default,
  kh: () => kh_default,
  ka: () => ka_default,
  ja: () => ja_default,
  it: () => it_default,
  is: () => is_default,
  id: () => id_default,
  hy: () => hy_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  da: () => da_default,
  cs: () => cs_default,
  ca: () => ca_default,
  bg: () => bg_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  let Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: " ",
    url: "",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: "  ISO",
    time: "  ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: "   IPv4",
    cidrv6: "   IPv6",
    base64: "  base64-encoded",
    base64url: "  base64url-encoded",
    json_string: "   JSON",
    e164: "   E.164",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `  :   instanceof ${issue2.expected}    ${received}`;
        return `  :   ${expected}    ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :   ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     : ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `   :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :     "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :     ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `    ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${issue2.origin}`;
      default:
        return "  ";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}
// node_modules/zod/v4/locales/az.js
var error2 = () => {
  let Sizable = {
    string: { unit: "simvol", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "element", verb: "olmaldr" },
    set: { unit: "element", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Yanl dyr: gzlniln instanceof ${issue2.expected}, daxil olan ${received}`;
        return `Yanl dyr: gzlniln ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl dyr: gzlniln ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
        if (_issue.format === "ends_with")
          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
        if (_issue.format === "includes")
          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
        if (_issue.format === "regex")
          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${issue2.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${issue2.origin} daxilind yanl dyr`;
      default:
        return "Yanl dyr";
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}
// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  let absCount = Math.abs(count), lastDigit = absCount % 10, lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19)
    return many;
  if (lastDigit === 1)
    return one;
  if (lastDigit >= 2 && lastDigit <= 4)
    return few;
  return many;
}
var error3 = () => {
  let Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` :  instanceof ${issue2.expected},  ${received}`;
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing) {
          let maxValue = Number(issue2.maximum), unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin ?? ""}  ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing) {
          let minValue = Number(issue2.minimum), unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin}  ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return " ";
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}
// node_modules/zod/v4/locales/bg.js
var error4 = () => {
  let Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` :  instanceof ${issue2.expected},  ${received}`;
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :     "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :     ${_issue.pattern}`;
        let invalid_adj = "";
        if (_issue.format === "emoji")
          invalid_adj = "";
        if (_issue.format === "datetime")
          invalid_adj = "";
        if (_issue.format === "date")
          invalid_adj = "";
        if (_issue.format === "time")
          invalid_adj = "";
        if (_issue.format === "duration")
          invalid_adj = "";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return " ";
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}
// node_modules/zod/v4/locales/ca.js
var error5 = () => {
  let Sizable = {
    string: { unit: "carcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "entrada",
    email: "adrea electrnica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adrea IPv4",
    ipv6: "adrea IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Tipus invlid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        return `Tipus invlid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci invlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "com a mxim" : "menys de", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingus ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? "com a mnim" : "ms de", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa petit: s'esperava que ${issue2.origin} contingus ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
        return `Format invlid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${issue2.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}
// node_modules/zod/v4/locales/cs.js
var error6 = () => {
  let Sizable = {
    string: { unit: "znak", verb: "mt" },
    file: { unit: "bajt", verb: "mt" },
    array: { unit: "prvk", verb: "mt" },
    set: { unit: "prvk", verb: "mt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "regulrn vraz",
    email: "e-mailov adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a as ve formtu ISO",
    date: "datum ve formtu ISO",
    time: "as ve formtu ISO",
    duration: "doba trvn ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "etzec zakdovan ve formtu base64",
    base64url: "etzec zakdovan ve formtu base64url",
    json_string: "etzec ve formtu JSON",
    e164: "slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  }, TypeDictionary = {
    nan: "NaN",
    number: "slo",
    string: "etzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Neplatn vstup: oekvno instanceof ${issue2.expected}, obdreno ${received}`;
        return `Neplatn vstup: oekvno ${expected}, obdreno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn vstup: oekvno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk"}`;
        return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk"}`;
        return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
        return `Neplatn formt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${issue2.origin}`;
      default:
        return "Neplatn vstup";
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}
// node_modules/zod/v4/locales/da.js
var error7 = () => {
  let Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslt",
    date: "ISO-dato",
    time: "ISO-klokkeslt",
    duration: "ISO-varighed",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "st",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig vrdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin), origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin), origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${issue2.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}
// node_modules/zod/v4/locales/de.js
var error8 = () => {
  let Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  }, TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Ungltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        return `Ungltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${issue2.origin}`;
      default:
        return "Ungltige Eingabe";
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}
// node_modules/zod/v4/locales/en.js
var error9 = () => {
  let Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Invalid string: must start with "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}
// node_modules/zod/v4/locales/eo.js
var error10 = () => {
  let Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  }, TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Nevalida enigo: atendiis instanceof ${issue2.expected}, riceviis ${received}`;
        return `Nevalida enigo: atendiis ${expected}, riceviis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro malgranda: atendiis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Tro malgranda: atendiis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} losilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}
// node_modules/zod/v4/locales/es.js
var error11 = () => {
  let Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "entrada",
    email: "direccin de correo electrnico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duracin ISO",
    ipv4: "direccin IPv4",
    ipv6: "direccin IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  }, TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "nmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "nmero grande",
    symbol: "smbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funcin",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeracin",
    union: "unin",
    literal: "literal",
    promise: "promesa",
    void: "vaco",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Entrada invlida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        return `Entrada invlida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opcin invlida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin), origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin), origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invlida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
        return `Invlido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return "Entrada invlida";
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}
// node_modules/zod/v4/locales/fa.js
var error12 = () => {
  let Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ",
    date: " ",
    time: " ",
    duration: "  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` :  instanceof ${issue2.expected}  ${received}  `;
        return ` :  ${expected}  ${received}  `;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        return ` :    ${joinValues(issue2.values, "|")} `;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :   "${_issue.prefix}"  `;
        if (_issue.format === "ends_with")
          return ` :   "${_issue.suffix}"  `;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}" `;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}   `;
        return `${FormatDictionary[_issue.format] ?? issue2.format} `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return " ";
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}
// node_modules/zod/v4/locales/fi.js
var error13 = () => {
  let Sizable = {
    string: { unit: "merkki", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pivmrn" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "snnllinen lauseke",
    email: "shkpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pivmr",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        return `Liian suuri: arvon tytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        return `Liian pieni: arvon tytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syte";
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}
// node_modules/zod/v4/locales/fr.js
var error14 = () => {
  let Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "entre",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  }, TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Entre invalide : instanceof ${issue2.expected} attendu, ${received} reu`;
        return `Entre invalide : ${expected} attendu, ${received} reu`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit tre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Trop petit : ${issue2.origin} doit tre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}
// node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  let Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "entre",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Entre invalide : attendu instanceof ${issue2.expected}, reu ${received}`;
        return `Entre invalide : attendu ${expected}, reu ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? "" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return "Entre invalide";
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
// node_modules/zod/v4/locales/he.js
var error16 = () => {
  let TypeNames = {
    string: { label: "", gender: "f" },
    number: { label: "", gender: "m" },
    boolean: { label: " ", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "", gender: "m" },
    array: { label: "", gender: "m" },
    object: { label: "", gender: "m" },
    null: { label: "  (null)", gender: "m" },
    undefined: { label: "   (undefined)", gender: "m" },
    symbol: { label: " (Symbol)", gender: "m" },
    function: { label: "", gender: "f" },
    map: { label: " (Map)", gender: "f" },
    set: { label: " (Set)", gender: "f" },
    file: { label: "", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "  ", gender: "m" },
    value: { label: "", gender: "m" }
  }, Sizable = {
    string: { unit: "", shortLabel: "", longLabel: "" },
    file: { unit: "", shortLabel: "", longLabel: "" },
    array: { unit: "", shortLabel: "", longLabel: "" },
    set: { unit: "", shortLabel: "", longLabel: "" },
    number: { unit: "", shortLabel: "", longLabel: "" }
  }, typeEntry = (t) => t ? TypeNames[t] : void 0, typeLabel = (t) => {
    let e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  }, withDefinite = (t) => `${typeLabel(t)}`, verbFor = (t) => {
    return (typeEntry(t)?.gender ?? "m") === "f" ? " " : " ";
  }, getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  }, FormatDictionary = {
    regex: { label: "", gender: "m" },
    email: { label: " ", gender: "f" },
    url: { label: " ", gender: "f" },
    emoji: { label: "'", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "  ISO", gender: "m" },
    date: { label: " ISO", gender: "m" },
    time: { label: " ISO", gender: "m" },
    duration: { label: "  ISO", gender: "m" },
    ipv4: { label: " IPv4", gender: "f" },
    ipv6: { label: " IPv6", gender: "f" },
    cidrv4: { label: " IPv4", gender: "m" },
    cidrv6: { label: " IPv6", gender: "m" },
    base64: { label: "  64", gender: "f" },
    base64url: { label: "  64  ", gender: "f" },
    json_string: { label: " JSON", gender: "f" },
    e164: { label: " E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "", gender: "m" },
    includes: { label: "", gender: "m" },
    lowercase: { label: "", gender: "m" },
    starts_with: { label: "", gender: "m" },
    uppercase: { label: "", gender: "m" }
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expectedKey = issue2.expected, expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey), receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `  :   instanceof ${issue2.expected},  ${received}`;
        return `  :   ${expected},  ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1)
          return `  :    ${stringifyPrimitive(issue2.values[0])}`;
        let stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2)
          return `  :    ${stringified[0]}  ${stringified[1]}`;
        let lastValue = stringified[stringified.length - 1];
        return `  :    ${stringified.slice(0, -1).join(", ")}  ${lastValue}`;
      }
      case "too_big": {
        let sizing = getSizing(issue2.origin), subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string")
          return `${sizing?.longLabel ?? ""} : ${subject}   ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? " " : " "}`.trim();
        if (issue2.origin === "number") {
          let comparison = issue2.inclusive ? `   -${issue2.maximum}` : ` -${issue2.maximum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          let verb = issue2.origin === "set" ? "" : "", comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""}  ` : ` -${issue2.maximum} ${sizing?.unit ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        let adj = issue2.inclusive ? "<=" : "<", be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit)
          return `${sizing.longLabel} : ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `${sizing?.longLabel ?? ""} : ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let sizing = getSizing(issue2.origin), subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string")
          return `${sizing?.shortLabel ?? ""} : ${subject}   ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? " " : ""}`.trim();
        if (issue2.origin === "number") {
          let comparison = issue2.inclusive ? `   -${issue2.minimum}` : ` -${issue2.minimum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          let verb = issue2.origin === "set" ? "" : "";
          if (issue2.minimum === 1 && issue2.inclusive) {
            let singularPhrase = issue2.origin === "set" ? "  " : "  ";
            return ` : ${subject} ${verb}  ${singularPhrase}`;
          }
          let comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""}  ` : ` -${issue2.minimum} ${sizing?.unit ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        let adj = issue2.inclusive ? ">=" : ">", be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit)
          return `${sizing.shortLabel} : ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `${sizing?.shortLabel ?? ""} : ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `    ${_issue.pattern}`;
        let nounEntry = FormatDictionary[_issue.format], noun = nounEntry?.label ?? _issue.format, adjective = (nounEntry?.gender ?? "m") === "f" ? "" : "";
        return `${noun}  ${adjective}`;
      }
      case "not_multiple_of":
        return `  :     ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "   ";
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${withDefinite(issue2.origin ?? "array")}`;
      default:
        return "  ";
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}
// node_modules/zod/v4/locales/hu.js
var error17 = () => {
  let Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "bemenet",
    email: "email cm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idblyeg",
    date: "ISO dtum",
    time: "ISO id",
    duration: "ISO idintervallum",
    ipv4: "IPv4 cm",
    ipv6: "IPv6 cm",
    cidrv4: "IPv4 tartomny",
    cidrv6: "IPv6 tartomny",
    base64: "base64-kdolt string",
    base64url: "base64url-kdolt string",
    json_string: "JSON string",
    e164: "E.164 szm",
    jwt: "JWT",
    template_literal: "bemenet"
  }, TypeDictionary = {
    nan: "NaN",
    number: "szm",
    array: "tmb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `rvnytelen bemenet: a vrt rtk instanceof ${issue2.expected}, a kapott rtk ${received}`;
        return `rvnytelen bemenet: a vrt rtk ${expected}, a kapott rtk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue2.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tl nagy: ${issue2.origin ?? "rtk"} mrete tl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${issue2.origin ?? "rtk"} tl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tl kicsi: a bemeneti rtk ${issue2.origin} mrete tl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Tl kicsi: a bemeneti rtk ${issue2.origin} tl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
        if (_issue.format === "ends_with")
          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
        if (_issue.format === "includes")
          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${issue2.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${issue2.origin}`;
      default:
        return "rvnytelen bemenet";
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}
// node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  let vowels = ["", "", "", "", "", "", ""], lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "" : "");
}
var error18 = () => {
  let Sizable = {
    string: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: ". ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `    instanceof ${issue2.expected},   ${received}`;
        return `    ${expected},   ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `    ${stringifyPrimitive(issue2.values[1])}`;
        return `      ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing) {
          let maxValue = Number(issue2.maximum), unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `    ,  ${withDefiniteArticle(issue2.origin ?? "")}  ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `    ,  ${withDefiniteArticle(issue2.origin ?? "")}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing) {
          let minValue = Number(issue2.minimum), unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `    ,  ${withDefiniteArticle(issue2.origin)}  ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `    ,  ${withDefiniteArticle(issue2.origin)}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `     "${_issue.prefix}"-`;
        if (_issue.format === "ends_with")
          return `     "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return `     "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `     ${_issue.pattern} `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `      ${issue2.divisor}-`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `  ${withDefiniteArticle(issue2.origin)}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${withDefiniteArticle(issue2.origin)}-`;
      default:
        return " ";
    }
  };
};
function hy_default() {
  return {
    localeError: error18()
  };
}
// node_modules/zod/v4/locales/id.js
var error19 = () => {
  let Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function id_default() {
  return {
    localeError: error19()
  };
}
// node_modules/zod/v4/locales/is.js
var error20 = () => {
  let Sizable = {
    string: { unit: "stafi", verb: "a hafa" },
    file: { unit: "bti", verb: "a hafa" },
    array: { unit: "hluti", verb: "a hafa" },
    set: { unit: "hluti", verb: "a hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tmi",
    date: "ISO dagsetning",
    time: "ISO tmi",
    duration: "ISO tmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tlugildi",
    jwt: "JWT",
    template_literal: "gildi"
  }, TypeDictionary = {
    nan: "NaN",
    number: "nmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Rangt gildi:  slst inn ${received} ar sem  a vera instanceof ${issue2.expected}`;
        return `Rangt gildi:  slst inn ${received} ar sem  a vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} s ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of lti: gert er r fyrir a ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Of lti: gert er r fyrir a ${issue2.origin} s ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `gildur strengur: verur a byrja  "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `gildur strengur: verur a enda  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `gildur strengur: verur a innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${issue2.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function is_default() {
  return {
    localeError: error20()
  };
}
// node_modules/zod/v4/locales/it.js
var error21 = () => {
  let Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function it_default() {
  return {
    localeError: error21()
  };
}
// node_modules/zod/v4/locales/ja.js
var error22 = () => {
  let Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `: instanceof ${issue2.expected}${received}`;
        return `: ${expected}${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `: ${stringifyPrimitive(issue2.values[0])}`;
        return `: ${joinValues(issue2.values, "")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "" : "", sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${sizing.unit ?? ""}${adj}`;
        return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${adj}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? "" : "", sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin}${issue2.minimum.toString()}${sizing.unit}${adj}`;
        return `: ${issue2.origin}${issue2.minimum.toString()}${adj}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `: "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `: "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `: "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `: ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `: ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin}`;
      default:
        return "";
    }
  };
};
function ja_default() {
  return {
    localeError: error22()
  };
}
// node_modules/zod/v4/locales/ka.js
var error23 = () => {
  let Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "- ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "-",
    date: "",
    time: "",
    duration: "",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    string: "",
    boolean: "",
    function: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` :  instanceof ${issue2.expected},  ${received}`;
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  - ${joinValues(issue2.values, "|")}-`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return ` :  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return ` :  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :   "${_issue.prefix}"-`;
        if (_issue.format === "ends_with")
          return ` :   "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"-`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}- `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `  ${issue2.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${issue2.origin}-`;
      default:
        return " ";
    }
  };
};
function ka_default() {
  return {
    localeError: error23()
  };
}
// node_modules/zod/v4/locales/km.js
var error24 = () => {
  let Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: " base64",
    base64url: " base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: " (Array)",
    null: " (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `  instanceof ${issue2.expected}  ${received}`;
        return `  ${expected}  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  ${stringifyPrimitive(issue2.values[0])}`;
        return `  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `  "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `  ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return "";
    }
  };
};
function km_default() {
  return {
    localeError: error24()
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
// node_modules/zod/v4/locales/ko.js
var error25 = () => {
  let Sizable = {
    string: { unit: "", verb: "to have" },
    file: { unit: "", verb: "to have" },
    array: { unit: "", verb: "to have" },
    set: { unit: "", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` :   instanceof ${issue2.expected},   ${received}`;
        return ` :   ${expected},   ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, " ")}   `;
      case "too_big": {
        let adj = issue2.inclusive ? "" : "", suffix = adj === "" ? " " : " ", sizing = getSizing(issue2.origin), unit = sizing?.unit ?? "";
        if (sizing)
          return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? "" : "", suffix = adj === "" ? " " : " ", sizing = getSizing(issue2.origin), unit = sizing?.unit ?? "";
        if (sizing)
          return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"()  `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"()  `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"()  `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}   `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}  `;
      case "unrecognized_keys":
        return `   : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` : ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return ` : ${issue2.origin}`;
      default:
        return " ";
    }
  };
};
function ko_default() {
  return {
    localeError: error25()
  };
}
// node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number2) {
  let abs = Math.abs(number2), last = abs % 10, last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error26 = () => {
  let Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne ilgesn kaip",
          notInclusive: "turi bti trumpesn kaip"
        },
        bigger: {
          inclusive: "turi bti ne trumpesn kaip",
          notInclusive: "turi bti ilgesn kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne didesnis kaip",
          notInclusive: "turi bti maesnis kaip"
        },
        bigger: {
          inclusive: "turi bti ne maesnis kaip",
          notInclusive: "turi bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    let result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  let FormatDictionary = {
    regex: "vestis",
    email: "el. pato adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 ukoduota eilut",
    base64url: "base64url ukoduota eilut",
    json_string: "JSON eilut",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "vestis"
  }, TypeDictionary = {
    nan: "NaN",
    number: "skaiius",
    bigint: "sveikasis skaiius",
    string: "eilut",
    boolean: "login reikm",
    undefined: "neapibrta reikm",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin reikm"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Gautas tipas ${received}, o tiktasi - instanceof ${issue2.expected}`;
        return `Gautas tipas ${received}, o tiktasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo bti vienas i ${joinValues(issue2.values, "|")} pasirinkim`;
      case "too_big": {
        let origin = TypeDictionary[issue2.origin] ?? issue2.origin, sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? !1, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        let adj = issue2.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        let origin = TypeDictionary[issue2.origin] ?? issue2.origin, sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? !1, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element"}`;
        let adj = issue2.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Eilut privalo prasidti "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Eilut privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut privalo traukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        let origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error26()
  };
}
// node_modules/zod/v4/locales/mk.js
var error27 = () => {
  let Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "  -",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` :   instanceof ${issue2.expected},  ${received}`;
        return ` :   ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :     "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :      ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? " " : " "}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return " ";
    }
  };
};
function mk_default() {
  return {
    localeError: error27()
  };
}
// node_modules/zod/v4/locales/ms.js
var error28 = () => {
  let Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function ms_default() {
  return {
    localeError: error28()
  };
}
// node_modules/zod/v4/locales/nl.js
var error29 = () => {
  let Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  }, TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin), longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin), shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing)
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function nl_default() {
  return {
    localeError: error29()
  };
}
// node_modules/zod/v4/locales/no.js
var error30 = () => {
  let Sizable = {
    string: { unit: "tegn", verb: " ha" },
    file: { unit: "bytes", verb: " ha" },
    array: { unit: "elementer", verb: " inneholde" },
    set: { unit: "elementer", verb: " inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function no_default() {
  return {
    localeError: error30()
  };
}
// node_modules/zod/v4/locales/ota.js
var error31 = () => {
  let Sizable = {
    string: { unit: "harf", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "unsur", verb: "olmaldr" },
    set: { unit: "unsur", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "giren",
    email: "epostagh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengm",
    date: "ISO tarihi",
    time: "ISO zaman",
    duration: "ISO mddeti",
    ipv4: "IPv4 nin",
    ipv6: "IPv6 nin",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ifreli metin",
    base64url: "base64url-ifreli metin",
    json_string: "JSON metin",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "giren"
  }, TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Fsit giren: umulan instanceof ${issue2.expected}, alnan ${received}`;
        return `Fsit giren: umulan ${expected}, alnan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fsit tercih: mteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
        return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fsit metin: "${_issue.prefix}" ile balamal.`;
        if (_issue.format === "ends_with")
          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
        if (_issue.format === "regex")
          return `Fsit metin: ${_issue.pattern} nakna uymal.`;
        return `Fsit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${issue2.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${issue2.origin} iin tannmayan kymet var.`;
      default:
        return "Kymet tannamad.";
    }
  };
};
function ota_default() {
  return {
    localeError: error31()
  };
}
// node_modules/zod/v4/locales/ps.js
var error32 = () => {
  let Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "",
    url: "  ",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ",
    date: "",
    time: "",
    duration: "",
    ipv4: " IPv4 ",
    ipv6: " IPv6 ",
    cidrv4: " IPv4 ",
    cidrv6: " IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: " E.164 ",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` :  instanceof ${issue2.expected} ,  ${received}  `;
        return ` :  ${expected} ,  ${received}  `;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        return ` :    ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :   "${_issue.prefix}"   `;
        if (_issue.format === "ends_with")
          return ` :   "${_issue.suffix}"    `;
        if (_issue.format === "includes")
          return ` :  "${_issue.includes}" `;
        if (_issue.format === "regex")
          return ` :   ${_issue.pattern}   `;
        return `${FormatDictionary[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}  `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin} `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin} `;
      default:
        return " ";
    }
  };
};
function ps_default() {
  return {
    localeError: error32()
  };
}
// node_modules/zod/v4/locales/pl.js
var error33 = () => {
  let Sizable = {
    string: { unit: "znakw", verb: "mie" },
    file: { unit: "bajtw", verb: "mie" },
    array: { unit: "elementw", verb: "mie" },
    set: { unit: "elementw", verb: "mie" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "wyraenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "cig znakw zakodowany w formacie base64",
    base64url: "cig znakw zakodowany w formacie base64url",
    json_string: "cig znakw w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejcie"
  }, TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        return `Nieprawidowe dane wejciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Za dua warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementw"}`;
        return `Zbyt du(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Za maa warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementw"}`;
        return `Zbyt ma(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
        return `Nieprawidow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${issue2.origin}`;
      default:
        return "Nieprawidowe dane wejciowe";
    }
  };
};
function pl_default() {
  return {
    localeError: error33()
  };
}
// node_modules/zod/v4/locales/pt.js
var error34 = () => {
  let Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "padro",
    email: "endereo de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durao ISO",
    ipv4: "endereo IPv4",
    ipv6: "endereo IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  }, TypeDictionary = {
    nan: "NaN",
    number: "nmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Tipo invlido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        return `Tipo invlido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opo invlida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto invlido: deve comear com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invlido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invlido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${issue2.origin}`;
      default:
        return "Campo invlido";
    }
  };
};
function pt_default() {
  return {
    localeError: error34()
  };
}
// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  let absCount = Math.abs(count), lastDigit = absCount % 10, lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19)
    return many;
  if (lastDigit === 1)
    return one;
  if (lastDigit >= 2 && lastDigit <= 4)
    return few;
  return many;
}
var error35 = () => {
  let Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` :  instanceof ${issue2.expected},  ${received}`;
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing) {
          let maxValue = Number(issue2.maximum), unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing) {
          let minValue = Number(issue2.minimum), unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return "  ";
    }
  };
};
function ru_default() {
  return {
    localeError: error35()
  };
}
// node_modules/zod/v4/locales/sl.js
var error36 = () => {
  let Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "vnos",
    email: "e-potni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in as",
    date: "ISO datum",
    time: "ISO as",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  }, TypeDictionary = {
    nan: "NaN",
    number: "tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Neveljaven vnos: priakovano instanceof ${issue2.expected}, prejeto ${received}`;
        return `Neveljaven vnos: priakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Premajhno: priakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Premajhno: priakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error36()
  };
}
// node_modules/zod/v4/locales/sv.js
var error37 = () => {
  let Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehlla" },
    set: { unit: "objekt", verb: "att innehlla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "reguljrt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strng",
    base64url: "base64url-kodad strng",
    json_string: "JSON-strng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  }, TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Ogiltig inmatning: frvntat instanceof ${issue2.expected}, fick ${received}`;
        return `Ogiltig inmatning: frvntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: frvntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fr stor(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `Fr stor(t): frvntat ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${issue2.origin ?? "vrdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function sv_default() {
  return {
    localeError: error37()
  };
}
// node_modules/zod/v4/locales/ta.js
var error38 = () => {
  let Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO  ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` :  instanceof ${issue2.expected},  ${received}`;
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"   `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"   `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` : ${_issue.pattern}   `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return " ";
    }
  };
};
function ta_default() {
  return {
    localeError: error38()
  };
}
// node_modules/zod/v4/locales/th.js
var error39 = () => {
  let Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: " ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IP  IPv4",
    cidrv6: " IP  IPv6",
    base64: " Base64",
    base64url: " Base64  URL",
    json_string: " JSON",
    e164: " (E.164)",
    jwt: " JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: " (Array)",
    null: " (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `:  instanceof ${issue2.expected}  ${received}`;
        return `:  ${expected}  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `:  ${stringifyPrimitive(issue2.values[0])}`;
        return `:  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "" : "", sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? "" : "", sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `:  "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `:  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `:  "${_issue.includes}" `;
        if (_issue.format === "regex")
          return `:  ${_issue.pattern}`;
        return `: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `:  ${issue2.divisor} `;
      case "unrecognized_keys":
        return `: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return "";
    }
  };
};
function th_default() {
  return {
    localeError: error39()
  };
}
// node_modules/zod/v4/locales/tr.js
var error40 = () => {
  let Sizable = {
    string: { unit: "karakter", verb: "olmal" },
    file: { unit: "bayt", verb: "olmal" },
    array: { unit: "e", verb: "olmal" },
    set: { unit: "e", verb: "olmal" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral",
    cidrv6: "IPv6 aral",
    base64: "base64 ile ifrelenmi metin",
    base64url: "base64url ile ifrelenmi metin",
    json_string: "JSON dizesi",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "ablon dizesi"
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Geersiz deer: beklenen instanceof ${issue2.expected}, alnan ${received}`;
        return `Geersiz deer: beklenen ${expected}, alnan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geersiz deer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "e"}`;
        return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geersiz metin: "${_issue.prefix}" ile balamal`;
        if (_issue.format === "ends_with")
          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geersiz metin: "${_issue.includes}" iermeli`;
        if (_issue.format === "regex")
          return `Geersiz metin: ${_issue.pattern} desenine uymal`;
        return `Geersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${issue2.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${issue2.origin} iinde geersiz deer`;
      default:
        return "Geersiz deer";
    }
  };
};
function tr_default() {
  return {
    localeError: error40()
  };
}
// node_modules/zod/v4/locales/uk.js
var error41 = () => {
  let Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: " ",
    email: "  ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "   base64",
    base64url: "   base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: " "
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `  :  instanceof ${issue2.expected},  ${received}`;
        return `  :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ,  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ,  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return ` : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return "  ";
    }
  };
};
function uk_default() {
  return {
    localeError: error41()
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
// node_modules/zod/v4/locales/ur.js
var error42 = () => {
  let Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: " ",
    email: "  ",
    url: "  ",
    emoji: "",
    uuid: "   ",
    uuidv4: "     4",
    uuidv6: "     6",
    nanoid: "  ",
    guid: "   ",
    cuid: "   ",
    cuid2: "    2",
    ulid: "   ",
    xid: "  ",
    ksuid: "    ",
    datetime: "    ",
    date: "   ",
    time: "   ",
    duration: "   ",
    ipv4: "   4 ",
    ipv6: "   6 ",
    cidrv4: "   4 ",
    cidrv6: "   6 ",
    base64: " 64   ",
    base64url: " 64      ",
    json_string: "    ",
    e164: " 164 ",
    jwt: "  ",
    template_literal: " "
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `  : instanceof ${issue2.expected}   ${received}  `;
        return `  : ${expected}   ${received}  `;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  : ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, "|")}     `;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"    `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"    `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}    `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `   ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return "  ";
    }
  };
};
function ur_default() {
  return {
    localeError: error42()
  };
}
// node_modules/zod/v4/locales/uz.js
var error43 = () => {
  let Sizable = {
    string: { unit: "belgi", verb: "bolishi kerak" },
    file: { unit: "bayt", verb: "bolishi kerak" },
    array: { unit: "element", verb: "bolishi kerak" },
    set: { unit: "element", verb: "bolishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  }, TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `Notogri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        return `Notogri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Notogri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Notogri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Notogri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Notogri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Notogri satr: "${_issue.includes}" ni oz ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Notogri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Notogri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Notogri raqam: ${issue2.divisor} ning karralisi bolishi kerak`;
      case "unrecognized_keys":
        return `Nomalum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit notogri`;
      case "invalid_union":
        return "Notogri kirish";
      case "invalid_element":
        return `${issue2.origin} da notogri qiymat`;
      default:
        return "Notogri kirish";
    }
  };
};
function uz_default() {
  return {
    localeError: error43()
  };
}
// node_modules/zod/v4/locales/vi.js
var error44 = () => {
  let Sizable = {
    string: { unit: "k t", verb: "c" },
    file: { unit: "byte", verb: "c" },
    array: { unit: "phn t", verb: "c" },
    set: { unit: "phn t", verb: "c" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "u vo",
    email: "a ch email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngy gi ISO",
    date: "ngy ISO",
    time: "gi ISO",
    duration: "khong thi gian ISO",
    ipv4: "a ch IPv4",
    ipv6: "a ch IPv6",
    cidrv4: "di IPv4",
    cidrv6: "di IPv6",
    base64: "chui m ha base64",
    base64url: "chui m ha base64url",
    json_string: "chui JSON",
    e164: "s E.164",
    jwt: "JWT",
    template_literal: "u vo"
  }, TypeDictionary = {
    nan: "NaN",
    number: "s",
    array: "mng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `u vo khng hp l: mong i instanceof ${issue2.expected}, nhn c ${received}`;
        return `u vo khng hp l: mong i ${expected}, nhn c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `u vo khng hp l: mong i ${stringifyPrimitive(issue2.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phn t"}`;
        return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu nh: mong i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Qu nh: mong i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${issue2.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${issue2.origin}`;
      default:
        return "u vo khng hp l";
    }
  };
};
function vi_default() {
  return {
    localeError: error44()
  };
}
// node_modules/zod/v4/locales/zh-CN.js
var error45 = () => {
  let Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: "(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` instanceof ${issue2.expected} ${received}`;
        return ` ${expected} ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return ` ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` "${_issue.prefix}" `;
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} (value)`;
      default:
        return "";
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error45()
  };
}
// node_modules/zod/v4/locales/zh-TW.js
var error46 = () => {
  let Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64 ",
    base64url: "base64url ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  }, TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return ` instanceof ${issue2.expected} ${received}`;
        return ` ${expected} ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return ` "${_issue.prefix}" `;
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} `;
      default:
        return "";
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error46()
  };
}
// node_modules/zod/v4/locales/yo.js
var error47 = () => {
  let Sizable = {
    string: { unit: "mi", verb: "n" },
    file: { unit: "bytes", verb: "n" },
    array: { unit: "nkan", verb: "n" },
    set: { unit: "nkan", verb: "n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "r bwl",
    email: "drs ml",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "kk ISO",
    date: "j ISO",
    time: "kk ISO",
    duration: "kk t p ISO",
    ipv4: "drs IPv4",
    ipv6: "drs IPv6",
    cidrv4: "gbgb IPv4",
    cidrv6: "gbgb IPv6",
    base64: "r t a k n base64",
    base64url: "r base64url",
    json_string: "r JSON",
    e164: "nmb E.164",
    jwt: "JWT",
    template_literal: "r bwl"
  }, TypeDictionary = {
    nan: "NaN",
    number: "nmb",
    array: "akop"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected))
          return `bwl ae: a n lti fi instanceof ${issue2.expected}, m a r ${received}`;
        return `bwl ae: a n lti fi ${expected}, m a r ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `bwl ae: a n lti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `yn ae: yan kan lra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        if (sizing)
          return `T p j: a n lti j p ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T p j: a n lti j ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        if (sizing)
          return `Kr ju: a n lti j p ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `Kr ju: a n lti j ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        if (_issue.format === "starts_with")
          return `r ae: gbd br pl "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `r ae: gbd par pl "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `r ae: gbd n "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `r ae: gbd b pr mu ${_issue.pattern}`;
        return `Ae: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${issue2.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${issue2.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function yo_default() {
  return {
    localeError: error47()
  };
}
// node_modules/zod/v4/core/registries.js
var _a15, $output = Symbol("ZodOutput"), $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap, this._idmap = /* @__PURE__ */ new Map;
  }
  add(schema, ..._meta) {
    let meta = _meta[0];
    if (this._map.set(schema, meta), meta && typeof meta === "object" && "id" in meta)
      this._idmap.set(meta.id, schema);
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap, this._idmap = /* @__PURE__ */ new Map, this;
  }
  remove(schema) {
    let meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta)
      this._idmap.delete(meta.id);
    return this._map.delete(schema), this;
  }
  get(schema) {
    let p = schema._zod.parent;
    if (p) {
      let pm = { ...this.get(p) ?? {} };
      delete pm.id;
      let f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
(_a15 = globalThis).__zod_globalRegistry ?? (_a15.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;
// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: !0,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: !0,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: !0,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: !0,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: !0,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  return new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: !1,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  let hasRest = _paramsOrRest instanceof $ZodType;
  return new Class2({
    type: "tuple",
    items,
    rest: hasRest ? _paramsOrRest : null,
    ...normalizeParams(hasRest ? _params : _paramsOrRest)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  let entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  let norm = normalizeParams(_params);
  return norm.abort ?? (norm.abort = !0), new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
}
function _refine(Class2, fn, _params) {
  return new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
}
function _superRefine(fn) {
  let ch = _check((payload) => {
    return payload.addIssue = (issue2) => {
      if (typeof issue2 === "string")
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      else {
        let _issue = issue2;
        if (_issue.fatal)
          _issue.continue = !1;
        _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = ch), _issue.continue ?? (_issue.continue = !ch._zod.def.abort), payload.issues.push(issue(_issue));
      }
    }, fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  let ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  return ch._zod.check = fn, ch;
}
function describe(description) {
  let ch = new $ZodCheck({ check: "describe" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ], ch._zod.check = () => {}, ch;
}
function meta(metadata) {
  let ch = new $ZodCheck({ check: "meta" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ], ch._zod.check = () => {}, ch;
}
function _stringbool(Classes, _params) {
  let params = normalizeParams(_params), truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive")
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v), falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  let truthySet = new Set(truthyArray), falsySet = new Set(falsyArray), _Codec = Classes.Codec ?? $ZodCodec, _Boolean = Classes.Boolean ?? $ZodBoolean, stringSchema = new (Classes.String ?? $ZodString)({ type: "string", error: params.error }), booleanSchema = new _Boolean({ type: "boolean", error: params.error }), codec = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data))
        return !0;
      else if (falsySet.has(data))
        return !1;
      else
        return payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: !1
        }), {};
    },
    reverseTransform: (input, _payload) => {
      if (input === !0)
        return truthyArray[0] || "true";
      else
        return falsyArray[0] || "false";
    },
    error: params.error
  });
  return codec;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  let params = normalizeParams(_params), def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp)
    def.pattern = fnOrRegex;
  return new Class2(def);
}
// node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {}),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map,
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a16;
  let def = schema._zod.def, seen = ctx.seen.get(schema);
  if (seen) {
    if (seen.count++, _params.schemaPath.includes(schema))
      seen.cycle = _params.path;
    return seen.schema;
  }
  let result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  let overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema)
    result.schema = overrideSchema;
  else {
    let params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema)
      schema._zod.processJSONSchema(ctx, result.schema, params);
    else {
      let _json = result.schema, processor = ctx.processors[def.type];
      if (!processor)
        throw Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      processor(schema, ctx, _json, params);
    }
    let parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params), ctx.seen.get(parent).isParent = !0;
    }
  }
  let meta2 = ctx.metadataRegistry.get(schema);
  if (meta2)
    Object.assign(result.schema, meta2);
  if (ctx.io === "input" && isTransforming(schema))
    delete result.schema.examples, delete result.schema.default;
  if (ctx.io === "input" && result.schema._prefault)
    (_a16 = result.schema).default ?? (_a16.default = result.schema._prefault);
  return delete result.schema._prefault, ctx.seen.get(schema).schema;
}
function extractDefs(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw Error("Unprocessed schema. This is a bug in Zod.");
  let idToSchema = /* @__PURE__ */ new Map;
  for (let entry of ctx.seen.entries()) {
    let id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      let existing = idToSchema.get(id);
      if (existing && existing !== entry[0])
        throw Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      idToSchema.set(id, entry[0]);
    }
  }
  let makeURI = (entry) => {
    let defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      let externalId = ctx.external.registry.get(entry[0])?.id, uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId)
        return { ref: uriGenerator(externalId) };
      let id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      return entry[1].defId = id, { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root)
      return { ref: "#" };
    let defUriPrefix = `${"#"}/${defsSegment}/`, defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  }, extractToDef = (entry) => {
    if (entry[1].schema.$ref)
      return;
    let seen = entry[1], { ref, defId } = makeURI(entry);
    if (seen.def = { ...seen.schema }, defId)
      seen.defId = defId;
    let schema2 = seen.schema;
    for (let key in schema2)
      delete schema2[key];
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw")
    for (let entry of ctx.seen.entries()) {
      let seen = entry[1];
      if (seen.cycle)
        throw Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      let ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    if (ctx.metadataRegistry.get(entry[0])?.id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw Error("Unprocessed schema. This is a bug in Zod.");
  let flattenRef = (zodSchema) => {
    let seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    let schema2 = seen.def ?? seen.schema, _cached = { ...schema2 }, ref = seen.ref;
    if (seen.ref = null, ref) {
      flattenRef(ref);
      let refSeen = ctx.seen.get(ref), refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0"))
        schema2.allOf = schema2.allOf ?? [], schema2.allOf.push(refSchema);
      else
        Object.assign(schema2, refSchema);
      if (Object.assign(schema2, _cached), zodSchema._zod.parent === ref)
        for (let key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached))
            delete schema2[key];
        }
      if (refSchema.$ref && refSeen.def)
        for (let key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key]))
            delete schema2[key];
        }
    }
    let parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      let parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        if (schema2.$ref = parentSeen.schema.$ref, parentSeen.def)
          for (let key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key]))
              delete schema2[key];
          }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (let entry of [...ctx.seen.entries()].reverse())
    flattenRef(entry[0]);
  let result = {};
  if (ctx.target === "draft-2020-12")
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  else if (ctx.target === "draft-07")
    result.$schema = "http://json-schema.org/draft-07/schema#";
  else if (ctx.target === "draft-04")
    result.$schema = "http://json-schema.org/draft-04/schema#";
  else if (ctx.target === "openapi-3.0")
    ;
  if (ctx.external?.uri) {
    let id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  let defs = ctx.external?.defs ?? {};
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    if (seen.def && seen.defId)
      defs[seen.defId] = seen.def;
  }
  if (ctx.external)
    ;
  else if (Object.keys(defs).length > 0)
    if (ctx.target === "draft-2020-12")
      result.$defs = defs;
    else
      result.definitions = defs;
  try {
    let finalized = JSON.parse(JSON.stringify(result));
    return Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), finalized;
  } catch (_err) {
    throw Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  let ctx = _ctx ?? { seen: /* @__PURE__ */ new Set };
  if (ctx.seen.has(_schema))
    return !1;
  ctx.seen.add(_schema);
  let def = _schema._zod.def;
  if (def.type === "transform")
    return !0;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault")
    return isTransforming(def.innerType, ctx);
  if (def.type === "intersection")
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  if (def.type === "record" || def.type === "map")
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  if (def.type === "pipe")
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  if (def.type === "object") {
    for (let key in def.shape)
      if (isTransforming(def.shape[key], ctx))
        return !0;
    return !1;
  }
  if (def.type === "union") {
    for (let option of def.options)
      if (isTransforming(option, ctx))
        return !0;
    return !1;
  }
  if (def.type === "tuple") {
    for (let item of def.items)
      if (isTransforming(item, ctx))
        return !0;
    if (def.rest && isTransforming(def.rest, ctx))
      return !0;
    return !1;
  }
  return !1;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  let ctx = initializeContext({ ...params, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
}, createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  let { libraryOptions, target } = params ?? {}, ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
};
// node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
}, stringProcessor = (schema, ctx, _json, _params) => {
  let json = _json;
  json.type = "string";
  let { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minLength = minimum;
  if (typeof maximum === "number")
    json.maxLength = maximum;
  if (format) {
    if (json.format = formatMap[format] ?? format, json.format === "")
      delete json.format;
    if (format === "time")
      delete json.format;
  }
  if (contentEncoding)
    json.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    let regexes = [...patterns];
    if (regexes.length === 1)
      json.pattern = regexes[0].source;
    else if (regexes.length > 1)
      json.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
  }
}, numberProcessor = (schema, ctx, _json, _params) => {
  let json = _json, { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json.type = "integer";
  else
    json.type = "number";
  if (typeof exclusiveMinimum === "number")
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0")
      json.minimum = exclusiveMinimum, json.exclusiveMinimum = !0;
    else
      json.exclusiveMinimum = exclusiveMinimum;
  if (typeof minimum === "number") {
    if (json.minimum = minimum, typeof exclusiveMinimum === "number" && ctx.target !== "draft-04")
      if (exclusiveMinimum >= minimum)
        delete json.minimum;
      else
        delete json.exclusiveMinimum;
  }
  if (typeof exclusiveMaximum === "number")
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0")
      json.maximum = exclusiveMaximum, json.exclusiveMaximum = !0;
    else
      json.exclusiveMaximum = exclusiveMaximum;
  if (typeof maximum === "number") {
    if (json.maximum = maximum, typeof exclusiveMaximum === "number" && ctx.target !== "draft-04")
      if (exclusiveMaximum <= maximum)
        delete json.maximum;
      else
        delete json.exclusiveMaximum;
  }
  if (typeof multipleOf === "number")
    json.multipleOf = multipleOf;
}, booleanProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
}, bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("BigInt cannot be represented in JSON Schema");
}, symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("Symbols cannot be represented in JSON Schema");
}, nullProcessor = (_schema, ctx, json, _params) => {
  if (ctx.target === "openapi-3.0")
    json.type = "string", json.nullable = !0, json.enum = [null];
  else
    json.type = "null";
}, undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("Undefined cannot be represented in JSON Schema");
}, voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("Void cannot be represented in JSON Schema");
}, neverProcessor = (_schema, _ctx, json, _params) => {
  json.not = {};
}, anyProcessor = (_schema, _ctx, _json, _params) => {}, unknownProcessor = (_schema, _ctx, _json, _params) => {}, dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("Date cannot be represented in JSON Schema");
}, enumProcessor = (schema, _ctx, json, _params) => {
  let def = schema._zod.def, values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json.type = "number";
  if (values.every((v) => typeof v === "string"))
    json.type = "string";
  json.enum = values;
}, literalProcessor = (schema, ctx, json, _params) => {
  let def = schema._zod.def, vals = [];
  for (let val of def.values)
    if (val === void 0) {
      if (ctx.unrepresentable === "throw")
        throw Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof val === "bigint")
      if (ctx.unrepresentable === "throw")
        throw Error("BigInt literals cannot be represented in JSON Schema");
      else
        vals.push(Number(val));
    else
      vals.push(val);
  if (vals.length === 0)
    ;
  else if (vals.length === 1) {
    let val = vals[0];
    if (json.type = val === null ? "null" : typeof val, ctx.target === "draft-04" || ctx.target === "openapi-3.0")
      json.enum = [val];
    else
      json.const = val;
  } else {
    if (vals.every((v) => typeof v === "number"))
      json.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json.type = "boolean";
    if (vals.every((v) => v === null))
      json.type = "null";
    json.enum = vals;
  }
}, nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("NaN cannot be represented in JSON Schema");
}, templateLiteralProcessor = (schema, _ctx, json, _params) => {
  let _json = json, pattern = schema._zod.pattern;
  if (!pattern)
    throw Error("Pattern not found in template literal");
  _json.type = "string", _json.pattern = pattern.source;
}, fileProcessor = (schema, _ctx, json, _params) => {
  let _json = json, file = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== void 0)
    file.minLength = minimum;
  if (maximum !== void 0)
    file.maxLength = maximum;
  if (mime)
    if (mime.length === 1)
      file.contentMediaType = mime[0], Object.assign(_json, file);
    else
      Object.assign(_json, file), _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
  else
    Object.assign(_json, file);
}, successProcessor = (_schema, _ctx, json, _params) => {
  json.type = "boolean";
}, customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("Custom types cannot be represented in JSON Schema");
}, functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("Function types cannot be represented in JSON Schema");
}, transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("Transforms cannot be represented in JSON Schema");
}, mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("Map cannot be represented in JSON Schema");
}, setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw Error("Set cannot be represented in JSON Schema");
}, arrayProcessor = (schema, ctx, _json, params) => {
  let json = _json, def = schema._zod.def, { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
  json.type = "array", json.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
}, objectProcessor = (schema, ctx, _json, params) => {
  let json = _json, def = schema._zod.def;
  json.type = "object", json.properties = {};
  let shape = def.shape;
  for (let key in shape)
    json.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  let allKeys = new Set(Object.keys(shape)), requiredKeys = new Set([...allKeys].filter((key) => {
    let v = def.shape[key]._zod;
    if (ctx.io === "input")
      return v.optin === void 0;
    else
      return v.optout === void 0;
  }));
  if (requiredKeys.size > 0)
    json.required = Array.from(requiredKeys);
  if (def.catchall?._zod.def.type === "never")
    json.additionalProperties = !1;
  else if (!def.catchall) {
    if (ctx.io === "output")
      json.additionalProperties = !1;
  } else if (def.catchall)
    json.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
}, unionProcessor = (schema, ctx, json, params) => {
  let def = schema._zod.def, isExclusive = def.inclusive === !1, options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive)
    json.oneOf = options;
  else
    json.anyOf = options;
}, intersectionProcessor = (schema, ctx, json, params) => {
  let def = schema._zod.def, a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  }), b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  }), isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1, allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json.allOf = allOf;
}, tupleProcessor = (schema, ctx, _json, params) => {
  let json = _json, def = schema._zod.def;
  json.type = "array";
  let prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items", restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems", prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  })), rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    if (json.prefixItems = prefixItems, rest)
      json.items = rest;
  } else if (ctx.target === "openapi-3.0") {
    if (json.items = {
      anyOf: prefixItems
    }, rest)
      json.items.anyOf.push(rest);
    if (json.minItems = prefixItems.length, !rest)
      json.maxItems = prefixItems.length;
  } else if (json.items = prefixItems, rest)
    json.additionalItems = rest;
  let { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json.minItems = minimum;
  if (typeof maximum === "number")
    json.maxItems = maximum;
}, recordProcessor = (schema, ctx, _json, params) => {
  let json = _json, def = schema._zod.def;
  json.type = "object";
  let keyType = def.keyType, patterns = keyType._zod.bag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    let valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json.patternProperties = {};
    for (let pattern of patterns)
      json.patternProperties[pattern.source] = valueSchema;
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12")
      json.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    json.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  let keyValues = keyType._zod.values;
  if (keyValues) {
    let validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0)
      json.required = validKeyValues;
  }
}, nullableProcessor = (schema, ctx, json, params) => {
  let def = schema._zod.def, inner = process2(def.innerType, ctx, params), seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0")
    seen.ref = def.innerType, json.nullable = !0;
  else
    json.anyOf = [inner, { type: "null" }];
}, nonoptionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, defaultProcessor = (schema, ctx, json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json.default = JSON.parse(JSON.stringify(def.defaultValue));
}, prefaultProcessor = (schema, ctx, json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  if (seen.ref = def.innerType, ctx.io === "input")
    json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
}, catchProcessor = (schema, ctx, json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw Error("Dynamic catch values are not supported in JSON Schema");
  }
  json.default = catchValue;
}, pipeProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def, innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, readonlyProcessor = (schema, ctx, json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json.readOnly = !0;
}, promiseProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, optionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, lazyProcessor = (schema, ctx, _json, params) => {
  let innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    let registry2 = input, ctx2 = initializeContext({ ...params, processors: allProcessors }), defs = {};
    for (let entry of registry2._idmap.entries()) {
      let [_, schema] = entry;
      process2(schema, ctx2);
    }
    let schemas = {}, external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (let entry of registry2._idmap.entries()) {
      let [key, schema] = entry;
      extractDefs(ctx2, schema), schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      let defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  let ctx = initializeContext({ ...params, processors: allProcessors });
  return process2(input, ctx), extractDefs(ctx, input), finalize(ctx, input);
}
// node_modules/zod/v4/core/json-schema-generator.js
class JSONSchemaGenerator {
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  get target() {
    return this.ctx.target;
  }
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  get override() {
    return this.ctx.override;
  }
  get io() {
    return this.ctx.io;
  }
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    let result = finalize(this.ctx, schema), { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
}
// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// node_modules/zod/v4/classic/schemas.js
var exports_schemas2 = {};
__export(exports_schemas2, {
  xor: () => xor,
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  url: () => url,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  transform: () => transform,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol15,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  set: () => set,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  promise: () => promise,
  preprocess: () => preprocess,
  prefault: () => prefault,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  nonoptional: () => nonoptional,
  never: () => never,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  meta: () => meta2,
  map: () => map,
  mac: () => mac2,
  looseRecord: () => looseRecord,
  looseObject: () => looseObject,
  literal: () => literal,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  function: () => _function,
  float64: () => float64,
  float32: () => float32,
  file: () => file,
  exactOptional: () => exactOptional,
  enum: () => _enum2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  describe: () => describe2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  codec: () => codec,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXor: () => ZodXor,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodMAC: () => ZodMAC,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIntersection: () => ZodIntersection,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFile: () => ZodFile,
  ZodExactOptional: () => ZodExactOptional,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny
});

// node_modules/zod/v4/classic/checks.js
var exports_checks2 = {};
__export(exports_checks2, {
  uppercase: () => _uppercase,
  trim: () => _trim,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  startsWith: () => _startsWith,
  slugify: () => _slugify,
  size: () => _size,
  regex: () => _regex,
  property: () => _property,
  positive: () => _positive,
  overwrite: () => _overwrite,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonnegative: () => _nonnegative,
  negative: () => _negative,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  length: () => _length,
  includes: () => _includes,
  gte: () => _gte,
  gt: () => _gt,
  endsWith: () => _endsWith
});

// node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def), ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def), ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues), inst.name = "ZodError", Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
}, ZodError = $constructor("ZodError", initializer2), ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse3 = /* @__PURE__ */ _parse(ZodRealError), parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError), safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError), safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError), encode2 = /* @__PURE__ */ _encode(ZodRealError), decode2 = /* @__PURE__ */ _decode(ZodRealError), encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError), decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError), safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError), safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError), safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError), safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  return $ZodType.init(inst, def), Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  }), inst.toJSONSchema = createToJSONSchemaMethod(inst, {}), inst.def = def, inst.type = def.type, Object.defineProperty(inst, "_def", { value: def }), inst.check = (...checks2) => {
    return inst.clone(exports_util.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: !0
    });
  }, inst.with = inst.check, inst.clone = (def2, params) => clone(inst, def2, params), inst.brand = () => inst, inst.register = (reg, meta2) => {
    return reg.add(inst, meta2), inst;
  }, inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse }), inst.safeParse = (data, params) => safeParse2(inst, data, params), inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync }), inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params), inst.spa = inst.safeParseAsync, inst.encode = (data, params) => encode2(inst, data, params), inst.decode = (data, params) => decode2(inst, data, params), inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params), inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params), inst.safeEncode = (data, params) => safeEncode2(inst, data, params), inst.safeDecode = (data, params) => safeDecode2(inst, data, params), inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params), inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params), inst.refine = (check, params) => inst.check(refine(check, params)), inst.superRefine = (refinement) => inst.check(superRefine(refinement)), inst.overwrite = (fn) => inst.check(_overwrite(fn)), inst.optional = () => optional(inst), inst.exactOptional = () => exactOptional(inst), inst.nullable = () => nullable(inst), inst.nullish = () => optional(nullable(inst)), inst.nonoptional = (params) => nonoptional(inst, params), inst.array = () => array(inst), inst.or = (arg) => union([inst, arg]), inst.and = (arg) => intersection(inst, arg), inst.transform = (tx) => pipe(inst, transform(tx)), inst.default = (def2) => _default2(inst, def2), inst.prefault = (def2) => prefault(inst, def2), inst.catch = (params) => _catch2(inst, params), inst.pipe = (target) => pipe(inst, target), inst.readonly = () => readonly(inst), inst.describe = (description) => {
    let cl = inst.clone();
    return globalRegistry.add(cl, { description }), cl;
  }, Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: !0
  }), inst.meta = (...args) => {
    if (args.length === 0)
      return globalRegistry.get(inst);
    let cl = inst.clone();
    return globalRegistry.add(cl, args[0]), cl;
  }, inst.isOptional = () => inst.safeParse(void 0).success, inst.isNullable = () => inst.safeParse(null).success, inst.apply = (fn) => fn(inst), inst;
}), _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => stringProcessor(inst, ctx, json, params);
  let bag = inst._zod.bag;
  inst.format = bag.format ?? null, inst.minLength = bag.minimum ?? null, inst.maxLength = bag.maximum ?? null, inst.regex = (...args) => inst.check(_regex(...args)), inst.includes = (...args) => inst.check(_includes(...args)), inst.startsWith = (...args) => inst.check(_startsWith(...args)), inst.endsWith = (...args) => inst.check(_endsWith(...args)), inst.min = (...args) => inst.check(_minLength(...args)), inst.max = (...args) => inst.check(_maxLength(...args)), inst.length = (...args) => inst.check(_length(...args)), inst.nonempty = (...args) => inst.check(_minLength(1, ...args)), inst.lowercase = (params) => inst.check(_lowercase(params)), inst.uppercase = (params) => inst.check(_uppercase(params)), inst.trim = () => inst.check(_trim()), inst.normalize = (...args) => inst.check(_normalize(...args)), inst.toLowerCase = () => inst.check(_toLowerCase()), inst.toUpperCase = () => inst.check(_toUpperCase()), inst.slugify = () => inst.check(_slugify());
}), ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def), _ZodString.init(inst, def), inst.email = (params) => inst.check(_email(ZodEmail, params)), inst.url = (params) => inst.check(_url(ZodURL, params)), inst.jwt = (params) => inst.check(_jwt(ZodJWT, params)), inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.uuid = (params) => inst.check(_uuid(ZodUUID, params)), inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params)), inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params)), inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params)), inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.cuid = (params) => inst.check(_cuid(ZodCUID, params)), inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params)), inst.ulid = (params) => inst.check(_ulid(ZodULID, params)), inst.base64 = (params) => inst.check(_base64(ZodBase64, params)), inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params)), inst.xid = (params) => inst.check(_xid(ZodXID, params)), inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params)), inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params)), inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params)), inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params)), inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params)), inst.e164 = (params) => inst.check(_e164(ZodE164, params)), inst.datetime = (params) => inst.check(datetime2(params)), inst.date = (params) => inst.check(date2(params)), inst.time = (params) => inst.check(time2(params)), inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), _ZodString.init(inst, def);
}), ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def), ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def), ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: exports_regexes.domain,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def), ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def), ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def), ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def), ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def), ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def), ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def), ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def), ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def), ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);
}
function hash(alg, params) {
  let enc = params?.enc ?? "hex", format = `${alg}_${enc}`, regex = exports_regexes[format];
  if (!regex)
    throw Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => numberProcessor(inst, ctx, json, params), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.int = (params) => inst.check(int(params)), inst.safe = (params) => inst.check(int(params)), inst.positive = (params) => inst.check(_gt(0, params)), inst.nonnegative = (params) => inst.check(_gte(0, params)), inst.negative = (params) => inst.check(_lt(0, params)), inst.nonpositive = (params) => inst.check(_lte(0, params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params)), inst.step = (value, params) => inst.check(_multipleOf(value, params)), inst.finite = () => inst;
  let bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5), inst.isFinite = !0, inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def), ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => booleanProcessor(inst, ctx, json, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => bigintProcessor(inst, ctx, json, params), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.positive = (params) => inst.check(_gt(BigInt(0), params)), inst.negative = (params) => inst.check(_lt(BigInt(0), params)), inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params)), inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  let bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null, inst.maxValue = bag.maximum ?? null, inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def), ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => symbolProcessor(inst, ctx, json, params);
});
function symbol15(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => undefinedProcessor(inst, ctx, json, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => nullProcessor(inst, ctx, json, params);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => anyProcessor(inst, ctx, json, params);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => unknownProcessor(inst, ctx, json, params);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => neverProcessor(inst, ctx, json, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => voidProcessor(inst, ctx, json, params);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => dateProcessor(inst, ctx, json, params), inst.min = (value, params) => inst.check(_gte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params));
  let c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null, inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => arrayProcessor(inst, ctx, json, params), inst.element = def.element, inst.min = (minLength, params) => inst.check(_minLength(minLength, params)), inst.nonempty = (params) => inst.check(_minLength(1, params)), inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params)), inst.length = (len, params) => inst.check(_length(len, params)), inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  let shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => objectProcessor(inst, ctx, json, params), exports_util.defineLazy(inst, "shape", () => {
    return def.shape;
  }), inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape)), inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall }), inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() }), inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 }), inst.extend = (incoming) => {
    return exports_util.extend(inst, incoming);
  }, inst.safeExtend = (incoming) => {
    return exports_util.safeExtend(inst, incoming);
  }, inst.merge = (other) => exports_util.merge(inst, other), inst.pick = (mask) => exports_util.pick(inst, mask), inst.omit = (mask) => exports_util.omit(inst, mask), inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]), inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  let def = {
    type: "object",
    shape: shape ?? {},
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params), inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def), $ZodXor.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => unionProcessor(inst, ctx, json, params), inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: !1,
    ...exports_util.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def), $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => intersectionProcessor(inst, ctx, json, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => tupleProcessor(inst, ctx, json, params), inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  let hasRest = _paramsOrRest instanceof $ZodType, params = hasRest ? _params : _paramsOrRest;
  return new ZodTuple({
    type: "tuple",
    items,
    rest: hasRest ? _paramsOrRest : null,
    ...exports_util.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => recordProcessor(inst, ctx, json, params), inst.keyType = def.keyType, inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  let k = clone(keyType);
  return k._zod.values = void 0, new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...exports_util.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => mapProcessor(inst, ctx, json, params), inst.keyType = def.keyType, inst.valueType = def.valueType, inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => setProcessor(inst, ctx, json, params), inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => enumProcessor(inst, ctx, json, params), inst.enum = def.entries, inst.options = Object.values(def.entries);
  let keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    let newEntries = {};
    for (let value of values)
      if (keys.has(value))
        newEntries[value] = def.entries[value];
      else
        throw Error(`Key ${value} not found in enum`);
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  }, inst.exclude = (values, params) => {
    let newEntries = { ...def.entries };
    for (let value of values)
      if (keys.has(value))
        delete newEntries[value];
      else
        throw Error(`Key ${value} not found in enum`);
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  let entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => literalProcessor(inst, ctx, json, params), inst.values = new Set(def.values), Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1)
        throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => fileProcessor(inst, ctx, json, params), inst.min = (size, params) => inst.check(_minSize(size, params)), inst.max = (size, params) => inst.check(_maxSize(size, params)), inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => transformProcessor(inst, ctx, json, params), inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string")
        payload.issues.push(exports_util.issue(issue2, payload.value, def));
      else {
        let _issue = issue2;
        if (_issue.fatal)
          _issue.continue = !1;
        _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = inst), payload.issues.push(exports_util.issue(_issue));
      }
    };
    let output = def.transform(payload.value, payload);
    if (output instanceof Promise)
      return output.then((output2) => {
        return payload.value = output2, payload;
      });
    return payload.value = output, payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => optionalProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => nullableProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => defaultProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => prefaultProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => nonoptionalProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => successProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => catchProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => nanProcessor(inst, ctx, json, params);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => pipeProcessor(inst, ctx, json, params), inst.in = def.in, inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def), $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => readonlyProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => templateLiteralProcessor(inst, ctx, json, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => lazyProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => promiseProcessor(inst, ctx, json, params), inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => functionProcessor(inst, ctx, json, params);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def), ZodType.init(inst, def), inst._zod.processJSONSchema = (ctx, json, params) => customProcessor(inst, ctx, json, params);
});
function check(fn) {
  let ch = new $ZodCheck({
    check: "custom"
  });
  return ch._zod.check = fn, ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => !0), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe, meta2 = meta;
function _instanceof(cls, params = {}) {
  let inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: !0,
    ...exports_util.normalizeParams(params)
  });
  return inst._zod.bag.Class = cls, inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls))
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
  }, inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  let jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...exports_schemas2,
  ...exports_checks2,
  iso: exports_iso
}, RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  "type",
  "enum",
  "const",
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  "minLength",
  "maxLength",
  "pattern",
  "format",
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  "description",
  "default",
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  let $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema")
    return "draft-2020-12";
  if ($schema === "http://json-schema.org/draft-07/schema#")
    return "draft-7";
  if ($schema === "http://json-schema.org/draft-04/schema#")
    return "draft-4";
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#"))
    throw Error("External $ref is not supported, only local refs (#/...) are allowed");
  let path = ref.slice(1).split("/").filter(Boolean);
  if (path.length === 0)
    return ctx.rootSchema;
  let defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    let key = path[1];
    if (!key || !ctx.defs[key])
      throw Error(`Reference not found: ${ref}`);
    return ctx.defs[key];
  }
  throw Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0)
      return z.never();
    throw Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0)
    throw Error("unevaluatedItems is not supported");
  if (schema.unevaluatedProperties !== void 0)
    throw Error("unevaluatedProperties is not supported");
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0)
    throw Error("Conditional schemas (if/then/else) are not supported");
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0)
    throw Error("dependentSchemas and dependentRequired are not supported");
  if (schema.$ref) {
    let refPath = schema.$ref;
    if (ctx.refs.has(refPath))
      return ctx.refs.get(refPath);
    if (ctx.processing.has(refPath))
      return z.lazy(() => {
        if (!ctx.refs.has(refPath))
          throw Error(`Circular reference not resolved: ${refPath}`);
        return ctx.refs.get(refPath);
      });
    ctx.processing.add(refPath);
    let resolved = resolveRef(refPath, ctx), zodSchema2 = convertSchema(resolved, ctx);
    return ctx.refs.set(refPath, zodSchema2), ctx.processing.delete(refPath), zodSchema2;
  }
  if (schema.enum !== void 0) {
    let enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === !0 && enumValues.length === 1 && enumValues[0] === null)
      return z.null();
    if (enumValues.length === 0)
      return z.never();
    if (enumValues.length === 1)
      return z.literal(enumValues[0]);
    if (enumValues.every((v) => typeof v === "string"))
      return z.enum(enumValues);
    let literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2)
      return literalSchemas[0];
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0)
    return z.literal(schema.const);
  let type = schema.type;
  if (Array.isArray(type)) {
    let typeSchemas = type.map((t) => {
      let typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0)
      return z.never();
    if (typeSchemas.length === 1)
      return typeSchemas[0];
    return z.union(typeSchemas);
  }
  if (!type)
    return z.any();
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        let format = schema.format;
        if (format === "email")
          stringSchema = stringSchema.check(z.email());
        else if (format === "uri" || format === "uri-reference")
          stringSchema = stringSchema.check(z.url());
        else if (format === "uuid" || format === "guid")
          stringSchema = stringSchema.check(z.uuid());
        else if (format === "date-time")
          stringSchema = stringSchema.check(z.iso.datetime());
        else if (format === "date")
          stringSchema = stringSchema.check(z.iso.date());
        else if (format === "time")
          stringSchema = stringSchema.check(z.iso.time());
        else if (format === "duration")
          stringSchema = stringSchema.check(z.iso.duration());
        else if (format === "ipv4")
          stringSchema = stringSchema.check(z.ipv4());
        else if (format === "ipv6")
          stringSchema = stringSchema.check(z.ipv6());
        else if (format === "mac")
          stringSchema = stringSchema.check(z.mac());
        else if (format === "cidr")
          stringSchema = stringSchema.check(z.cidrv4());
        else if (format === "cidr-v6")
          stringSchema = stringSchema.check(z.cidrv6());
        else if (format === "base64")
          stringSchema = stringSchema.check(z.base64());
        else if (format === "base64url")
          stringSchema = stringSchema.check(z.base64url());
        else if (format === "e164")
          stringSchema = stringSchema.check(z.e164());
        else if (format === "jwt")
          stringSchema = stringSchema.check(z.jwt());
        else if (format === "emoji")
          stringSchema = stringSchema.check(z.emoji());
        else if (format === "nanoid")
          stringSchema = stringSchema.check(z.nanoid());
        else if (format === "cuid")
          stringSchema = stringSchema.check(z.cuid());
        else if (format === "cuid2")
          stringSchema = stringSchema.check(z.cuid2());
        else if (format === "ulid")
          stringSchema = stringSchema.check(z.ulid());
        else if (format === "xid")
          stringSchema = stringSchema.check(z.xid());
        else if (format === "ksuid")
          stringSchema = stringSchema.check(z.ksuid());
      }
      if (typeof schema.minLength === "number")
        stringSchema = stringSchema.min(schema.minLength);
      if (typeof schema.maxLength === "number")
        stringSchema = stringSchema.max(schema.maxLength);
      if (schema.pattern)
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number")
        numberSchema = numberSchema.min(schema.minimum);
      if (typeof schema.maximum === "number")
        numberSchema = numberSchema.max(schema.maximum);
      if (typeof schema.exclusiveMinimum === "number")
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      else if (schema.exclusiveMinimum === !0 && typeof schema.minimum === "number")
        numberSchema = numberSchema.gt(schema.minimum);
      if (typeof schema.exclusiveMaximum === "number")
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      else if (schema.exclusiveMaximum === !0 && typeof schema.maximum === "number")
        numberSchema = numberSchema.lt(schema.maximum);
      if (typeof schema.multipleOf === "number")
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      let shape = {}, properties = schema.properties || {}, requiredSet = new Set(schema.required || []);
      for (let [key, propSchema] of Object.entries(properties)) {
        let propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        let keySchema = convertSchema(schema.propertyNames, ctx), valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        let objectSchema2 = z.object(shape).passthrough(), recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        let patternProps = schema.patternProperties, patternKeys = Object.keys(patternProps), looseRecords = [];
        for (let pattern of patternKeys) {
          let patternValue = convertSchema(patternProps[pattern], ctx), keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        let schemasToIntersect = [];
        if (Object.keys(shape).length > 0)
          schemasToIntersect.push(z.object(shape).passthrough());
        if (schemasToIntersect.push(...looseRecords), schemasToIntersect.length === 0)
          zodSchema = z.object({}).passthrough();
        else if (schemasToIntersect.length === 1)
          zodSchema = schemasToIntersect[0];
        else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2;i < schemasToIntersect.length; i++)
            result = z.intersection(result, schemasToIntersect[i]);
          zodSchema = result;
        }
        break;
      }
      let objectSchema = z.object(shape);
      if (schema.additionalProperties === !1)
        zodSchema = objectSchema.strict();
      else if (typeof schema.additionalProperties === "object")
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      else
        zodSchema = objectSchema.passthrough();
      break;
    }
    case "array": {
      let { prefixItems, items } = schema;
      if (prefixItems && Array.isArray(prefixItems)) {
        let tupleItems = prefixItems.map((item) => convertSchema(item, ctx)), rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest)
          zodSchema = z.tuple(tupleItems).rest(rest);
        else
          zodSchema = z.tuple(tupleItems);
        if (typeof schema.minItems === "number")
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        if (typeof schema.maxItems === "number")
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
      } else if (Array.isArray(items)) {
        let tupleItems = items.map((item) => convertSchema(item, ctx)), rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest)
          zodSchema = z.tuple(tupleItems).rest(rest);
        else
          zodSchema = z.tuple(tupleItems);
        if (typeof schema.minItems === "number")
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        if (typeof schema.maxItems === "number")
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
      } else if (items !== void 0) {
        let element = convertSchema(items, ctx), arraySchema = z.array(element);
        if (typeof schema.minItems === "number")
          arraySchema = arraySchema.min(schema.minItems);
        if (typeof schema.maxItems === "number")
          arraySchema = arraySchema.max(schema.maxItems);
        zodSchema = arraySchema;
      } else
        zodSchema = z.array(z.any());
      break;
    }
    default:
      throw Error(`Unsupported type: ${type}`);
  }
  if (schema.description)
    zodSchema = zodSchema.describe(schema.description);
  if (schema.default !== void 0)
    zodSchema = zodSchema.default(schema.default);
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean")
    return schema ? z.any() : z.never();
  let baseSchema = convertBaseSchema(schema, ctx), hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    let options = schema.anyOf.map((s) => convertSchema(s, ctx)), anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    let options = schema.oneOf.map((s) => convertSchema(s, ctx)), oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf))
    if (schema.allOf.length === 0)
      baseSchema = hasExplicitType ? baseSchema : z.any();
    else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx), startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx;i < schema.allOf.length; i++)
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      baseSchema = result;
    }
  if (schema.nullable === !0 && ctx.version === "openapi-3.0")
    baseSchema = z.nullable(baseSchema);
  if (schema.readOnly === !0)
    baseSchema = z.readonly(baseSchema);
  let extraMeta = {}, coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (let key of coreMetadataKeys)
    if (key in schema)
      extraMeta[key] = schema[key];
  let contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (let key of contentMetadataKeys)
    if (key in schema)
      extraMeta[key] = schema[key];
  for (let key of Object.keys(schema))
    if (!RECOGNIZED_KEYS.has(key))
      extraMeta[key] = schema[key];
  if (Object.keys(extraMeta).length > 0)
    ctx.registry.add(baseSchema, extraMeta);
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean")
    return schema ? z.any() : z.never();
  let version2 = detectVersion(schema, params?.defaultTarget), defs = schema.$defs || schema.definitions || {}, ctx = {
    version: version2,
    defs,
    refs: /* @__PURE__ */ new Map,
    processing: /* @__PURE__ */ new Set,
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}
// node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());
// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {};
  function assertIs2(_arg) {}
  util2.assertIs = assertIs2;
  function assertNever2(_x) {
    throw Error();
  }
  util2.assertNever = assertNever2, util2.arrayToEnum = (items) => {
    let obj = {};
    for (let item of items)
      obj[item] = item;
    return obj;
  }, util2.getValidEnumValues = (obj) => {
    let validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number"), filtered = {};
    for (let k of validKeys)
      filtered[k] = obj[k];
    return util2.objectValues(filtered);
  }, util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  }, util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    let keys = [];
    for (let key in object2)
      if (Object.prototype.hasOwnProperty.call(object2, key))
        keys.push(key);
    return keys;
  }, util2.find = (arr, checker) => {
    for (let item of arr)
      if (checker(item))
        return item;
    return;
  }, util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues2(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues2, util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint")
      return value.toString();
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType2 = (data) => {
  switch (typeof data) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data))
        return ZodParsedType.array;
      if (data === null)
        return ZodParsedType.null;
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function")
        return ZodParsedType.promise;
      if (typeof Map < "u" && data instanceof Map)
        return ZodParsedType.map;
      if (typeof Set < "u" && data instanceof Set)
        return ZodParsedType.set;
      if (typeof Date < "u" && data instanceof Date)
        return ZodParsedType.date;
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode2 = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class ZodError2 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [], this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    }, this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    let actualProto = new.target.prototype;
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(this, actualProto);
    else
      this.__proto__ = actualProto;
    this.name = "ZodError", this.issues = issues;
  }
  format(_mapper) {
    let mapper = _mapper || function(issue2) {
      return issue2.message;
    }, fieldErrors = { _errors: [] }, processError = (error48) => {
      for (let issue2 of error48.issues)
        if (issue2.code === "invalid_union")
          issue2.unionErrors.map(processError);
        else if (issue2.code === "invalid_return_type")
          processError(issue2.returnTypeError);
        else if (issue2.code === "invalid_arguments")
          processError(issue2.argumentsError);
        else if (issue2.path.length === 0)
          fieldErrors._errors.push(mapper(issue2));
        else {
          let curr = fieldErrors, i = 0;
          while (i < issue2.path.length) {
            let el = issue2.path[i];
            if (i !== issue2.path.length - 1)
              curr[el] = curr[el] || { _errors: [] };
            else
              curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2));
            curr = curr[el], i++;
          }
        }
    };
    return processError(this), fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError2))
      throw Error(`Not a ZodError: ${value}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    let fieldErrors = Object.create(null), formErrors = [];
    for (let sub of this.issues)
      if (sub.path.length > 0) {
        let firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [], fieldErrors[firstEl].push(mapper(sub));
      } else
        formErrors.push(mapper(sub));
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError2.create = (issues) => {
  return new ZodError2(issues);
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode2.invalid_type:
      if (issue2.received === ZodParsedType.undefined)
        message = "Required";
      else
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      break;
    case ZodIssueCode2.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode2.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode2.invalid_union:
      message = "Invalid input";
      break;
    case ZodIssueCode2.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode2.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode2.invalid_arguments:
      message = "Invalid function arguments";
      break;
    case ZodIssueCode2.invalid_return_type:
      message = "Invalid function return type";
      break;
    case ZodIssueCode2.invalid_date:
      message = "Invalid date";
      break;
    case ZodIssueCode2.invalid_string:
      if (typeof issue2.validation === "object")
        if ("includes" in issue2.validation) {
          if (message = `Invalid input: must include "${issue2.validation.includes}"`, typeof issue2.validation.position === "number")
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
        } else if ("startsWith" in issue2.validation)
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        else if ("endsWith" in issue2.validation)
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        else
          util.assertNever(issue2.validation);
      else if (issue2.validation !== "regex")
        message = `Invalid ${issue2.validation}`;
      else
        message = "Invalid";
      break;
    case ZodIssueCode2.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "more than"} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "over"} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode2.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "less than"} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "under"} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? "exactly" : issue2.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode2.custom:
      message = "Invalid input";
      break;
    case ZodIssueCode2.invalid_intersection_types:
      message = "Intersection results could not be merged";
      break;
    case ZodIssueCode2.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode2.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError, util.assertNever(issue2);
  }
  return { message };
}, en_default2 = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default2;
function getErrorMap2() {
  return overrideErrorMap;
}

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  let { data, path, errorMaps, issueData } = params, fullPath = [...path, ...issueData.path || []], fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0)
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  let errorMessage = "", maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (let map2 of maps)
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  let overrideMap = getErrorMap2(), issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default2 ? void 0 : en_default2
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    let arrayValue = [];
    for (let s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    let syncPairs = [];
    for (let pair of pairs) {
      let key = await pair.key, value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    let finalObject = {};
    for (let pair of pairs) {
      let { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value < "u" || pair.alwaysSet))
        finalObject[key.value] = value.value;
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
}), DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise < "u" && x instanceof Promise;

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {}, errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [], this.parent = parent, this.data = value, this._path = path, this._key = key;
  }
  get path() {
    if (!this._cachedPath.length)
      if (Array.isArray(this._key))
        this._cachedPath.push(...this._path, ...this._key);
      else
        this._cachedPath.push(...this._path, this._key);
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result))
    return { success: !0, data: result.value };
  else {
    if (!ctx.common.issues.length)
      throw Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        let error48 = new ZodError2(ctx.common.issues);
        return this._error = error48, this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  let { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error))
    throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (errorMap2)
    return { errorMap: errorMap2, description };
  return { errorMap: (iss, ctx) => {
    let { message } = params;
    if (iss.code === "invalid_enum_value")
      return { message: message ?? ctx.defaultError };
    if (typeof ctx.data > "u")
      return { message: message ?? required_error ?? ctx.defaultError };
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, description };
}

class ZodType2 {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType2(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType2(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType2(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    let result = this._parse(input);
    if (isAsync(result))
      throw Error("Synchronous parse encountered promise.");
    return result;
  }
  _parseAsync(input) {
    let result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    let result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    let ctx = {
      common: {
        issues: [],
        async: params?.async ?? !1,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    }, result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    let ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    };
    if (!this["~standard"].async)
      try {
        let result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered"))
          this["~standard"].async = !0;
        ctx.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    let result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    let ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: !0
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType2(data)
    }, maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx }), result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    let getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message > "u")
        return { message };
      else if (typeof message === "function")
        return message(val);
      else
        return message;
    };
    return this._refinement((val, ctx) => {
      let result = check2(val), setError = () => ctx.addIssue({
        code: ZodIssueCode2.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise < "u" && result instanceof Promise)
        return result.then((data) => {
          if (!data)
            return setError(), !1;
          else
            return !0;
        });
      if (!result)
        return setError(), !1;
      else
        return !0;
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check2(val))
        return ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData), !1;
      else
        return !0;
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync, this._def = def, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional2.create(this, this._def);
  }
  nullable() {
    return ZodNullable2.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray2.create(this);
  }
  promise() {
    return ZodPromise2.create(this, this._def);
  }
  or(option) {
    return ZodUnion2.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection2.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind2.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    let defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault2({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind2.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind2.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    let catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch2({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind2.ZodCatch
    });
  }
  describe(description) {
    return new this.constructor({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly2.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", emojiRegex, ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = "[0-5]\\d";
  if (args.precision)
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  else if (args.precision == null)
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  let secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`, opts = [];
  if (opts.push(args.local ? "Z?" : "Z"), args.offset)
    opts.push("([+-]\\d{2}:?\\d{2})");
  return regex = `${regex}(${opts.join("|")})`, new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip))
    return !0;
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip))
    return !0;
  return !1;
}
function isValidJWT2(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return !1;
  try {
    let [header] = jwt2.split(".");
    if (!header)
      return !1;
    let base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "="), decoded = JSON.parse(atob(base643));
    if (typeof decoded !== "object" || decoded === null)
      return !1;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return !1;
    if (!decoded.alg)
      return !1;
    if (alg && decoded.alg !== alg)
      return !1;
    return !0;
  } catch {
    return !1;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip))
    return !0;
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip))
    return !0;
  return !1;
}

class ZodString2 extends ZodType2 {
  _parse(input) {
    if (this._def.coerce)
      input.data = String(input.data);
    if (this._getType(input) !== ZodParsedType.string) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      }), INVALID;
    }
    let status = new ParseStatus, ctx = void 0;
    for (let check2 of this._def.checks)
      if (check2.kind === "min") {
        if (input.data.length < check2.value)
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check2.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "max") {
        if (input.data.length > check2.value)
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check2.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "length") {
        let tooBig = input.data.length > check2.value, tooSmall = input.data.length < check2.value;
        if (tooBig || tooSmall) {
          if (ctx = this._getOrReturnCtx(input, ctx), tooBig)
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: check2.value,
              type: "string",
              inclusive: !0,
              exact: !0,
              message: check2.message
            });
          else if (tooSmall)
            addIssueToContext(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: check2.value,
              type: "string",
              inclusive: !0,
              exact: !0,
              message: check2.message
            });
          status.dirty();
        }
      } else if (check2.kind === "email") {
        if (!emailRegex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "emoji") {
        if (!emojiRegex)
          emojiRegex = new RegExp(_emojiRegex, "u");
        if (!emojiRegex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "uuid") {
        if (!uuidRegex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "nanoid") {
        if (!nanoidRegex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "cuid") {
        if (!cuidRegex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "cuid2") {
        if (!cuid2Regex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "ulid") {
        if (!ulidRegex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "url")
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
        }
      else if (check2.kind === "regex") {
        if (check2.regex.lastIndex = 0, !check2.regex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "trim")
        input.data = input.data.trim();
      else if (check2.kind === "includes") {
        if (!input.data.includes(check2.value, check2.position))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { includes: check2.value, position: check2.position },
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "toLowerCase")
        input.data = input.data.toLowerCase();
      else if (check2.kind === "toUpperCase")
        input.data = input.data.toUpperCase();
      else if (check2.kind === "startsWith") {
        if (!input.data.startsWith(check2.value))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { startsWith: check2.value },
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "endsWith") {
        if (!input.data.endsWith(check2.value))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: { endsWith: check2.value },
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "datetime") {
        if (!datetimeRegex(check2).test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "datetime",
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "date") {
        if (!dateRegex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "date",
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "time") {
        if (!timeRegex(check2).test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_string,
            validation: "time",
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "duration") {
        if (!durationRegex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "ip") {
        if (!isValidIP(input.data, check2.version))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "jwt") {
        if (!isValidJWT2(input.data, check2.alg))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "cidr") {
        if (!isValidCidr(input.data, check2.version))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "base64") {
        if (!base64Regex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "base64url") {
        if (!base64urlRegex.test(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode2.invalid_string,
            message: check2.message
          }), status.dirty();
      } else
        util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode2.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string")
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: options
      });
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      offset: options?.offset ?? !1,
      local: options?.local ?? !1,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string")
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (let ch of this._def.checks)
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    return min;
  }
  get maxLength() {
    let max = null;
    for (let ch of this._def.checks)
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    return max;
  }
}
ZodString2.create = (params) => {
  return new ZodString2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodString,
    coerce: params?.coerce ?? !1,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder2(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepDecCount = (step.toString().split(".")[1] || "").length, decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce)
      input.data = Number(input.data);
    if (this._getType(input) !== ZodParsedType.number) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      }), INVALID;
    }
    let ctx = void 0, status = new ParseStatus;
    for (let check2 of this._def.checks)
      if (check2.kind === "int") {
        if (!util.isInteger(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: "integer",
            received: "float",
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "min") {
        if (check2.inclusive ? input.data < check2.value : input.data <= check2.value)
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: !1,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "max") {
        if (check2.inclusive ? input.data > check2.value : input.data >= check2.value)
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: check2.value,
            type: "number",
            inclusive: check2.inclusive,
            exact: !1,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "multipleOf") {
        if (floatSafeRemainder2(input.data, check2.value) !== 0)
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "finite") {
        if (!Number.isFinite(input.data))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.not_finite,
            message: check2.message
          }), status.dirty();
      } else
        util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber2({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodNumber2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (let ch of this._def.checks)
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf")
        return !0;
      else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber2.create = (params) => {
  return new ZodNumber2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodNumber,
    coerce: params?.coerce || !1,
    ...processCreateParams(params)
  });
};

class ZodBigInt2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce)
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    if (this._getType(input) !== ZodParsedType.bigint)
      return this._getInvalidInput(input);
    let ctx = void 0, status = new ParseStatus;
    for (let check2 of this._def.checks)
      if (check2.kind === "min") {
        if (check2.inclusive ? input.data < check2.value : input.data <= check2.value)
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            type: "bigint",
            minimum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "max") {
        if (check2.inclusive ? input.data > check2.value : input.data >= check2.value)
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            type: "bigint",
            maximum: check2.value,
            inclusive: check2.inclusive,
            message: check2.message
          }), status.dirty();
      } else if (check2.kind === "multipleOf") {
        if (input.data % check2.value !== BigInt(0))
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.not_multiple_of,
            multipleOf: check2.value,
            message: check2.message
          }), status.dirty();
      } else
        util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    }), INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt2({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new ZodBigInt2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    return max;
  }
}
ZodBigInt2.create = (params) => {
  return new ZodBigInt2({
    checks: [],
    typeName: ZodFirstPartyTypeKind2.ZodBigInt,
    coerce: params?.coerce ?? !1,
    ...processCreateParams(params)
  });
};

class ZodBoolean2 extends ZodType2 {
  _parse(input) {
    if (this._def.coerce)
      input.data = Boolean(input.data);
    if (this._getType(input) !== ZodParsedType.boolean) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean2.create = (params) => {
  return new ZodBoolean2({
    typeName: ZodFirstPartyTypeKind2.ZodBoolean,
    coerce: params?.coerce || !1,
    ...processCreateParams(params)
  });
};

class ZodDate2 extends ZodType2 {
  _parse(input) {
    if (this._def.coerce)
      input.data = new Date(input.data);
    if (this._getType(input) !== ZodParsedType.date) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      }), INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_date
      }), INVALID;
    }
    let status = new ParseStatus, ctx = void 0;
    for (let check2 of this._def.checks)
      if (check2.kind === "min") {
        if (input.data.getTime() < check2.value)
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.too_small,
            message: check2.message,
            inclusive: !0,
            exact: !1,
            minimum: check2.value,
            type: "date"
          }), status.dirty();
      } else if (check2.kind === "max") {
        if (input.data.getTime() > check2.value)
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            code: ZodIssueCode2.too_big,
            message: check2.message,
            inclusive: !0,
            exact: !1,
            maximum: check2.value,
            type: "date"
          }), status.dirty();
      } else
        util.assertNever(check2);
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new ZodDate2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (let ch of this._def.checks)
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (let ch of this._def.checks)
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    return max != null ? new Date(max) : null;
  }
}
ZodDate2.create = (params) => {
  return new ZodDate2({
    checks: [],
    coerce: params?.coerce || !1,
    typeName: ZodFirstPartyTypeKind2.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol2 extends ZodType2 {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.symbol) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol2.create = (params) => {
  return new ZodSymbol2({
    typeName: ZodFirstPartyTypeKind2.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined2 extends ZodType2 {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined2.create = (params) => {
  return new ZodUndefined2({
    typeName: ZodFirstPartyTypeKind2.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull2 extends ZodType2 {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.null) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
}
ZodNull2.create = (params) => {
  return new ZodNull2({
    typeName: ZodFirstPartyTypeKind2.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this._any = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny2.create = (params) => {
  return new ZodAny2({
    typeName: ZodFirstPartyTypeKind2.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this._unknown = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown2.create = (params) => {
  return new ZodUnknown2({
    typeName: ZodFirstPartyTypeKind2.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever2 extends ZodType2 {
  _parse(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode2.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    }), INVALID;
  }
}
ZodNever2.create = (params) => {
  return new ZodNever2({
    typeName: ZodFirstPartyTypeKind2.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid2 extends ZodType2 {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid2.create = (params) => {
  return new ZodVoid2({
    typeName: ZodFirstPartyTypeKind2.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray2 extends ZodType2 {
  _parse(input) {
    let { ctx, status } = this._processInputParams(input), def = this._def;
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (def.exactLength !== null) {
      let tooBig = ctx.data.length > def.exactLength.value, tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall)
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: def.exactLength.message
        }), status.dirty();
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value)
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: def.minLength.message
        }), status.dirty();
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value)
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: def.maxLength.message
        }), status.dirty();
    }
    if (ctx.common.async)
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    let result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray2({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray2({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray2({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray2.create = (schema, params) => {
  return new ZodArray2({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind2.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject2) {
    let newShape = {};
    for (let key in schema.shape) {
      let fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional2.create(deepPartialify(fieldSchema));
    }
    return new ZodObject2({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray2)
    return new ZodArray2({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  else if (schema instanceof ZodOptional2)
    return ZodOptional2.create(deepPartialify(schema.unwrap()));
  else if (schema instanceof ZodNullable2)
    return ZodNullable2.create(deepPartialify(schema.unwrap()));
  else if (schema instanceof ZodTuple2)
    return ZodTuple2.create(schema.items.map((item) => deepPartialify(item)));
  else
    return schema;
}

class ZodObject2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    let shape = this._def.shape(), keys = util.objectKeys(shape);
    return this._cached = { shape, keys }, this._cached;
  }
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.object) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      }), INVALID;
    }
    let { status, ctx } = this._processInputParams(input), { shape, keys: shapeKeys } = this._getCached(), extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
      for (let key in ctx.data)
        if (!shapeKeys.includes(key))
          extraKeys.push(key);
    }
    let pairs = [];
    for (let key of shapeKeys) {
      let keyValidator = shape[key], value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever2) {
      let unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough")
        for (let key of extraKeys)
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
      else if (unknownKeys === "strict") {
        if (extraKeys.length > 0)
          addIssueToContext(ctx, {
            code: ZodIssueCode2.unrecognized_keys,
            keys: extraKeys
          }), status.dirty();
      } else if (unknownKeys === "strip")
        ;
      else
        throw Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let catchall = this._def.catchall;
      for (let key of extraKeys) {
        let value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async)
      return Promise.resolve().then(async () => {
        let syncPairs = [];
        for (let pair of pairs) {
          let key = await pair.key, value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    else
      return ParseStatus.mergeObjectSync(status, pairs);
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    return errorUtil.errToObj, new ZodObject2({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          let defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject2({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject2({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    return new ZodObject2({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind2.ZodObject
    });
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject2({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    let shape = {};
    for (let key of util.objectKeys(mask))
      if (mask[key] && this.shape[key])
        shape[key] = this.shape[key];
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    let shape = {};
    for (let key of util.objectKeys(this.shape))
      if (!mask[key])
        shape[key] = this.shape[key];
    return new ZodObject2({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape)) {
      let fieldSchema = this.shape[key];
      if (mask && !mask[key])
        newShape[key] = fieldSchema;
      else
        newShape[key] = fieldSchema.optional();
    }
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape))
      if (mask && !mask[key])
        newShape[key] = this.shape[key];
      else {
        let newField = this.shape[key];
        while (newField instanceof ZodOptional2)
          newField = newField._def.innerType;
        newShape[key] = newField;
      }
    return new ZodObject2({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject2.create = (shape, params) => {
  return new ZodObject2({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject2.strictCreate = (shape, params) => {
  return new ZodObject2({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject2.lazycreate = (shape, params) => {
  return new ZodObject2({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever2.create(),
    typeName: ZodFirstPartyTypeKind2.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion2 extends ZodType2 {
  _parse(input) {
    let { ctx } = this._processInputParams(input), options = this._def.options;
    function handleResults(results) {
      for (let result of results)
        if (result.result.status === "valid")
          return result.result;
      for (let result of results)
        if (result.result.status === "dirty")
          return ctx.common.issues.push(...result.ctx.common.issues), result.result;
      let unionErrors = results.map((result) => new ZodError2(result.ctx.common.issues));
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors
      }), INVALID;
    }
    if (ctx.common.async)
      return Promise.all(options.map(async (option) => {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    else {
      let dirty = void 0, issues = [];
      for (let option of options) {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        }, result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid")
          return result;
        else if (result.status === "dirty" && !dirty)
          dirty = { result, ctx: childCtx };
        if (childCtx.common.issues.length)
          issues.push(childCtx.common.issues);
      }
      if (dirty)
        return ctx.common.issues.push(...dirty.ctx.common.issues), dirty.result;
      let unionErrors = issues.map((issues2) => new ZodError2(issues2));
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union,
        unionErrors
      }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion2.create = (types, params) => {
  return new ZodUnion2({
    options: types,
    typeName: ZodFirstPartyTypeKind2.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy2)
    return getDiscriminator(type.schema);
  else if (type instanceof ZodEffects)
    return getDiscriminator(type.innerType());
  else if (type instanceof ZodLiteral2)
    return [type.value];
  else if (type instanceof ZodEnum2)
    return type.options;
  else if (type instanceof ZodNativeEnum)
    return util.objectValues(type.enum);
  else if (type instanceof ZodDefault2)
    return getDiscriminator(type._def.innerType);
  else if (type instanceof ZodUndefined2)
    return [void 0];
  else if (type instanceof ZodNull2)
    return [null];
  else if (type instanceof ZodOptional2)
    return [void 0, ...getDiscriminator(type.unwrap())];
  else if (type instanceof ZodNullable2)
    return [null, ...getDiscriminator(type.unwrap())];
  else if (type instanceof ZodBranded)
    return getDiscriminator(type.unwrap());
  else if (type instanceof ZodReadonly2)
    return getDiscriminator(type.unwrap());
  else if (type instanceof ZodCatch2)
    return getDiscriminator(type._def.innerType);
  else
    return [];
};

class ZodDiscriminatedUnion2 extends ZodType2 {
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let discriminator = this.discriminator, discriminatorValue = ctx.data[discriminator], option = this.optionsMap.get(discriminatorValue);
    if (!option)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      }), INVALID;
    if (ctx.common.async)
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    else
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    let optionsMap = /* @__PURE__ */ new Map;
    for (let type of options) {
      let discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length)
        throw Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      for (let value of discriminatorValues) {
        if (optionsMap.has(value))
          throw Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion2({
      typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues2(a, b) {
  let aType = getParsedType2(a), bType = getParsedType2(b);
  if (a === b)
    return { valid: !0, data: a };
  else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    let bKeys = util.objectKeys(b), sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid)
        return { valid: !1 };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length)
      return { valid: !1 };
    let newArray = [];
    for (let index = 0;index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid)
        return { valid: !1 };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b)
    return { valid: !0, data: a };
  else
    return { valid: !1 };
}

class ZodIntersection2 extends ZodType2 {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight))
        return INVALID;
      let merged = mergeValues2(parsedLeft.value, parsedRight.value);
      if (!merged.valid)
        return addIssueToContext(ctx, {
          code: ZodIssueCode2.invalid_intersection_types
        }), INVALID;
      if (isDirty(parsedLeft) || isDirty(parsedRight))
        status.dirty();
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async)
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    else
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
  }
}
ZodIntersection2.create = (left, right, params) => {
  return new ZodIntersection2({
    left,
    right,
    typeName: ZodFirstPartyTypeKind2.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple2 extends ZodType2 {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (ctx.data.length < this._def.items.length)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID;
    if (!this._def.rest && ctx.data.length > this._def.items.length)
      addIssueToContext(ctx, {
        code: ZodIssueCode2.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), status.dirty();
    let items = [...ctx.data].map((item, itemIndex) => {
      let schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async)
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    else
      return ParseStatus.mergeArray(status, items);
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple2({
      ...this._def,
      rest
    });
  }
}
ZodTuple2.create = (schemas3, params) => {
  if (!Array.isArray(schemas3))
    throw Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple2({
    items: schemas3,
    typeName: ZodFirstPartyTypeKind2.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord2 extends ZodType2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let pairs = [], keyType = this._def.keyType, valueType = this._def.valueType;
    for (let key in ctx.data)
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    if (ctx.common.async)
      return ParseStatus.mergeObjectAsync(status, pairs);
    else
      return ParseStatus.mergeObjectSync(status, pairs);
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType2)
      return new ZodRecord2({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind2.ZodRecord,
        ...processCreateParams(third)
      });
    return new ZodRecord2({
      keyType: ZodString2.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind2.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap2 extends ZodType2 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      }), INVALID;
    let keyType = this._def.keyType, valueType = this._def.valueType, pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      let finalMap = /* @__PURE__ */ new Map;
      return Promise.resolve().then(async () => {
        for (let pair of pairs) {
          let key = await pair.key, value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted")
            return INVALID;
          if (key.status === "dirty" || value.status === "dirty")
            status.dirty();
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      let finalMap = /* @__PURE__ */ new Map;
      for (let pair of pairs) {
        let { key, value } = pair;
        if (key.status === "aborted" || value.status === "aborted")
          return INVALID;
        if (key.status === "dirty" || value.status === "dirty")
          status.dirty();
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap2.create = (keyType, valueType, params) => {
  return new ZodMap2({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind2.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet2 extends ZodType2 {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      }), INVALID;
    let def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value)
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: def.minSize.message
        }), status.dirty();
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value)
        addIssueToContext(ctx, {
          code: ZodIssueCode2.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: def.maxSize.message
        }), status.dirty();
    }
    let valueType = this._def.valueType;
    function finalizeSet(elements2) {
      let parsedSet = /* @__PURE__ */ new Set;
      for (let element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    let elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async)
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    else
      return finalizeSet(elements);
  }
  min(minSize, message) {
    return new ZodSet2({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet2({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet2.create = (valueType, params) => {
  return new ZodSet2({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind2.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction2 extends ZodType2 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      }), INVALID;
    function makeArgsIssue(args, error48) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_arguments,
          argumentsError: error48
        }
      });
    }
    function makeReturnsIssue(returns, error48) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap2(), en_default2].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode2.invalid_return_type,
          returnTypeError: error48
        }
      });
    }
    let params = { errorMap: ctx.common.contextualErrorMap }, fn = ctx.data;
    if (this._def.returns instanceof ZodPromise2) {
      let me = this;
      return OK(async function(...args) {
        let error48 = new ZodError2([]), parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          throw error48.addIssue(makeArgsIssue(args, e)), error48;
        }), result = await Reflect.apply(fn, this, parsedArgs);
        return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          throw error48.addIssue(makeReturnsIssue(result, e)), error48;
        });
      });
    } else {
      let me = this;
      return OK(function(...args) {
        let parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success)
          throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);
        let result = Reflect.apply(fn, this, parsedArgs.data), parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success)
          throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction2({
      ...this._def,
      args: ZodTuple2.create(items).rest(ZodUnknown2.create())
    });
  }
  returns(returnType) {
    return new ZodFunction2({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    return this.parse(func);
  }
  strictImplement(func) {
    return this.parse(func);
  }
  static create(args, returns, params) {
    return new ZodFunction2({
      args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
      returns: returns || ZodUnknown2.create(),
      typeName: ZodFirstPartyTypeKind2.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy2 extends ZodType2 {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    return this._def.getter()._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy2.create = (getter, params) => {
  return new ZodLazy2({
    getter,
    typeName: ZodFirstPartyTypeKind2.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral2 extends ZodType2 {
  _parse(input) {
    if (input.data !== this._def.value) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_literal,
        expected: this._def.value
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral2.create = (value, params) => {
  return new ZodLiteral2({
    value,
    typeName: ZodFirstPartyTypeKind2.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum2({
    values,
    typeName: ZodFirstPartyTypeKind2.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum2 extends ZodType2 {
  _parse(input) {
    if (typeof input.data !== "string") {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type
      }), INVALID;
    }
    if (!this._cache)
      this._cache = new Set(this._def.values);
    if (!this._cache.has(input.data)) {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Values() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum2.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum2.create = createZodEnum;

class ZodNativeEnum extends ZodType2 {
  _parse(input) {
    let nativeEnumValues = util.getValidEnumValues(this._def.values), ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode2.invalid_type
      }), INVALID;
    }
    if (!this._cache)
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    if (!this._cache.has(input.data)) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode2.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise2 extends ZodType2 {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === !1)
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      }), INVALID;
    let promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise2.create = (schema, params) => {
  return new ZodPromise2({
    type: schema,
    typeName: ZodFirstPartyTypeKind2.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType2 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), effect = this._def.effect || null, checkCtx = {
      addIssue: (arg) => {
        if (addIssueToContext(ctx, arg), arg.fatal)
          status.abort();
        else
          status.dirty();
      },
      get path() {
        return ctx.path;
      }
    };
    if (checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx), effect.type === "preprocess") {
      let processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async)
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          let result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      else {
        if (status.value === "aborted")
          return INVALID;
        let result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      let executeRefinement = (acc) => {
        let result = effect.refinement(acc, checkCtx);
        if (ctx.common.async)
          return Promise.resolve(result);
        if (result instanceof Promise)
          throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return acc;
      };
      if (ctx.common.async === !1) {
        let inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        return executeRefinement(inner.value), { status: status.value, value: inner.value };
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
    }
    if (effect.type === "transform")
      if (ctx.common.async === !1) {
        let base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        let result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise)
          throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: status.value, value: result };
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind2.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind2.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional2 extends ZodType2 {
  _parse(input) {
    if (this._getType(input) === ZodParsedType.undefined)
      return OK(void 0);
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional2.create = (type, params) => {
  return new ZodOptional2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable2 extends ZodType2 {
  _parse(input) {
    if (this._getType(input) === ZodParsedType.null)
      return OK(null);
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable2.create = (type, params) => {
  return new ZodNullable2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault2 extends ZodType2 {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined)
      data = this._def.defaultValue();
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault2.create = (type, params) => {
  return new ZodDefault2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch2 extends ZodType2 {
  _parse(input) {
    let { ctx } = this._processInputParams(input), newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    }, result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result))
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError2(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    else
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError2(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch2.create = (type, params) => {
  return new ZodCatch2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN2 extends ZodType2 {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.nan) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode2.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN2.create = (params) => {
  return new ZodNaN2({
    typeName: ZodFirstPartyTypeKind2.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType2 {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType2 {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.common.async)
      return (async () => {
        let inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty")
          return status.dirty(), DIRTY(inResult.value);
        else
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
      })();
    else {
      let inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty")
        return status.dirty(), {
          status: "dirty",
          value: inResult.value
        };
      else
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind2.ZodPipeline
    });
  }
}

class ZodReadonly2 extends ZodType2 {
  _parse(input) {
    let result = this._def.innerType._parse(input), freeze = (data) => {
      if (isValid(data))
        data.value = Object.freeze(data.value);
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly2.create = (type, params) => {
  return new ZodReadonly2({
    innerType: type,
    typeName: ZodFirstPartyTypeKind2.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject2.lazycreate
}, ZodFirstPartyTypeKind2;
(function(ZodFirstPartyTypeKind3) {
  ZodFirstPartyTypeKind3.ZodString = "ZodString", ZodFirstPartyTypeKind3.ZodNumber = "ZodNumber", ZodFirstPartyTypeKind3.ZodNaN = "ZodNaN", ZodFirstPartyTypeKind3.ZodBigInt = "ZodBigInt", ZodFirstPartyTypeKind3.ZodBoolean = "ZodBoolean", ZodFirstPartyTypeKind3.ZodDate = "ZodDate", ZodFirstPartyTypeKind3.ZodSymbol = "ZodSymbol", ZodFirstPartyTypeKind3.ZodUndefined = "ZodUndefined", ZodFirstPartyTypeKind3.ZodNull = "ZodNull", ZodFirstPartyTypeKind3.ZodAny = "ZodAny", ZodFirstPartyTypeKind3.ZodUnknown = "ZodUnknown", ZodFirstPartyTypeKind3.ZodNever = "ZodNever", ZodFirstPartyTypeKind3.ZodVoid = "ZodVoid", ZodFirstPartyTypeKind3.ZodArray = "ZodArray", ZodFirstPartyTypeKind3.ZodObject = "ZodObject", ZodFirstPartyTypeKind3.ZodUnion = "ZodUnion", ZodFirstPartyTypeKind3.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ZodFirstPartyTypeKind3.ZodIntersection = "ZodIntersection", ZodFirstPartyTypeKind3.ZodTuple = "ZodTuple", ZodFirstPartyTypeKind3.ZodRecord = "ZodRecord", ZodFirstPartyTypeKind3.ZodMap = "ZodMap", ZodFirstPartyTypeKind3.ZodSet = "ZodSet", ZodFirstPartyTypeKind3.ZodFunction = "ZodFunction", ZodFirstPartyTypeKind3.ZodLazy = "ZodLazy", ZodFirstPartyTypeKind3.ZodLiteral = "ZodLiteral", ZodFirstPartyTypeKind3.ZodEnum = "ZodEnum", ZodFirstPartyTypeKind3.ZodEffects = "ZodEffects", ZodFirstPartyTypeKind3.ZodNativeEnum = "ZodNativeEnum", ZodFirstPartyTypeKind3.ZodOptional = "ZodOptional", ZodFirstPartyTypeKind3.ZodNullable = "ZodNullable", ZodFirstPartyTypeKind3.ZodDefault = "ZodDefault", ZodFirstPartyTypeKind3.ZodCatch = "ZodCatch", ZodFirstPartyTypeKind3.ZodPromise = "ZodPromise", ZodFirstPartyTypeKind3.ZodBranded = "ZodBranded", ZodFirstPartyTypeKind3.ZodPipeline = "ZodPipeline", ZodFirstPartyTypeKind3.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
var stringType = ZodString2.create, numberType = ZodNumber2.create, nanType = ZodNaN2.create, bigIntType = ZodBigInt2.create, booleanType = ZodBoolean2.create, dateType = ZodDate2.create, symbolType = ZodSymbol2.create, undefinedType = ZodUndefined2.create, nullType = ZodNull2.create, anyType = ZodAny2.create, unknownType = ZodUnknown2.create, neverType = ZodNever2.create, voidType = ZodVoid2.create, arrayType = ZodArray2.create, objectType = ZodObject2.create, strictObjectType = ZodObject2.strictCreate, unionType = ZodUnion2.create, discriminatedUnionType = ZodDiscriminatedUnion2.create, intersectionType = ZodIntersection2.create, tupleType = ZodTuple2.create, recordType = ZodRecord2.create, mapType = ZodMap2.create, setType = ZodSet2.create, functionType = ZodFunction2.create, lazyType = ZodLazy2.create, literalType = ZodLiteral2.create, enumType = ZodEnum2.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise2.create, effectsType = ZodEffects.create, optionalType = ZodOptional2.create, nullableType = ZodNullable2.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create;

// node_modules/eventsource-parser/dist/index.js
class ParseError extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
}
function noop(_arg) {}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");
  let { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks, incompleteLine = "", isFirstChunk = !0, id, data = "", eventType = "";
  function feed(newChunk) {
    let chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (let line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = !1;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    let fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      let field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\x00") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(new ParseError(`Invalid \`retry\` value: "${value}"`, {
          type: "invalid-retry",
          value,
          line
        }));
        break;
      default:
        onError(new ParseError(`Unknown field "${field.length > 20 ? `${field.slice(0, 20)}` : field}"`, { type: "unknown-field", field, value, line }));
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = !0, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  let lines = [], incompleteLine = "", searchIndex = 0;
  for (;searchIndex < chunk.length; ) {
    let crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex), lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      let line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}

// node_modules/eventsource-parser/dist/stream.js
class EventSourceParserStream extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error48) {
            onError === "terminate" ? controller.error(error48) : typeof onError == "function" && onError(error48);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
}

// node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders(...headers) {
  return headers.reduce((combinedHeaders, currentHeaders) => ({
    ...combinedHeaders,
    ...currentHeaders != null ? currentHeaders : {}
  }), {});
}
function createToolNameMapping({
  tools = [],
  providerToolNames
}) {
  let customToolNameToProviderToolName = {}, providerToolNameToCustomToolName = {};
  for (let tool2 of tools)
    if (tool2.type === "provider" && tool2.id in providerToolNames) {
      let providerToolName = providerToolNames[tool2.id];
      customToolNameToProviderToolName[tool2.name] = providerToolName, providerToolNameToCustomToolName[providerToolName] = tool2.name;
    }
  return {
    toProviderToolName: (customToolName) => {
      var _a22;
      return (_a22 = customToolNameToProviderToolName[customToolName]) != null ? _a22 : customToolName;
    },
    toCustomToolName: (providerToolName) => {
      var _a22;
      return (_a22 = providerToolNameToCustomToolName[providerToolName]) != null ? _a22 : providerToolName;
    }
  };
}
async function delay(delayInMs, options) {
  if (delayInMs == null)
    return Promise.resolve();
  let signal = options == null ? void 0 : options.abortSignal;
  return new Promise((resolve2, reject) => {
    if (signal == null ? void 0 : signal.aborted) {
      reject(createAbortError());
      return;
    }
    let timeoutId = setTimeout(() => {
      cleanup(), resolve2();
    }, delayInMs), cleanup = () => {
      clearTimeout(timeoutId), signal == null || signal.removeEventListener("abort", onAbort);
    }, onAbort = () => {
      cleanup(), reject(createAbortError());
    };
    signal == null || signal.addEventListener("abort", onAbort);
  });
}
function createAbortError() {
  return new DOMException("Delay was aborted", "AbortError");
}
var DelayedPromise = class {
  constructor() {
    this.status = { type: "pending" }, this._resolve = void 0, this._reject = void 0;
  }
  get promise() {
    if (this._promise)
      return this._promise;
    return this._promise = new Promise((resolve2, reject) => {
      if (this.status.type === "resolved")
        resolve2(this.status.value);
      else if (this.status.type === "rejected")
        reject(this.status.error);
      this._resolve = resolve2, this._reject = reject;
    }), this._promise;
  }
  resolve(value) {
    var _a22;
    if (this.status = { type: "resolved", value }, this._promise)
      (_a22 = this._resolve) == null || _a22.call(this, value);
  }
  reject(error48) {
    var _a22;
    if (this.status = { type: "rejected", error: error48 }, this._promise)
      (_a22 = this._reject) == null || _a22.call(this, error48);
  }
  isResolved() {
    return this.status.type === "resolved";
  }
  isRejected() {
    return this.status.type === "rejected";
  }
  isPending() {
    return this.status.type === "pending";
  }
};
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
var { btoa: btoa2, atob: atob2 } = globalThis;
function convertBase64ToUint8Array(base64String) {
  let base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/"), latin1string = atob2(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase64(array2) {
  let latin1string = "";
  for (let i = 0;i < array2.length; i++)
    latin1string += String.fromCodePoint(array2[i]);
  return btoa2(latin1string);
}
function convertToBase64(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase64(value) : value;
}
function convertToFormData(input, options = {}) {
  let { useArrayBrackets = !0 } = options, formData = new FormData;
  for (let [key, value] of Object.entries(input)) {
    if (value == null)
      continue;
    if (Array.isArray(value)) {
      if (value.length === 1) {
        formData.append(key, value[0]);
        continue;
      }
      let arrayKey = useArrayBrackets ? `${key}[]` : key;
      for (let item of value)
        formData.append(arrayKey, item);
      continue;
    }
    formData.append(key, value);
  }
  return formData;
}
var name14 = "AI_DownloadError", marker15 = `vercel.ai.error.${name14}`, symbol17 = Symbol.for(marker15), _a17, _b15, DownloadError = class extends (_b15 = AISDKError, _a17 = symbol17, _b15) {
  constructor({
    url: url2,
    statusCode,
    statusText,
    cause,
    message = cause == null ? `Failed to download ${url2}: ${statusCode} ${statusText}` : `Failed to download ${url2}: ${cause}`
  }) {
    super({ name: name14, message, cause });
    this[_a17] = !0, this.url = url2, this.statusCode = statusCode, this.statusText = statusText;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker15);
  }
};
async function downloadBlob(url2) {
  try {
    let response = await fetch(url2);
    if (!response.ok)
      throw new DownloadError({
        url: url2,
        statusCode: response.status,
        statusText: response.statusText
      });
    return await response.blob();
  } catch (error48) {
    if (DownloadError.isInstance(error48))
      throw error48;
    throw new DownloadError({ url: url2, cause: error48 });
  }
}
var createIdGenerator = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  let generator = () => {
    let alphabetLength = alphabet.length, chars = Array(size);
    for (let i = 0;i < size; i++)
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    return chars.join("");
  };
  if (prefix == null)
    return generator;
  if (alphabet.includes(separator))
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  return () => `${prefix}${separator}${generator()}`;
}, generateId = createIdGenerator();
function getErrorMessage2(error48) {
  if (error48 == null)
    return "unknown error";
  if (typeof error48 === "string")
    return error48;
  if (error48 instanceof Error)
    return error48.message;
  return JSON.stringify(error48);
}
function isAbortError(error48) {
  return (error48 instanceof Error || error48 instanceof DOMException) && (error48.name === "AbortError" || error48.name === "ResponseAborted" || error48.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"], BUN_ERROR_CODES = [
  "ConnectionRefused",
  "ConnectionClosed",
  "FailedToOpenSocket",
  "ECONNRESET",
  "ECONNREFUSED",
  "ETIMEDOUT",
  "EPIPE"
];
function isBunNetworkError(error48) {
  if (!(error48 instanceof Error))
    return !1;
  let code = error48.code;
  if (typeof code === "string" && BUN_ERROR_CODES.includes(code))
    return !0;
  return !1;
}
function handleFetchError({
  error: error48,
  url: url2,
  requestBodyValues
}) {
  if (isAbortError(error48))
    return error48;
  if (error48 instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error48.message.toLowerCase())) {
    let cause = error48.cause;
    if (cause != null)
      return new APICallError({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url: url2,
        requestBodyValues,
        isRetryable: !0
      });
  }
  if (isBunNetworkError(error48))
    return new APICallError({
      message: `Cannot connect to API: ${error48.message}`,
      cause: error48,
      url: url2,
      requestBodyValues,
      isRetryable: !0
    });
  return error48;
}
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a22, _b22, _c;
  if (globalThisAny.window)
    return "runtime/browser";
  if ((_a22 = globalThisAny.navigator) == null ? void 0 : _a22.userAgent)
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  if ((_c = (_b22 = globalThisAny.process) == null ? void 0 : _b22.versions) == null ? void 0 : _c.node)
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  if (globalThisAny.EdgeRuntime)
    return "runtime/vercel-edge";
  return "runtime/unknown";
}
function normalizeHeaders(headers) {
  if (headers == null)
    return {};
  let normalized = {};
  if (headers instanceof Headers)
    headers.forEach((value, key) => {
      normalized[key.toLowerCase()] = value;
    });
  else {
    if (!Array.isArray(headers))
      headers = Object.entries(headers);
    for (let [key, value] of headers)
      if (value != null)
        normalized[key.toLowerCase()] = value;
  }
  return normalized;
}
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
  let normalizedHeaders = new Headers(normalizeHeaders(headers)), currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  return normalizedHeaders.set("user-agent", [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")), Object.fromEntries(normalizedHeaders.entries());
}
var VERSION = "4.0.13", getOriginalFetch = () => globalThis.fetch, getFromApi = async ({
  url: url2,
  headers = {},
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch()
}) => {
  try {
    let response = await fetch2(url2, {
      method: "GET",
      headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),
      signal: abortSignal
    }), responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url: url2,
          requestBodyValues: {}
        });
      } catch (error48) {
        if (isAbortError(error48) || APICallError.isInstance(error48))
          throw error48;
        throw new APICallError({
          message: "Failed to process error response",
          cause: error48,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: {}
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url: url2,
        requestBodyValues: {}
      });
    } catch (error48) {
      if (error48 instanceof Error) {
        if (isAbortError(error48) || APICallError.isInstance(error48))
          throw error48;
      }
      throw new APICallError({
        message: "Failed to process successful response",
        cause: error48,
        statusCode: response.status,
        url: url2,
        responseHeaders,
        requestBodyValues: {}
      });
    }
  } catch (error48) {
    throw handleFetchError({ error: error48, url: url2, requestBodyValues: {} });
  }
}, DEFAULT_SCHEMA_PREFIX = "JSON schema:", DEFAULT_SCHEMA_SUFFIX = "You MUST answer with a JSON object that matches the JSON schema above.", DEFAULT_GENERIC_SUFFIX = "You MUST answer with JSON.";
function injectJsonInstruction({
  prompt,
  schema,
  schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0,
  schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX
}) {
  return [
    prompt != null && prompt.length > 0 ? prompt : void 0,
    prompt != null && prompt.length > 0 ? "" : void 0,
    schemaPrefix,
    schema != null ? JSON.stringify(schema) : void 0,
    schemaSuffix
  ].filter((line) => line != null).join(`
`);
}
function injectJsonInstructionIntoMessages({
  messages,
  schema,
  schemaPrefix,
  schemaSuffix
}) {
  var _a22, _b22;
  let systemMessage = ((_a22 = messages[0]) == null ? void 0 : _a22.role) === "system" ? { ...messages[0] } : { role: "system", content: "" };
  return systemMessage.content = injectJsonInstruction({
    prompt: systemMessage.content,
    schema,
    schemaPrefix,
    schemaSuffix
  }), [
    systemMessage,
    ...((_b22 = messages[0]) == null ? void 0 : _b22.role) === "system" ? messages.slice(1) : messages
  ];
}
function isNonNullable(value) {
  return value != null;
}
function isUrlSupported({
  mediaType,
  url: url2,
  supportedUrls
}) {
  return url2 = url2.toLowerCase(), mediaType = mediaType.toLowerCase(), Object.entries(supportedUrls).map(([key, value]) => {
    let mediaType2 = key.toLowerCase();
    return mediaType2 === "*" || mediaType2 === "*/*" ? { mediaTypePrefix: "", regexes: value } : { mediaTypePrefix: mediaType2.replace(/\*/, ""), regexes: value };
  }).filter(({ mediaTypePrefix }) => mediaType.startsWith(mediaTypePrefix)).flatMap(({ regexes }) => regexes).some((pattern) => pattern.test(url2));
}
function loadApiKey({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string")
    return apiKey;
  if (apiKey != null)
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  if (typeof process > "u")
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  if (apiKey = process.env[environmentVariableName], apiKey == null)
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  if (typeof apiKey !== "string")
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  return apiKey;
}
function loadOptionalSetting({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string")
    return settingValue;
  if (settingValue != null || typeof process > "u")
    return;
  if (settingValue = process.env[environmentVariableName], settingValue == null || typeof settingValue !== "string")
    return;
  return settingValue;
}
function mediaTypeToExtension(mediaType) {
  var _a22;
  let [_type, subtype = ""] = mediaType.toLowerCase().split("/");
  return (_a22 = {
    mpeg: "mp3",
    "x-wav": "wav",
    opus: "ogg",
    mp4: "m4a",
    "x-m4a": "m4a"
  }[subtype]) != null ? _a22 : subtype;
}
var suspectProtoRx = /"__proto__"\s*:/, suspectConstructorRx = /"constructor"\s*:/;
function _parse2(text) {
  let obj = JSON.parse(text);
  if (obj === null || typeof obj !== "object")
    return obj;
  if (suspectProtoRx.test(text) === !1 && suspectConstructorRx.test(text) === !1)
    return obj;
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    let nodes = next;
    next = [];
    for (let node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__"))
        throw SyntaxError("Object contains forbidden prototype property");
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype"))
        throw SyntaxError("Object contains forbidden prototype property");
      for (let key in node) {
        let value = node[key];
        if (value && typeof value === "object")
          next.push(value);
      }
    }
  }
  return obj;
}
function secureJsonParse(text) {
  let { stackTraceLimit } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch (e) {
    return _parse2(text);
  }
  try {
    return _parse2(text);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
function addAdditionalPropertiesToJsonSchema(jsonSchema2) {
  if (jsonSchema2.type === "object" || Array.isArray(jsonSchema2.type) && jsonSchema2.type.includes("object")) {
    jsonSchema2.additionalProperties = !1;
    let { properties } = jsonSchema2;
    if (properties != null)
      for (let key of Object.keys(properties))
        properties[key] = visit(properties[key]);
  }
  if (jsonSchema2.items != null)
    jsonSchema2.items = Array.isArray(jsonSchema2.items) ? jsonSchema2.items.map(visit) : visit(jsonSchema2.items);
  if (jsonSchema2.anyOf != null)
    jsonSchema2.anyOf = jsonSchema2.anyOf.map(visit);
  if (jsonSchema2.allOf != null)
    jsonSchema2.allOf = jsonSchema2.allOf.map(visit);
  if (jsonSchema2.oneOf != null)
    jsonSchema2.oneOf = jsonSchema2.oneOf.map(visit);
  let { definitions } = jsonSchema2;
  if (definitions != null)
    for (let key of Object.keys(definitions))
      definitions[key] = visit(definitions[key]);
  return jsonSchema2;
}
function visit(def) {
  if (typeof def === "boolean")
    return def;
  return addAdditionalPropertiesToJsonSchema(def);
}
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use"), defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};
function parseAnyDef() {
  return {};
}
function parseArrayDef(def, refs) {
  var _a22, _b22, _c;
  let res = {
    type: "array"
  };
  if (((_a22 = def.type) == null ? void 0 : _a22._def) && ((_c = (_b22 = def.type) == null ? void 0 : _b22._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind2.ZodAny)
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  if (def.minLength)
    res.minItems = def.minLength.value;
  if (def.maxLength)
    res.maxItems = def.maxLength.value;
  if (def.exactLength)
    res.minItems = def.exactLength.value, res.maxItems = def.exactLength.value;
  return res;
}
function parseBigintDef(def) {
  let res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (let check2 of def.checks)
    switch (check2.kind) {
      case "min":
        if (check2.inclusive)
          res.minimum = check2.value;
        else
          res.exclusiveMinimum = check2.value;
        break;
      case "max":
        if (check2.inclusive)
          res.maximum = check2.value;
        else
          res.exclusiveMaximum = check2.value;
        break;
      case "multipleOf":
        res.multipleOf = check2.value;
        break;
    }
  return res;
}
function parseBooleanDef() {
  return { type: "boolean" };
}
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};
function parseDateDef(def, refs, overrideDateStrategy) {
  let strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy))
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def);
  }
}
var integerDateParser = (def) => {
  let res = {
    type: "integer",
    format: "unix-time"
  };
  for (let check2 of def.checks)
    switch (check2.kind) {
      case "min":
        res.minimum = check2.value;
        break;
      case "max":
        res.maximum = check2.value;
        break;
    }
  return res;
};
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return !1;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  let allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x), mergedAllOf = [];
  return allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema))
      mergedAllOf.push(...schema.allOf);
    else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === !1) {
        let { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  }), mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}
function parseLiteralDef(def) {
  let parsedType2 = typeof def.value;
  if (parsedType2 !== "bigint" && parsedType2 !== "number" && parsedType2 !== "boolean" && parsedType2 !== "string")
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  return {
    type: parsedType2 === "bigint" ? "integer" : parsedType2,
    const: def.value
  };
}
var emojiRegex2 = void 0, zodPatterns = {
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  emoji: () => {
    if (emojiRegex2 === void 0)
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    return emojiRegex2;
  },
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  let res = {
    type: "string"
  };
  if (def.checks)
    for (let check2 of def.checks)
      switch (check2.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`), check2.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`), check2.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check2.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value;
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check2.value, refs)), check2.message, refs);
          break;
        }
        case "ip": {
          if (check2.version !== "v6")
            addFormat(res, "ipv4", check2.message, refs);
          if (check2.version !== "v4")
            addFormat(res, "ipv6", check2.message, refs);
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check2.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check2.message, refs);
          break;
        case "cidr": {
          if (check2.version !== "v6")
            addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);
          if (check2.version !== "v4")
            addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check2.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check2.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check2.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check2.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid":
          addPattern(res, zodPatterns.nanoid, check2.message, refs);
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
      }
  return res;
}
function escapeLiteralCheckValue(literal2, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal2) : literal2;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0;i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i]))
      result += "\\";
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  var _a22;
  if (schema.format || ((_a22 = schema.anyOf) == null ? void 0 : _a22.some((x) => x.format))) {
    if (!schema.anyOf)
      schema.anyOf = [];
    if (schema.format)
      schema.anyOf.push({
        format: schema.format
      }), delete schema.format;
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else
    schema.format = value;
}
function addPattern(schema, regex, message, refs) {
  var _a22;
  if (schema.pattern || ((_a22 = schema.allOf) == null ? void 0 : _a22.some((x) => x.pattern))) {
    if (!schema.allOf)
      schema.allOf = [];
    if (schema.pattern)
      schema.allOf.push({
        pattern: schema.pattern
      }), delete schema.pattern;
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else
    schema.pattern = stringifyRegExpWithFlags(regex, refs);
}
function stringifyRegExpWithFlags(regex, refs) {
  var _a22;
  if (!refs.applyRegexFlags || !regex.flags)
    return regex.source;
  let flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
  }, source = flags.i ? regex.source.toLowerCase() : regex.source, pattern = "", isEscaped = !1, inCharGroup = !1, inCharRange = !1;
  for (let i = 0;i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i], isEscaped = !1;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange)
            pattern += source[i], pattern += `${source[i - 2]}-${source[i]}`.toUpperCase(), inCharRange = !1;
          else if (source[i + 1] === "-" && ((_a22 = source[i + 2]) == null ? void 0 : _a22.match(/[a-z]/)))
            pattern += source[i], inCharRange = !0;
          else
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    if (pattern += source[i], source[i] === "\\")
      isEscaped = !0;
    else if (inCharGroup && source[i] === "]")
      inCharGroup = !1;
    else if (!inCharGroup && source[i] === "[")
      inCharGroup = !0;
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    return console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`), regex.source;
  }
  return pattern;
}
function parseRecordDef(def, refs) {
  var _a22, _b22, _c, _d, _e, _f;
  let schema = {
    type: "object",
    additionalProperties: (_a22 = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a22 : refs.allowedAdditionalProperties
  };
  if (((_b22 = def.keyType) == null ? void 0 : _b22._def.typeName) === ZodFirstPartyTypeKind2.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    let { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind2.ZodEnum)
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind2.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind2.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    let { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record")
    return parseRecordDef(def, refs);
  let keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(), values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}
function parseNativeEnumDef(def) {
  let object2 = def.values, actualValues = Object.keys(def.values).filter((key) => {
    return typeof object2[object2[key]] !== "number";
  }).map((key) => object2[key]), parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
function parseNeverDef() {
  return { not: parseAnyDef() };
}
function parseNullDef() {
  return {
    type: "null"
  };
}
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  let options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => (x._def.typeName in primitiveMappings) && (!x._def.checks || !x._def.checks.length))) {
    let types = options.reduce((types2, x) => {
      let type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    let types = options.reduce((acc, x) => {
      let type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      let uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  let anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length))
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  let base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
function parseNumberDef(def) {
  let res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (let check2 of def.checks)
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check2.inclusive)
          res.minimum = check2.value;
        else
          res.exclusiveMinimum = check2.value;
        break;
      case "max":
        if (check2.inclusive)
          res.maximum = check2.value;
        else
          res.exclusiveMaximum = check2.value;
        break;
      case "multipleOf":
        res.multipleOf = check2.value;
        break;
    }
  return res;
}
function parseObjectDef(def, refs) {
  let result = {
    type: "object",
    properties: {}
  }, required2 = [], shape = def.shape();
  for (let propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0)
      continue;
    let propOptional = safeIsOptional(propDef), parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0)
      continue;
    if (result.properties[propName] = parsedDef, !propOptional)
      required2.push(propName);
  }
  if (required2.length)
    result.required = required2;
  let additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0)
    result.additionalProperties = additionalProperties;
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever")
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return !0;
  }
}
var parseOptionalDef = (def, refs) => {
  var _a22;
  if (refs.currentPath.toString() === ((_a22 = refs.propertyPath) == null ? void 0 : _a22.toString()))
    return parseDef(def.innerType._def, refs);
  let innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
}, parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input")
    return parseDef(def.in._def, refs);
  else if (refs.pipeStrategy === "output")
    return parseDef(def.out._def, refs);
  let a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  }), b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
function parseSetDef(def, refs) {
  let schema = {
    type: "array",
    uniqueItems: !0,
    items: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    })
  };
  if (def.minSize)
    schema.minItems = def.minSize.value;
  if (def.maxSize)
    schema.maxItems = def.maxSize.value;
  return schema;
}
function parseTupleDef(def, refs) {
  if (def.rest)
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  else
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
}
function parseUndefinedDef() {
  return {
    not: parseAnyDef()
  };
}
function parseUnknownDef() {
  return parseAnyDef();
}
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
}, selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind2.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodNumber:
      return parseNumberDef(def);
    case ZodFirstPartyTypeKind2.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodBigInt:
      return parseBigintDef(def);
    case ZodFirstPartyTypeKind2.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind2.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind2.ZodNull:
      return parseNullDef();
    case ZodFirstPartyTypeKind2.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodUnion:
    case ZodFirstPartyTypeKind2.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodLiteral:
      return parseLiteralDef(def);
    case ZodFirstPartyTypeKind2.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind2.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind2.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind2.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodNaN:
    case ZodFirstPartyTypeKind2.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind2.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind2.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind2.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind2.ZodFunction:
    case ZodFirstPartyTypeKind2.ZodVoid:
    case ZodFirstPartyTypeKind2.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((_) => {
        return;
      })(typeName);
  }
}, getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (;i < pathA.length && i < pathB.length; i++)
    if (pathA[i] !== pathB[i])
      break;
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
function parseDef(def, refs, forceResolution = !1) {
  var _a22;
  let seenItem = refs.seen.get(def);
  if (refs.override) {
    let overrideResult = (_a22 = refs.override) == null ? void 0 : _a22.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride)
      return overrideResult;
  }
  if (seenItem && !forceResolution) {
    let seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0)
      return seenSchema;
  }
  let newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  let jsonSchemaOrGetter = selectParser(def, def.typeName, refs), jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema2)
    addMeta(def, refs, jsonSchema2);
  if (refs.postProcess) {
    let postProcessResult = refs.postProcess(jsonSchema2, def, refs);
    return newItem.jsonSchema = jsonSchema2, postProcessResult;
  }
  return newItem.jsonSchema = jsonSchema2, jsonSchema2;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value))
        return console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`), parseAnyDef();
      return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
    }
  }
}, addMeta = (def, refs, jsonSchema2) => {
  if (def.description)
    jsonSchema2.description = def.description;
  return jsonSchema2;
}, getRefs = (options) => {
  let _options = getDefaultOptions(options), currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name22, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name22],
        jsonSchema: void 0
      }
    ]))
  };
}, zod3ToJsonSchema = (schema, options) => {
  var _a22;
  let refs = getRefs(options), definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name32, schema2]) => {
    var _a32;
    return {
      ...acc,
      [name32]: (_a32 = parseDef(schema2._def, {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name32]
      }, !0)) != null ? _a32 : parseAnyDef()
    };
  }, {}) : void 0, name22 = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name, main = (_a22 = parseDef(schema._def, name22 === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name22]
  }, !1)) != null ? _a22 : parseAnyDef(), title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0)
    main.title = title;
  let combined = name22 === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name22
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name22]: main
    }
  };
  return combined.$schema = "http://json-schema.org/draft-07/schema#", combined;
}, schemaSymbol = Symbol.for("vercel.ai.schema");
function lazySchema(createSchema) {
  let schema;
  return () => {
    if (schema == null)
      schema = createSchema();
    return schema;
  };
}
function jsonSchema(jsonSchema2, {
  validate
} = {}) {
  return {
    [schemaSymbol]: !0,
    _type: void 0,
    get jsonSchema() {
      if (typeof jsonSchema2 === "function")
        jsonSchema2 = jsonSchema2();
      return jsonSchema2;
    },
    validate
  };
}
function isSchema(value) {
  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === !0 && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
  return schema == null ? jsonSchema({ properties: {}, additionalProperties: !1 }) : isSchema(schema) ? schema : ("~standard" in schema) ? schema["~standard"].vendor === "zod" ? zodSchema(schema) : standardSchema(schema) : schema();
}
function standardSchema(standardSchema2) {
  return jsonSchema(() => addAdditionalPropertiesToJsonSchema(standardSchema2["~standard"].jsonSchema.input({
    target: "draft-07"
  })), {
    validate: async (value) => {
      let result = await standardSchema2["~standard"].validate(value);
      return "value" in result ? { success: !0, value: result.value } : {
        success: !1,
        error: new TypeValidationError({
          value,
          cause: result.issues
        })
      };
    }
  });
}
function zod3Schema(zodSchema2, options) {
  var _a22;
  let useReferences = (_a22 = options == null ? void 0 : options.useReferences) != null ? _a22 : !1;
  return jsonSchema(() => zod3ToJsonSchema(zodSchema2, {
    $refStrategy: useReferences ? "root" : "none"
  }), {
    validate: async (value) => {
      let result = await zodSchema2.safeParseAsync(value);
      return result.success ? { success: !0, value: result.data } : { success: !1, error: result.error };
    }
  });
}
function zod4Schema(zodSchema2, options) {
  var _a22;
  let useReferences = (_a22 = options == null ? void 0 : options.useReferences) != null ? _a22 : !1;
  return jsonSchema(() => addAdditionalPropertiesToJsonSchema(toJSONSchema(zodSchema2, {
    target: "draft-7",
    io: "input",
    reused: useReferences ? "ref" : "inline"
  })), {
    validate: async (value) => {
      let result = await safeParseAsync2(zodSchema2, value);
      return result.success ? { success: !0, value: result.data } : { success: !1, error: result.error };
    }
  });
}
function isZod4Schema(zodSchema2) {
  return "_zod" in zodSchema2;
}
function zodSchema(zodSchema2, options) {
  if (isZod4Schema(zodSchema2))
    return zod4Schema(zodSchema2, options);
  else
    return zod3Schema(zodSchema2, options);
}
async function validateTypes({
  value,
  schema,
  context
}) {
  let result = await safeValidateTypes({ value, schema, context });
  if (!result.success)
    throw TypeValidationError.wrap({ value, cause: result.error, context });
  return result.value;
}
async function safeValidateTypes({
  value,
  schema,
  context
}) {
  let actualSchema = asSchema(schema);
  try {
    if (actualSchema.validate == null)
      return { success: !0, value, rawValue: value };
    let result = await actualSchema.validate(value);
    if (result.success)
      return { success: !0, value: result.value, rawValue: value };
    return {
      success: !1,
      error: TypeValidationError.wrap({ value, cause: result.error, context }),
      rawValue: value
    };
  } catch (error48) {
    return {
      success: !1,
      error: TypeValidationError.wrap({ value, cause: error48, context }),
      rawValue: value
    };
  }
}
async function parseJSON({
  text,
  schema
}) {
  try {
    let value = secureJsonParse(text);
    if (schema == null)
      return value;
    return validateTypes({ value, schema });
  } catch (error48) {
    if (JSONParseError.isInstance(error48) || TypeValidationError.isInstance(error48))
      throw error48;
    throw new JSONParseError({ text, cause: error48 });
  }
}
async function safeParseJSON({
  text,
  schema
}) {
  try {
    let value = secureJsonParse(text);
    if (schema == null)
      return { success: !0, value, rawValue: value };
    return await safeValidateTypes({ value, schema });
  } catch (error48) {
    return {
      success: !1,
      error: JSONParseError.isInstance(error48) ? error48 : new JSONParseError({ text, cause: error48 }),
      rawValue: void 0
    };
  }
}
function isParsableJson(input) {
  try {
    return secureJsonParse(input), !0;
  } catch (e) {
    return !1;
  }
}
function parseJsonEventStream({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream).pipeThrough(new EventSourceParserStream).pipeThrough(new TransformStream({
    async transform({ data }, controller) {
      if (data === "[DONE]")
        return;
      controller.enqueue(await safeParseJSON({ text: data, schema }));
    }
  }));
}
async function parseProviderOptions({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null)
    return;
  let parsedProviderOptions = await safeValidateTypes({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success)
    throw new InvalidArgumentError({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  return parsedProviderOptions.value;
}
var getOriginalFetch2 = () => globalThis.fetch, postJsonToApi = async ({
  url: url2,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi({
  url: url2,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}), postFormDataToApi = async ({
  url: url2,
  headers,
  formData,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi({
  url: url2,
  headers,
  body: {
    content: formData,
    values: Object.fromEntries(formData.entries())
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}), postToApi = async ({
  url: url2,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch2()
}) => {
  try {
    let response = await fetch2(url2, {
      method: "POST",
      headers: withUserAgentSuffix(headers, `ai-sdk/provider-utils/${VERSION}`, getRuntimeEnvironmentUserAgent()),
      body: body.content,
      signal: abortSignal
    }), responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url: url2,
          requestBodyValues: body.values
        });
      } catch (error48) {
        if (isAbortError(error48) || APICallError.isInstance(error48))
          throw error48;
        throw new APICallError({
          message: "Failed to process error response",
          cause: error48,
          statusCode: response.status,
          url: url2,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url: url2,
        requestBodyValues: body.values
      });
    } catch (error48) {
      if (error48 instanceof Error) {
        if (isAbortError(error48) || APICallError.isInstance(error48))
          throw error48;
      }
      throw new APICallError({
        message: "Failed to process successful response",
        cause: error48,
        statusCode: response.status,
        url: url2,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error48) {
    throw handleFetchError({ error: error48, url: url2, requestBodyValues: body.values });
  }
};
function tool(tool2) {
  return tool2;
}
function createProviderToolFactory({
  id,
  inputSchema
}) {
  return ({
    execute,
    outputSchema,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool({
    type: "provider",
    id,
    args,
    inputSchema,
    outputSchema,
    execute,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable
  });
}
function createProviderToolFactoryWithOutputSchema({
  id,
  inputSchema,
  outputSchema,
  supportsDeferredResults
}) {
  return ({
    execute,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool({
    type: "provider",
    id,
    args,
    inputSchema,
    outputSchema,
    execute,
    needsApproval,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    supportsDeferredResults
  });
}
async function resolve(value) {
  if (typeof value === "function")
    value = value();
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url: url2, requestBodyValues }) => {
  let responseBody = await response.text(), responseHeaders = extractResponseHeaders(response);
  if (responseBody.trim() === "")
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  try {
    let parsedError = await parseJSON({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError({
        message: errorToMessage(parsedError),
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url: url2,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
}, createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
  let responseHeaders = extractResponseHeaders(response);
  if (response.body == null)
    throw new EmptyResponseBodyError({});
  return {
    responseHeaders,
    value: parseJsonEventStream({
      stream: response.body,
      schema: chunkSchema
    })
  };
}, createJsonResponseHandler = (responseSchema) => async ({ response, url: url2, requestBodyValues }) => {
  let responseBody = await response.text(), parsedResult = await safeParseJSON({
    text: responseBody,
    schema: responseSchema
  }), responseHeaders = extractResponseHeaders(response);
  if (!parsedResult.success)
    throw new APICallError({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url: url2,
      requestBodyValues
    });
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
}, createBinaryResponseHandler = () => async ({ response, url: url2, requestBodyValues }) => {
  let responseHeaders = extractResponseHeaders(response);
  if (!response.body)
    throw new APICallError({
      message: "Response body is empty",
      url: url2,
      requestBodyValues,
      statusCode: response.status,
      responseHeaders,
      responseBody: void 0
    });
  try {
    let buffer = await response.arrayBuffer();
    return {
      responseHeaders,
      value: new Uint8Array(buffer)
    };
  } catch (error48) {
    throw new APICallError({
      message: "Failed to read response as array buffer",
      url: url2,
      requestBodyValues,
      statusCode: response.status,
      responseHeaders,
      responseBody: void 0,
      cause: error48
    });
  }
};
function withoutTrailingSlash(url2) {
  return url2 == null ? void 0 : url2.replace(/\/$/, "");
}
function isAsyncIterable(obj) {
  return obj != null && typeof obj[Symbol.asyncIterator] === "function";
}
async function* executeTool({
  execute,
  input,
  options
}) {
  let result = execute(input, options);
  if (isAsyncIterable(result)) {
    let lastOutput;
    for await (let output of result)
      lastOutput = output, yield { type: "preliminary", output };
    yield { type: "final", output: lastOutput };
  } else
    yield { type: "final", output: await result };
}
// node_modules/@ai-sdk/gateway/dist/index.mjs
var import_oidc = __toESM(require_index_browser(), 1), import_oidc2 = __toESM(require_index_browser(), 1);
var marker17 = "vercel.ai.gateway.error", symbol18 = Symbol.for(marker17), _a18, _b17, GatewayError = class _GatewayError extends (_b17 = Error, _a18 = symbol18, _b17) {
  constructor({
    message,
    statusCode = 500,
    cause,
    generationId
  }) {
    super(generationId ? `${message} [${generationId}]` : message);
    this[_a18] = !0, this.statusCode = statusCode, this.cause = cause, this.generationId = generationId;
  }
  static isInstance(error48) {
    return _GatewayError.hasMarker(error48);
  }
  static hasMarker(error48) {
    return typeof error48 === "object" && error48 !== null && symbol18 in error48 && error48[symbol18] === !0;
  }
}, name16 = "GatewayAuthenticationError", marker22 = `vercel.ai.gateway.error.${name16}`, symbol22 = Symbol.for(marker22), _a22, _b22, GatewayAuthenticationError = class _GatewayAuthenticationError extends (_b22 = GatewayError, _a22 = symbol22, _b22) {
  constructor({
    message = "Authentication failed",
    statusCode = 401,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a22] = !0, this.name = name16, this.type = "authentication_error";
  }
  static isInstance(error48) {
    return GatewayError.hasMarker(error48) && symbol22 in error48;
  }
  static createContextualError({
    apiKeyProvided,
    oidcTokenProvided,
    message = "Authentication failed",
    statusCode = 401,
    cause,
    generationId
  }) {
    let contextualMessage;
    if (apiKeyProvided)
      contextualMessage = `AI Gateway authentication failed: Invalid API key.

Create a new API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys

Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.`;
    else if (oidcTokenProvided)
      contextualMessage = `AI Gateway authentication failed: Invalid OIDC token.

Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.

Alternatively, use an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys`;
    else
      contextualMessage = `AI Gateway authentication failed: No authentication provided.

Option 1 - API key:
Create an API key: https://vercel.com/d?to=%2F%5Bteam%5D%2F%7E%2Fai%2Fapi-keys
Provide via 'apiKey' option or 'AI_GATEWAY_API_KEY' environment variable.

Option 2 - OIDC token:
Run 'npx vercel link' to link your project, then 'vc env pull' to fetch the token.`;
    return new _GatewayAuthenticationError({
      message: contextualMessage,
      statusCode,
      cause,
      generationId
    });
  }
}, name22 = "GatewayInvalidRequestError", marker32 = `vercel.ai.gateway.error.${name22}`, symbol32 = Symbol.for(marker32), _a32, _b32, GatewayInvalidRequestError = class extends (_b32 = GatewayError, _a32 = symbol32, _b32) {
  constructor({
    message = "Invalid request",
    statusCode = 400,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a32] = !0, this.name = name22, this.type = "invalid_request_error";
  }
  static isInstance(error48) {
    return GatewayError.hasMarker(error48) && symbol32 in error48;
  }
}, name32 = "GatewayRateLimitError", marker42 = `vercel.ai.gateway.error.${name32}`, symbol42 = Symbol.for(marker42), _a42, _b42, GatewayRateLimitError = class extends (_b42 = GatewayError, _a42 = symbol42, _b42) {
  constructor({
    message = "Rate limit exceeded",
    statusCode = 429,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a42] = !0, this.name = name32, this.type = "rate_limit_exceeded";
  }
  static isInstance(error48) {
    return GatewayError.hasMarker(error48) && symbol42 in error48;
  }
}, name42 = "GatewayModelNotFoundError", marker52 = `vercel.ai.gateway.error.${name42}`, symbol52 = Symbol.for(marker52), modelNotFoundParamSchema = lazySchema(() => zodSchema(exports_external.object({
  modelId: exports_external.string()
}))), _a52, _b52, GatewayModelNotFoundError = class extends (_b52 = GatewayError, _a52 = symbol52, _b52) {
  constructor({
    message = "Model not found",
    statusCode = 404,
    modelId,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a52] = !0, this.name = name42, this.type = "model_not_found", this.modelId = modelId;
  }
  static isInstance(error48) {
    return GatewayError.hasMarker(error48) && symbol52 in error48;
  }
}, name52 = "GatewayInternalServerError", marker62 = `vercel.ai.gateway.error.${name52}`, symbol62 = Symbol.for(marker62), _a62, _b62, GatewayInternalServerError = class extends (_b62 = GatewayError, _a62 = symbol62, _b62) {
  constructor({
    message = "Internal server error",
    statusCode = 500,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a62] = !0, this.name = name52, this.type = "internal_server_error";
  }
  static isInstance(error48) {
    return GatewayError.hasMarker(error48) && symbol62 in error48;
  }
}, name62 = "GatewayResponseError", marker72 = `vercel.ai.gateway.error.${name62}`, symbol72 = Symbol.for(marker72), _a72, _b72, GatewayResponseError = class extends (_b72 = GatewayError, _a72 = symbol72, _b72) {
  constructor({
    message = "Invalid response from Gateway",
    statusCode = 502,
    response,
    validationError,
    cause,
    generationId
  } = {}) {
    super({ message, statusCode, cause, generationId });
    this[_a72] = !0, this.name = name62, this.type = "response_error", this.response = response, this.validationError = validationError;
  }
  static isInstance(error48) {
    return GatewayError.hasMarker(error48) && symbol72 in error48;
  }
};
async function createGatewayErrorFromResponse({
  response,
  statusCode,
  defaultMessage = "Gateway request failed",
  cause,
  authMethod
}) {
  var _a82;
  let parseResult = await safeValidateTypes({
    value: response,
    schema: gatewayErrorResponseSchema
  });
  if (!parseResult.success) {
    let rawGenerationId = typeof response === "object" && response !== null && "generationId" in response ? response.generationId : void 0;
    return new GatewayResponseError({
      message: `Invalid error response format: ${defaultMessage}`,
      statusCode,
      response,
      validationError: parseResult.error,
      cause,
      generationId: rawGenerationId
    });
  }
  let validatedResponse = parseResult.value, errorType = validatedResponse.error.type, message = validatedResponse.error.message, generationId = (_a82 = validatedResponse.generationId) != null ? _a82 : void 0;
  switch (errorType) {
    case "authentication_error":
      return GatewayAuthenticationError.createContextualError({
        apiKeyProvided: authMethod === "api-key",
        oidcTokenProvided: authMethod === "oidc",
        statusCode,
        cause,
        generationId
      });
    case "invalid_request_error":
      return new GatewayInvalidRequestError({
        message,
        statusCode,
        cause,
        generationId
      });
    case "rate_limit_exceeded":
      return new GatewayRateLimitError({
        message,
        statusCode,
        cause,
        generationId
      });
    case "model_not_found": {
      let modelResult = await safeValidateTypes({
        value: validatedResponse.error.param,
        schema: modelNotFoundParamSchema
      });
      return new GatewayModelNotFoundError({
        message,
        statusCode,
        modelId: modelResult.success ? modelResult.value.modelId : void 0,
        cause,
        generationId
      });
    }
    case "internal_server_error":
      return new GatewayInternalServerError({
        message,
        statusCode,
        cause,
        generationId
      });
    default:
      return new GatewayInternalServerError({
        message,
        statusCode,
        cause,
        generationId
      });
  }
}
var gatewayErrorResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  error: exports_external.object({
    message: exports_external.string(),
    type: exports_external.string().nullish(),
    param: exports_external.unknown().nullish(),
    code: exports_external.union([exports_external.string(), exports_external.number()]).nullish()
  }),
  generationId: exports_external.string().nullish()
})));
function asGatewayError(error48, authMethod) {
  var _a82;
  if (GatewayError.isInstance(error48))
    return error48;
  if (APICallError.isInstance(error48))
    return createGatewayErrorFromResponse({
      response: extractApiCallResponse(error48),
      statusCode: (_a82 = error48.statusCode) != null ? _a82 : 500,
      defaultMessage: "Gateway request failed",
      cause: error48,
      authMethod
    });
  return createGatewayErrorFromResponse({
    response: {},
    statusCode: 500,
    defaultMessage: error48 instanceof Error ? `Gateway request failed: ${error48.message}` : "Unknown Gateway error",
    cause: error48,
    authMethod
  });
}
function extractApiCallResponse(error48) {
  if (error48.data !== void 0)
    return error48.data;
  if (error48.responseBody != null)
    try {
      return JSON.parse(error48.responseBody);
    } catch (e) {
      return error48.responseBody;
    }
  return {};
}
var GATEWAY_AUTH_METHOD_HEADER = "ai-gateway-auth-method";
async function parseAuthMethod(headers) {
  let result = await safeValidateTypes({
    value: headers[GATEWAY_AUTH_METHOD_HEADER],
    schema: gatewayAuthMethodSchema
  });
  return result.success ? result.value : void 0;
}
var gatewayAuthMethodSchema = lazySchema(() => zodSchema(exports_external.union([exports_external.literal("api-key"), exports_external.literal("oidc")]))), GatewayFetchMetadata = class {
  constructor(config2) {
    this.config = config2;
  }
  async getAvailableModels() {
    try {
      let { value } = await getFromApi({
        url: `${this.config.baseURL}/config`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler(gatewayAvailableModelsResponseSchema),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error48) {
      throw await asGatewayError(error48);
    }
  }
  async getCredits() {
    try {
      let baseUrl = new URL(this.config.baseURL), { value } = await getFromApi({
        url: `${baseUrl.origin}/v1/credits`,
        headers: await resolve(this.config.headers()),
        successfulResponseHandler: createJsonResponseHandler(gatewayCreditsResponseSchema),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        fetch: this.config.fetch
      });
      return value;
    } catch (error48) {
      throw await asGatewayError(error48);
    }
  }
}, gatewayAvailableModelsResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  models: exports_external.array(exports_external.object({
    id: exports_external.string(),
    name: exports_external.string(),
    description: exports_external.string().nullish(),
    pricing: exports_external.object({
      input: exports_external.string(),
      output: exports_external.string(),
      input_cache_read: exports_external.string().nullish(),
      input_cache_write: exports_external.string().nullish()
    }).transform(({ input, output, input_cache_read, input_cache_write }) => ({
      input,
      output,
      ...input_cache_read ? { cachedInputTokens: input_cache_read } : {},
      ...input_cache_write ? { cacheCreationInputTokens: input_cache_write } : {}
    })).nullish(),
    specification: exports_external.object({
      specificationVersion: exports_external.literal("v3"),
      provider: exports_external.string(),
      modelId: exports_external.string()
    }),
    modelType: exports_external.enum(["language", "embedding", "image"]).nullish()
  }))
}))), gatewayCreditsResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  balance: exports_external.string(),
  total_used: exports_external.string()
}).transform(({ balance, total_used }) => ({
  balance,
  totalUsed: total_used
})))), GatewayLanguageModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId, this.config = config2, this.specificationVersion = "v3", this.supportedUrls = { "*/*": [/.*/] };
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs(options) {
    let { abortSignal: _abortSignal, ...optionsWithoutSignal } = options;
    return {
      args: this.maybeEncodeFileParts(optionsWithoutSignal),
      warnings: []
    };
  }
  async doGenerate(options) {
    let { args, warnings } = await this.getArgs(options), { abortSignal } = options, resolvedHeaders = await resolve(this.config.headers());
    try {
      let {
        responseHeaders,
        value: responseBody,
        rawValue: rawResponse
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, !1), await resolve(this.config.o11yHeaders)),
        body: args,
        successfulResponseHandler: createJsonResponseHandler(exports_external.any()),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        ...responseBody,
        request: { body: args },
        response: { headers: responseHeaders, body: rawResponse },
        warnings
      };
    } catch (error48) {
      throw await asGatewayError(error48, await parseAuthMethod(resolvedHeaders));
    }
  }
  async doStream(options) {
    let { args, warnings } = await this.getArgs(options), { abortSignal } = options, resolvedHeaders = await resolve(this.config.headers());
    try {
      let { value: response, responseHeaders } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(resolvedHeaders, options.headers, this.getModelConfigHeaders(this.modelId, !0), await resolve(this.config.o11yHeaders)),
        body: args,
        successfulResponseHandler: createEventSourceResponseHandler(exports_external.any()),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        stream: response.pipeThrough(new TransformStream({
          start(controller) {
            if (warnings.length > 0)
              controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            if (chunk.success) {
              let streamPart = chunk.value;
              if (streamPart.type === "raw" && !options.includeRawChunks)
                return;
              if (streamPart.type === "response-metadata" && streamPart.timestamp && typeof streamPart.timestamp === "string")
                streamPart.timestamp = new Date(streamPart.timestamp);
              controller.enqueue(streamPart);
            } else
              controller.error(chunk.error);
          }
        })),
        request: { body: args },
        response: { headers: responseHeaders }
      };
    } catch (error48) {
      throw await asGatewayError(error48, await parseAuthMethod(resolvedHeaders));
    }
  }
  isFilePart(part) {
    return part && typeof part === "object" && "type" in part && part.type === "file";
  }
  maybeEncodeFileParts(options) {
    for (let message of options.prompt)
      for (let part of message.content)
        if (this.isFilePart(part)) {
          let filePart = part;
          if (filePart.data instanceof Uint8Array) {
            let buffer = Uint8Array.from(filePart.data), base64Data = Buffer.from(buffer).toString("base64");
            filePart.data = new URL(`data:${filePart.mediaType || "application/octet-stream"};base64,${base64Data}`);
          }
        }
    return options;
  }
  getUrl() {
    return `${this.config.baseURL}/language-model`;
  }
  getModelConfigHeaders(modelId, streaming) {
    return {
      "ai-language-model-specification-version": "3",
      "ai-language-model-id": modelId,
      "ai-language-model-streaming": String(streaming)
    };
  }
}, GatewayEmbeddingModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId, this.config = config2, this.specificationVersion = "v3", this.maxEmbeddingsPerCall = 2048, this.supportsParallelCalls = !0;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a82;
    let resolvedHeaders = await resolve(this.config.headers());
    try {
      let {
        responseHeaders,
        value: responseBody,
        rawValue
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve(this.config.o11yHeaders)),
        body: {
          values,
          ...providerOptions ? { providerOptions } : {}
        },
        successfulResponseHandler: createJsonResponseHandler(gatewayEmbeddingResponseSchema),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        embeddings: responseBody.embeddings,
        usage: (_a82 = responseBody.usage) != null ? _a82 : void 0,
        providerMetadata: responseBody.providerMetadata,
        response: { headers: responseHeaders, body: rawValue },
        warnings: []
      };
    } catch (error48) {
      throw await asGatewayError(error48, await parseAuthMethod(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/embedding-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-embedding-model-specification-version": "3",
      "ai-model-id": this.modelId
    };
  }
}, gatewayEmbeddingResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  embeddings: exports_external.array(exports_external.array(exports_external.number())),
  usage: exports_external.object({ tokens: exports_external.number() }).nullish(),
  providerMetadata: exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), exports_external.unknown())).optional()
}))), GatewayImageModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId, this.config = config2, this.specificationVersion = "v3", this.maxImagesPerCall = Number.MAX_SAFE_INTEGER;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    files,
    mask,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a82;
    let resolvedHeaders = await resolve(this.config.headers());
    try {
      let {
        responseHeaders,
        value: responseBody,
        rawValue
      } = await postJsonToApi({
        url: this.getUrl(),
        headers: combineHeaders(resolvedHeaders, headers != null ? headers : {}, this.getModelConfigHeaders(), await resolve(this.config.o11yHeaders)),
        body: {
          prompt,
          n,
          ...size && { size },
          ...aspectRatio && { aspectRatio },
          ...seed && { seed },
          ...providerOptions && { providerOptions },
          ...files && {
            files: files.map((file2) => maybeEncodeImageFile(file2))
          },
          ...mask && { mask: maybeEncodeImageFile(mask) }
        },
        successfulResponseHandler: createJsonResponseHandler(gatewayImageResponseSchema),
        failedResponseHandler: createJsonErrorResponseHandler({
          errorSchema: exports_external.any(),
          errorToMessage: (data) => data
        }),
        ...abortSignal && { abortSignal },
        fetch: this.config.fetch
      });
      return {
        images: responseBody.images,
        warnings: (_a82 = responseBody.warnings) != null ? _a82 : [],
        providerMetadata: responseBody.providerMetadata,
        response: {
          timestamp: /* @__PURE__ */ new Date,
          modelId: this.modelId,
          headers: responseHeaders
        }
      };
    } catch (error48) {
      throw asGatewayError(error48, await parseAuthMethod(resolvedHeaders));
    }
  }
  getUrl() {
    return `${this.config.baseURL}/image-model`;
  }
  getModelConfigHeaders() {
    return {
      "ai-image-model-specification-version": "3",
      "ai-model-id": this.modelId
    };
  }
};
function maybeEncodeImageFile(file2) {
  if (file2.type === "file" && file2.data instanceof Uint8Array)
    return {
      ...file2,
      data: convertUint8ArrayToBase64(file2.data)
    };
  return file2;
}
var providerMetadataEntrySchema = exports_external.object({
  images: exports_external.array(exports_external.unknown()).optional()
}).catchall(exports_external.unknown()), gatewayImageResponseSchema = exports_external.object({
  images: exports_external.array(exports_external.string()),
  warnings: exports_external.array(exports_external.object({
    type: exports_external.literal("other"),
    message: exports_external.string()
  })).optional(),
  providerMetadata: exports_external.record(exports_external.string(), providerMetadataEntrySchema).optional()
}), parallelSearchInputSchema = lazySchema(() => zodSchema(exports_external.object({
  objective: exports_external.string().describe("Natural-language description of the web research goal, including source or freshness guidance and broader context from the task. Maximum 5000 characters."),
  search_queries: exports_external.array(exports_external.string()).optional().describe("Optional search queries to supplement the objective. Maximum 200 characters per query."),
  mode: exports_external.enum(["one-shot", "agentic"]).optional().describe('Mode preset: "one-shot" for comprehensive results with longer excerpts (default), "agentic" for concise, token-efficient results for multi-step workflows.'),
  max_results: exports_external.number().optional().describe("Maximum number of results to return (1-20). Defaults to 10 if not specified."),
  source_policy: exports_external.object({
    include_domains: exports_external.array(exports_external.string()).optional().describe("List of domains to include in search results."),
    exclude_domains: exports_external.array(exports_external.string()).optional().describe("List of domains to exclude from search results."),
    after_date: exports_external.string().optional().describe("Only include results published after this date (ISO 8601 format).")
  }).optional().describe("Source policy for controlling which domains to include/exclude and freshness."),
  excerpts: exports_external.object({
    max_chars_per_result: exports_external.number().optional().describe("Maximum characters per result."),
    max_chars_total: exports_external.number().optional().describe("Maximum total characters across all results.")
  }).optional().describe("Excerpt configuration for controlling result length."),
  fetch_policy: exports_external.object({
    max_age_seconds: exports_external.number().optional().describe("Maximum age in seconds for cached content. Set to 0 to always fetch fresh content.")
  }).optional().describe("Fetch policy for controlling content freshness.")
}))), parallelSearchOutputSchema = lazySchema(() => zodSchema(exports_external.union([
  exports_external.object({
    searchId: exports_external.string(),
    results: exports_external.array(exports_external.object({
      url: exports_external.string(),
      title: exports_external.string(),
      excerpt: exports_external.string(),
      publishDate: exports_external.string().nullable().optional(),
      relevanceScore: exports_external.number().optional()
    }))
  }),
  exports_external.object({
    error: exports_external.enum([
      "api_error",
      "rate_limit",
      "timeout",
      "invalid_input",
      "configuration_error",
      "unknown"
    ]),
    statusCode: exports_external.number().optional(),
    message: exports_external.string()
  })
]))), parallelSearchToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "gateway.parallel_search",
  inputSchema: parallelSearchInputSchema,
  outputSchema: parallelSearchOutputSchema
}), parallelSearch = (config2 = {}) => parallelSearchToolFactory(config2), perplexitySearchInputSchema = lazySchema(() => zodSchema(exports_external.object({
  query: exports_external.union([exports_external.string(), exports_external.array(exports_external.string())]).describe("Search query (string) or multiple queries (array of up to 5 strings). Multi-query searches return combined results from all queries."),
  max_results: exports_external.number().optional().describe("Maximum number of search results to return (1-20, default: 10)"),
  max_tokens_per_page: exports_external.number().optional().describe("Maximum number of tokens to extract per search result page (256-2048, default: 2048)"),
  max_tokens: exports_external.number().optional().describe("Maximum total tokens across all search results (default: 25000, max: 1000000)"),
  country: exports_external.string().optional().describe("Two-letter ISO 3166-1 alpha-2 country code for regional search results (e.g., 'US', 'GB', 'FR')"),
  search_domain_filter: exports_external.array(exports_external.string()).optional().describe("List of domains to include or exclude from search results (max 20). To include: ['nature.com', 'science.org']. To exclude: ['-example.com', '-spam.net']"),
  search_language_filter: exports_external.array(exports_external.string()).optional().describe("List of ISO 639-1 language codes to filter results (max 10, lowercase). Examples: ['en', 'fr', 'de']"),
  search_after_date: exports_external.string().optional().describe("Include only results published after this date. Format: 'MM/DD/YYYY' (e.g., '3/1/2025'). Cannot be used with search_recency_filter."),
  search_before_date: exports_external.string().optional().describe("Include only results published before this date. Format: 'MM/DD/YYYY' (e.g., '3/15/2025'). Cannot be used with search_recency_filter."),
  last_updated_after_filter: exports_external.string().optional().describe("Include only results last updated after this date. Format: 'MM/DD/YYYY' (e.g., '3/1/2025'). Cannot be used with search_recency_filter."),
  last_updated_before_filter: exports_external.string().optional().describe("Include only results last updated before this date. Format: 'MM/DD/YYYY' (e.g., '3/15/2025'). Cannot be used with search_recency_filter."),
  search_recency_filter: exports_external.enum(["day", "week", "month", "year"]).optional().describe("Filter results by relative time period. Cannot be used with search_after_date or search_before_date.")
}))), perplexitySearchOutputSchema = lazySchema(() => zodSchema(exports_external.union([
  exports_external.object({
    results: exports_external.array(exports_external.object({
      title: exports_external.string(),
      url: exports_external.string(),
      snippet: exports_external.string(),
      date: exports_external.string().optional(),
      lastUpdated: exports_external.string().optional()
    })),
    id: exports_external.string()
  }),
  exports_external.object({
    error: exports_external.enum([
      "api_error",
      "rate_limit",
      "timeout",
      "invalid_input",
      "unknown"
    ]),
    statusCode: exports_external.number().optional(),
    message: exports_external.string()
  })
]))), perplexitySearchToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "gateway.perplexity_search",
  inputSchema: perplexitySearchInputSchema,
  outputSchema: perplexitySearchOutputSchema
}), perplexitySearch = (config2 = {}) => perplexitySearchToolFactory(config2), gatewayTools = {
  parallelSearch,
  perplexitySearch
};
async function getVercelRequestId() {
  var _a82;
  return (_a82 = import_oidc.getContext().headers) == null ? void 0 : _a82["x-vercel-id"];
}
var VERSION2 = "3.0.32", AI_GATEWAY_PROTOCOL_VERSION = "0.0.1";
function createGatewayProvider(options = {}) {
  var _a82, _b82;
  let pendingMetadata = null, metadataCache = null, cacheRefreshMillis = (_a82 = options.metadataCacheRefreshMillis) != null ? _a82 : 300000, lastFetchTime = 0, baseURL = (_b82 = withoutTrailingSlash(options.baseURL)) != null ? _b82 : "https://ai-gateway.vercel.sh/v3/ai", getHeaders = async () => {
    try {
      let auth = await getGatewayAuthToken(options);
      return withUserAgentSuffix({
        Authorization: `Bearer ${auth.token}`,
        "ai-gateway-protocol-version": AI_GATEWAY_PROTOCOL_VERSION,
        [GATEWAY_AUTH_METHOD_HEADER]: auth.authMethod,
        ...options.headers
      }, `ai-sdk/gateway/${VERSION2}`);
    } catch (error48) {
      throw GatewayAuthenticationError.createContextualError({
        apiKeyProvided: !1,
        oidcTokenProvided: !1,
        statusCode: 401,
        cause: error48
      });
    }
  }, createO11yHeaders = () => {
    let deploymentId = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_DEPLOYMENT_ID"
    }), environment = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_ENV"
    }), region = loadOptionalSetting({
      settingValue: void 0,
      environmentVariableName: "VERCEL_REGION"
    });
    return async () => {
      let requestId = await getVercelRequestId();
      return {
        ...deploymentId && { "ai-o11y-deployment-id": deploymentId },
        ...environment && { "ai-o11y-environment": environment },
        ...region && { "ai-o11y-region": region },
        ...requestId && { "ai-o11y-request-id": requestId }
      };
    };
  }, createLanguageModel = (modelId) => {
    return new GatewayLanguageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  }, getAvailableModels = async () => {
    var _a92, _b92, _c;
    let now = (_c = (_b92 = (_a92 = options._internal) == null ? void 0 : _a92.currentDate) == null ? void 0 : _b92.call(_a92).getTime()) != null ? _c : Date.now();
    if (!pendingMetadata || now - lastFetchTime > cacheRefreshMillis)
      lastFetchTime = now, pendingMetadata = new GatewayFetchMetadata({
        baseURL,
        headers: getHeaders,
        fetch: options.fetch
      }).getAvailableModels().then((metadata) => {
        return metadataCache = metadata, metadata;
      }).catch(async (error48) => {
        throw await asGatewayError(error48, await parseAuthMethod(await getHeaders()));
      });
    return metadataCache ? Promise.resolve(metadataCache) : pendingMetadata;
  }, getCredits = async () => {
    return new GatewayFetchMetadata({
      baseURL,
      headers: getHeaders,
      fetch: options.fetch
    }).getCredits().catch(async (error48) => {
      throw await asGatewayError(error48, await parseAuthMethod(await getHeaders()));
    });
  }, provider = function(modelId) {
    if (new.target)
      throw Error("The Gateway Provider model function cannot be called with the new keyword.");
    return createLanguageModel(modelId);
  };
  provider.specificationVersion = "v3", provider.getAvailableModels = getAvailableModels, provider.getCredits = getCredits, provider.imageModel = (modelId) => {
    return new GatewayImageModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  }, provider.languageModel = createLanguageModel;
  let createEmbeddingModel = (modelId) => {
    return new GatewayEmbeddingModel(modelId, {
      provider: "gateway",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      o11yHeaders: createO11yHeaders()
    });
  };
  return provider.embeddingModel = createEmbeddingModel, provider.textEmbeddingModel = createEmbeddingModel, provider.tools = gatewayTools, provider;
}
var gateway = createGatewayProvider();
async function getGatewayAuthToken(options) {
  let apiKey = loadOptionalSetting({
    settingValue: options.apiKey,
    environmentVariableName: "AI_GATEWAY_API_KEY"
  });
  if (apiKey)
    return {
      token: apiKey,
      authMethod: "api-key"
    };
  return {
    token: await import_oidc2.getVercelOidcToken(),
    authMethod: "oidc"
  };
}

// node_modules/@opentelemetry/api/build/esm/platform/browser/globalThis.js
var _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION3 = "1.9.0";

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]), rejectedVersions = /* @__PURE__ */ new Set, myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch)
    return function() {
      return !1;
    };
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null)
    return function(globalVersion) {
      return globalVersion === ownVersion;
    };
  function _reject(v) {
    return rejectedVersions.add(v), !1;
  }
  function _accept(v) {
    return acceptedVersions.add(v), !0;
  }
  return function(globalVersion) {
    if (acceptedVersions.has(globalVersion))
      return !0;
    if (rejectedVersions.has(globalVersion))
      return !1;
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch)
      return _reject(globalVersion);
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null)
      return _reject(globalVersion);
    if (ownVersionParsed.major !== globalVersionParsed.major)
      return _reject(globalVersion);
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch)
        return _accept(globalVersion);
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor)
      return _accept(globalVersion);
    return _reject(globalVersion);
  };
}
var isCompatible = _makeCompatibilityCheck(VERSION3);

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
var major = VERSION3.split(".")[0], GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major), _global = _globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
  var _a16;
  if (allowOverride === void 0)
    allowOverride = !1;
  var api2 = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a16 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a16 !== void 0 ? _a16 : {
    version: VERSION3
  };
  if (!allowOverride && api2[type]) {
    var err = Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    return diag.error(err.stack || err.message), !1;
  }
  if (api2.version !== VERSION3) {
    var err = Error("@opentelemetry/api: Registration of version v" + api2.version + " for " + type + " does not match previously registered API v" + VERSION3);
    return diag.error(err.stack || err.message), !1;
  }
  return api2[type] = instance, diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION3 + "."), !0;
}
function getGlobal(type) {
  var _a16, _b16, globalVersion = (_a16 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a16 === void 0 ? void 0 : _a16.version;
  if (!globalVersion || !isCompatible(globalVersion))
    return;
  return (_b16 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b16 === void 0 ? void 0 : _b16[type];
}
function unregisterGlobal(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION3 + ".");
  var api2 = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api2)
    delete api2[type];
}

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error48) {
    e = { error: error48 };
  } finally {
    try {
      if (r && !r.done && (m = i.return))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}, __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) {
    for (var i = 0, l = from.length, ar;i < l; i++)
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}, DiagComponentLogger = function() {
  function DiagComponentLogger2(props) {
    this._namespace = props.namespace || "DiagComponentLogger";
  }
  return DiagComponentLogger2.prototype.debug = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++)
      args[_i] = arguments[_i];
    return logProxy("debug", this._namespace, args);
  }, DiagComponentLogger2.prototype.error = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++)
      args[_i] = arguments[_i];
    return logProxy("error", this._namespace, args);
  }, DiagComponentLogger2.prototype.info = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++)
      args[_i] = arguments[_i];
    return logProxy("info", this._namespace, args);
  }, DiagComponentLogger2.prototype.warn = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++)
      args[_i] = arguments[_i];
    return logProxy("warn", this._namespace, args);
  }, DiagComponentLogger2.prototype.verbose = function() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++)
      args[_i] = arguments[_i];
    return logProxy("verbose", this._namespace, args);
  }, DiagComponentLogger2;
}();
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger)
    return;
  return args.unshift(namespace), logger[funcName].apply(logger, __spreadArray([], __read(args), !1));
}

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
(function(DiagLogLevel2) {
  DiagLogLevel2[DiagLogLevel2.NONE = 0] = "NONE", DiagLogLevel2[DiagLogLevel2.ERROR = 30] = "ERROR", DiagLogLevel2[DiagLogLevel2.WARN = 50] = "WARN", DiagLogLevel2[DiagLogLevel2.INFO = 60] = "INFO", DiagLogLevel2[DiagLogLevel2.DEBUG = 70] = "DEBUG", DiagLogLevel2[DiagLogLevel2.VERBOSE = 80] = "VERBOSE", DiagLogLevel2[DiagLogLevel2.ALL = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE)
    maxLevel = DiagLogLevel.NONE;
  else if (maxLevel > DiagLogLevel.ALL)
    maxLevel = DiagLogLevel.ALL;
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel)
      return theFunc.bind(logger);
    return function() {};
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error48) {
    e = { error: error48 };
  } finally {
    try {
      if (r && !r.done && (m = i.return))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}, __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) {
    for (var i = 0, l = from.length, ar;i < l; i++)
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}, API_NAME = "diag", DiagAPI = function() {
  function DiagAPI2() {
    function _logProxy(funcName) {
      return function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++)
          args[_i] = arguments[_i];
        var logger = getGlobal("diag");
        if (!logger)
          return;
        return logger[funcName].apply(logger, __spreadArray2([], __read2(args), !1));
      };
    }
    var self2 = this, setLogger = function(logger, optionsOrLogLevel) {
      var _a16, _b16, _c;
      if (optionsOrLogLevel === void 0)
        optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
      if (logger === self2) {
        var err = Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
        return self2.error((_a16 = err.stack) !== null && _a16 !== void 0 ? _a16 : err.message), !1;
      }
      if (typeof optionsOrLogLevel === "number")
        optionsOrLogLevel = {
          logLevel: optionsOrLogLevel
        };
      var oldLogger = getGlobal("diag"), newLogger = createLogLevelDiagLogger((_b16 = optionsOrLogLevel.logLevel) !== null && _b16 !== void 0 ? _b16 : DiagLogLevel.INFO, logger);
      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
        var stack = (_c = Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
        oldLogger.warn("Current logger will be overwritten from " + stack), newLogger.warn("Current logger will overwrite one already registered from " + stack);
      }
      return registerGlobal("diag", newLogger, self2, !0);
    };
    self2.setLogger = setLogger, self2.disable = function() {
      unregisterGlobal(API_NAME, self2);
    }, self2.createComponentLogger = function(options) {
      return new DiagComponentLogger(options);
    }, self2.verbose = _logProxy("verbose"), self2.debug = _logProxy("debug"), self2.info = _logProxy("info"), self2.warn = _logProxy("warn"), self2.error = _logProxy("error");
  }
  return DiagAPI2.instance = function() {
    if (!this._instance)
      this._instance = new DiagAPI2;
    return this._instance;
  }, DiagAPI2;
}();

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext = function() {
  function BaseContext2(parentContext) {
    var self2 = this;
    self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map, self2.getValue = function(key) {
      return self2._currentContext.get(key);
    }, self2.setValue = function(key, value) {
      var context = new BaseContext2(self2._currentContext);
      return context._currentContext.set(key, value), context;
    }, self2.deleteValue = function(key) {
      var context = new BaseContext2(self2._currentContext);
      return context._currentContext.delete(key), context;
    };
  }
  return BaseContext2;
}(), ROOT_CONTEXT = new BaseContext;

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error48) {
    e = { error: error48 };
  } finally {
    try {
      if (r && !r.done && (m = i.return))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}, __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2) {
    for (var i = 0, l = from.length, ar;i < l; i++)
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}, NoopContextManager = function() {
  function NoopContextManager2() {}
  return NoopContextManager2.prototype.active = function() {
    return ROOT_CONTEXT;
  }, NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
    var args = [];
    for (var _i = 3;_i < arguments.length; _i++)
      args[_i - 3] = arguments[_i];
    return fn.call.apply(fn, __spreadArray3([thisArg], __read3(args), !1));
  }, NoopContextManager2.prototype.bind = function(_context, target) {
    return target;
  }, NoopContextManager2.prototype.enable = function() {
    return this;
  }, NoopContextManager2.prototype.disable = function() {
    return this;
  }, NoopContextManager2;
}();

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error48) {
    e = { error: error48 };
  } finally {
    try {
      if (r && !r.done && (m = i.return))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}, __spreadArray4 = function(to, from, pack) {
  if (pack || arguments.length === 2) {
    for (var i = 0, l = from.length, ar;i < l; i++)
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}, API_NAME2 = "context", NOOP_CONTEXT_MANAGER = new NoopContextManager, ContextAPI = function() {
  function ContextAPI2() {}
  return ContextAPI2.getInstance = function() {
    if (!this._instance)
      this._instance = new ContextAPI2;
    return this._instance;
  }, ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
    return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
  }, ContextAPI2.prototype.active = function() {
    return this._getContextManager().active();
  }, ContextAPI2.prototype.with = function(context, fn, thisArg) {
    var _a16, args = [];
    for (var _i = 3;_i < arguments.length; _i++)
      args[_i - 3] = arguments[_i];
    return (_a16 = this._getContextManager()).with.apply(_a16, __spreadArray4([context, fn, thisArg], __read4(args), !1));
  }, ContextAPI2.prototype.bind = function(context, target) {
    return this._getContextManager().bind(context, target);
  }, ContextAPI2.prototype._getContextManager = function() {
    return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
  }, ContextAPI2.prototype.disable = function() {
    this._getContextManager().disable(), unregisterGlobal(API_NAME2, DiagAPI.instance());
  }, ContextAPI2;
}();

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
(function(TraceFlags2) {
  TraceFlags2[TraceFlags2.NONE = 0] = "NONE", TraceFlags2[TraceFlags2.SAMPLED = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID = "0000000000000000", INVALID_TRACEID = "00000000000000000000000000000000", INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE
};

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan = function() {
  function NonRecordingSpan2(_spanContext) {
    if (_spanContext === void 0)
      _spanContext = INVALID_SPAN_CONTEXT;
    this._spanContext = _spanContext;
  }
  return NonRecordingSpan2.prototype.spanContext = function() {
    return this._spanContext;
  }, NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
    return this;
  }, NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
    return this;
  }, NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
    return this;
  }, NonRecordingSpan2.prototype.addLink = function(_link) {
    return this;
  }, NonRecordingSpan2.prototype.addLinks = function(_links) {
    return this;
  }, NonRecordingSpan2.prototype.setStatus = function(_status) {
    return this;
  }, NonRecordingSpan2.prototype.updateName = function(_name) {
    return this;
  }, NonRecordingSpan2.prototype.end = function(_endTime) {}, NonRecordingSpan2.prototype.isRecording = function() {
    return !1;
  }, NonRecordingSpan2.prototype.recordException = function(_exception, _time) {}, NonRecordingSpan2;
}();

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context) {
  return context.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context, span) {
  return context.setValue(SPAN_KEY, span);
}
function deleteSpan(context) {
  return context.deleteValue(SPAN_KEY);
}
function setSpanContext(context, spanContext) {
  return setSpan(context, new NonRecordingSpan(spanContext));
}
function getSpanContext(context) {
  var _a16;
  return (_a16 = getSpan(context)) === null || _a16 === void 0 ? void 0 : _a16.spanContext();
}

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i, VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
var contextApi = ContextAPI.getInstance(), NoopTracer = function() {
  function NoopTracer2() {}
  return NoopTracer2.prototype.startSpan = function(name15, options, context) {
    if (context === void 0)
      context = contextApi.active();
    var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
    if (root)
      return new NonRecordingSpan;
    var parentFromContext = context && getSpanContext(context);
    if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext))
      return new NonRecordingSpan(parentFromContext);
    else
      return new NonRecordingSpan;
  }, NoopTracer2.prototype.startActiveSpan = function(name15, arg2, arg3, arg4) {
    var opts, ctx, fn;
    if (arguments.length < 2)
      return;
    else if (arguments.length === 2)
      fn = arg2;
    else if (arguments.length === 3)
      opts = arg2, fn = arg3;
    else
      opts = arg2, ctx = arg3, fn = arg4;
    var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active(), span = this.startSpan(name15, opts, parentContext), contextWithSpanSet = setSpan(parentContext, span);
    return contextApi.with(contextWithSpanSet, fn, void 0, span);
  }, NoopTracer2;
}();
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext.spanId === "string" && typeof spanContext.traceId === "string" && typeof spanContext.traceFlags === "number";
}

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER = new NoopTracer, ProxyTracer = function() {
  function ProxyTracer2(_provider, name15, version2, options) {
    this._provider = _provider, this.name = name15, this.version = version2, this.options = options;
  }
  return ProxyTracer2.prototype.startSpan = function(name15, options, context) {
    return this._getTracer().startSpan(name15, options, context);
  }, ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
    var tracer = this._getTracer();
    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
  }, ProxyTracer2.prototype._getTracer = function() {
    if (this._delegate)
      return this._delegate;
    var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
    if (!tracer)
      return NOOP_TRACER;
    return this._delegate = tracer, this._delegate;
  }, ProxyTracer2;
}();

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider = function() {
  function NoopTracerProvider2() {}
  return NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
    return new NoopTracer;
  }, NoopTracerProvider2;
}();

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER = new NoopTracerProvider, ProxyTracerProvider = function() {
  function ProxyTracerProvider2() {}
  return ProxyTracerProvider2.prototype.getTracer = function(name15, version2, options) {
    var _a16;
    return (_a16 = this.getDelegateTracer(name15, version2, options)) !== null && _a16 !== void 0 ? _a16 : new ProxyTracer(this, name15, version2, options);
  }, ProxyTracerProvider2.prototype.getDelegate = function() {
    var _a16;
    return (_a16 = this._delegate) !== null && _a16 !== void 0 ? _a16 : NOOP_TRACER_PROVIDER;
  }, ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
    this._delegate = delegate;
  }, ProxyTracerProvider2.prototype.getDelegateTracer = function(name15, version2, options) {
    var _a16;
    return (_a16 = this._delegate) === null || _a16 === void 0 ? void 0 : _a16.getTracer(name15, version2, options);
  }, ProxyTracerProvider2;
}();

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
(function(SpanStatusCode2) {
  SpanStatusCode2[SpanStatusCode2.UNSET = 0] = "UNSET", SpanStatusCode2[SpanStatusCode2.OK = 1] = "OK", SpanStatusCode2[SpanStatusCode2.ERROR = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));
// node_modules/@opentelemetry/api/build/esm/context-api.js
var context = ContextAPI.getInstance();

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME3 = "trace", TraceAPI = function() {
  function TraceAPI2() {
    this._proxyTracerProvider = new ProxyTracerProvider, this.wrapSpanContext = wrapSpanContext, this.isSpanContextValid = isSpanContextValid, this.deleteSpan = deleteSpan, this.getSpan = getSpan, this.getActiveSpan = getActiveSpan, this.getSpanContext = getSpanContext, this.setSpan = setSpan, this.setSpanContext = setSpanContext;
  }
  return TraceAPI2.getInstance = function() {
    if (!this._instance)
      this._instance = new TraceAPI2;
    return this._instance;
  }, TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
    var success2 = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
    if (success2)
      this._proxyTracerProvider.setDelegate(provider);
    return success2;
  }, TraceAPI2.prototype.getTracerProvider = function() {
    return getGlobal(API_NAME3) || this._proxyTracerProvider;
  }, TraceAPI2.prototype.getTracer = function(name15, version2) {
    return this.getTracerProvider().getTracer(name15, version2);
  }, TraceAPI2.prototype.disable = function() {
    unregisterGlobal(API_NAME3, DiagAPI.instance()), this._proxyTracerProvider = new ProxyTracerProvider;
  }, TraceAPI2;
}();

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace = TraceAPI.getInstance();

// node_modules/ai/dist/index.mjs
var __defProp2 = Object.defineProperty, __export2 = (target, all) => {
  for (var name21 in all)
    __defProp2(target, name21, { get: all[name21], enumerable: !0 });
}, name17 = "AI_InvalidArgumentError", marker18 = `vercel.ai.error.${name17}`, symbol19 = Symbol.for(marker18), _a19, InvalidArgumentError2 = class extends AISDKError {
  constructor({
    parameter,
    value,
    message
  }) {
    super({
      name: name17,
      message: `Invalid argument for parameter ${parameter}: ${message}`
    });
    this[_a19] = !0, this.parameter = parameter, this.value = value;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker18);
  }
};
_a19 = symbol19;
var name23 = "AI_InvalidStreamPartError", marker23 = `vercel.ai.error.${name23}`, symbol23 = Symbol.for(marker23), _a23;
_a23 = symbol23;
var name33 = "AI_InvalidToolApprovalError", marker33 = `vercel.ai.error.${name33}`, symbol33 = Symbol.for(marker33), _a33, InvalidToolApprovalError = class extends AISDKError {
  constructor({ approvalId }) {
    super({
      name: name33,
      message: `Tool approval response references unknown approvalId: "${approvalId}". No matching tool-approval-request found in message history.`
    });
    this[_a33] = !0, this.approvalId = approvalId;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker33);
  }
};
_a33 = symbol33;
var name43 = "AI_InvalidToolInputError", marker43 = `vercel.ai.error.${name43}`, symbol43 = Symbol.for(marker43), _a43, InvalidToolInputError = class extends AISDKError {
  constructor({
    toolInput,
    toolName,
    cause,
    message = `Invalid input for tool ${toolName}: ${getErrorMessage(cause)}`
  }) {
    super({ name: name43, message, cause });
    this[_a43] = !0, this.toolInput = toolInput, this.toolName = toolName;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker43);
  }
};
_a43 = symbol43;
var name53 = "AI_ToolCallNotFoundForApprovalError", marker53 = `vercel.ai.error.${name53}`, symbol53 = Symbol.for(marker53), _a53, ToolCallNotFoundForApprovalError = class extends AISDKError {
  constructor({
    toolCallId,
    approvalId
  }) {
    super({
      name: name53,
      message: `Tool call "${toolCallId}" not found for approval request "${approvalId}".`
    });
    this[_a53] = !0, this.toolCallId = toolCallId, this.approvalId = approvalId;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker53);
  }
};
_a53 = symbol53;
var name63 = "AI_MissingToolResultsError", marker63 = `vercel.ai.error.${name63}`, symbol63 = Symbol.for(marker63), _a63, MissingToolResultsError = class extends AISDKError {
  constructor({ toolCallIds }) {
    super({
      name: name63,
      message: `Tool result${toolCallIds.length > 1 ? "s are" : " is"} missing for tool call${toolCallIds.length > 1 ? "s" : ""} ${toolCallIds.join(", ")}.`
    });
    this[_a63] = !0, this.toolCallIds = toolCallIds;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker63);
  }
};
_a63 = symbol63;
var name72 = "AI_NoImageGeneratedError", marker73 = `vercel.ai.error.${name72}`, symbol73 = Symbol.for(marker73), _a73;
_a73 = symbol73;
var name82 = "AI_NoObjectGeneratedError", marker82 = `vercel.ai.error.${name82}`, symbol82 = Symbol.for(marker82), _a82, NoObjectGeneratedError = class extends AISDKError {
  constructor({
    message = "No object generated.",
    cause,
    text: text2,
    response,
    usage,
    finishReason
  }) {
    super({ name: name82, message, cause });
    this[_a82] = !0, this.text = text2, this.response = response, this.usage = usage, this.finishReason = finishReason;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker82);
  }
};
_a82 = symbol82;
var name92 = "AI_NoOutputGeneratedError", marker92 = `vercel.ai.error.${name92}`, symbol92 = Symbol.for(marker92), _a92, NoOutputGeneratedError = class extends AISDKError {
  constructor({
    message = "No output generated.",
    cause
  } = {}) {
    super({ name: name92, message, cause });
    this[_a92] = !0;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker92);
  }
};
_a92 = symbol92;
var name102 = "AI_NoSpeechGeneratedError", marker102 = `vercel.ai.error.${name102}`, symbol102 = Symbol.for(marker102), _a102;
_a102 = symbol102;
var name112 = "AI_NoTranscriptGeneratedError", marker112 = `vercel.ai.error.${name112}`, symbol112 = Symbol.for(marker112), _a112;
_a112 = symbol112;
var name122 = "AI_NoVideoGeneratedError", marker122 = `vercel.ai.error.${name122}`, symbol122 = Symbol.for(marker122), _a122;
_a122 = symbol122;
var name132 = "AI_NoSuchToolError", marker132 = `vercel.ai.error.${name132}`, symbol132 = Symbol.for(marker132), _a132, NoSuchToolError = class extends AISDKError {
  constructor({
    toolName,
    availableTools = void 0,
    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}`
  }) {
    super({ name: name132, message });
    this[_a132] = !0, this.toolName = toolName, this.availableTools = availableTools;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker132);
  }
};
_a132 = symbol132;
var name142 = "AI_ToolCallRepairError", marker142 = `vercel.ai.error.${name142}`, symbol142 = Symbol.for(marker142), _a142, ToolCallRepairError = class extends AISDKError {
  constructor({
    cause,
    originalError,
    message = `Error repairing tool call: ${getErrorMessage(cause)}`
  }) {
    super({ name: name142, message, cause });
    this[_a142] = !0, this.originalError = originalError;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker142);
  }
};
_a142 = symbol142;
var UnsupportedModelVersionError = class extends AISDKError {
  constructor(options) {
    super({
      name: "AI_UnsupportedModelVersionError",
      message: `Unsupported model version ${options.version} for provider "${options.provider}" and model "${options.modelId}". AI SDK 5 only supports models that implement specification version "v2".`
    });
    this.version = options.version, this.provider = options.provider, this.modelId = options.modelId;
  }
}, name15 = "AI_UIMessageStreamError", marker152 = `vercel.ai.error.${name15}`, symbol152 = Symbol.for(marker152), _a152, UIMessageStreamError = class extends AISDKError {
  constructor({
    chunkType,
    chunkId,
    message
  }) {
    super({ name: name15, message });
    this[_a152] = !0, this.chunkType = chunkType, this.chunkId = chunkId;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker152);
  }
};
_a152 = symbol152;
var name162 = "AI_InvalidDataContentError", marker16 = `vercel.ai.error.${name162}`, symbol16 = Symbol.for(marker16), _a16;
_a16 = symbol16;
var name172 = "AI_InvalidMessageRoleError", marker172 = `vercel.ai.error.${name172}`, symbol172 = Symbol.for(marker172), _a172, InvalidMessageRoleError = class extends AISDKError {
  constructor({
    role,
    message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".`
  }) {
    super({ name: name172, message });
    this[_a172] = !0, this.role = role;
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker172);
  }
};
_a172 = symbol172;
var name18 = "AI_MessageConversionError", marker182 = `vercel.ai.error.${name18}`, symbol182 = Symbol.for(marker182), _a182;
_a182 = symbol182;
var name19 = "AI_RetryError", marker19 = `vercel.ai.error.${name19}`, symbol192 = Symbol.for(marker19), _a192, RetryError = class extends AISDKError {
  constructor({
    message,
    reason,
    errors: errors3
  }) {
    super({ name: name19, message });
    this[_a192] = !0, this.reason = reason, this.errors = errors3, this.lastError = errors3[errors3.length - 1];
  }
  static isInstance(error48) {
    return AISDKError.hasMarker(error48, marker19);
  }
};
_a192 = symbol192;
function formatWarning({
  warning,
  provider,
  model
}) {
  let prefix = `AI SDK Warning (${provider} / ${model}):`;
  switch (warning.type) {
    case "unsupported": {
      let message = `${prefix} The feature "${warning.feature}" is not supported.`;
      if (warning.details)
        message += ` ${warning.details}`;
      return message;
    }
    case "compatibility": {
      let message = `${prefix} The feature "${warning.feature}" is used in a compatibility mode.`;
      if (warning.details)
        message += ` ${warning.details}`;
      return message;
    }
    case "other":
      return `${prefix} ${warning.message}`;
    default:
      return `${prefix} ${JSON.stringify(warning, null, 2)}`;
  }
}
var FIRST_WARNING_INFO_MESSAGE = "AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.", hasLoggedBefore = !1, logWarnings = (options) => {
  if (options.warnings.length === 0)
    return;
  let logger = globalThis.AI_SDK_LOG_WARNINGS;
  if (logger === !1)
    return;
  if (typeof logger === "function") {
    logger(options);
    return;
  }
  if (!hasLoggedBefore)
    hasLoggedBefore = !0, console.info(FIRST_WARNING_INFO_MESSAGE);
  for (let warning of options.warnings)
    console.warn(formatWarning({
      warning,
      provider: options.provider,
      model: options.model
    }));
};
function logV2CompatibilityWarning({
  provider,
  modelId
}) {
  logWarnings({
    warnings: [
      {
        type: "compatibility",
        feature: "specificationVersion",
        details: "Using v2 specification compatibility mode. Some features may not be available."
      }
    ],
    provider,
    model: modelId
  });
}
function asLanguageModelV3(model) {
  if (model.specificationVersion === "v3")
    return model;
  return logV2CompatibilityWarning({
    provider: model.provider,
    modelId: model.modelId
  }), new Proxy(model, {
    get(target, prop) {
      switch (prop) {
        case "specificationVersion":
          return "v3";
        case "doGenerate":
          return async (...args) => {
            let result = await target.doGenerate(...args);
            return {
              ...result,
              finishReason: convertV2FinishReasonToV3(result.finishReason),
              usage: convertV2UsageToV3(result.usage)
            };
          };
        case "doStream":
          return async (...args) => {
            let result = await target.doStream(...args);
            return {
              ...result,
              stream: convertV2StreamToV3(result.stream)
            };
          };
        default:
          return target[prop];
      }
    }
  });
}
function convertV2StreamToV3(stream) {
  return stream.pipeThrough(new TransformStream({
    transform(chunk, controller) {
      switch (chunk.type) {
        case "finish":
          controller.enqueue({
            ...chunk,
            finishReason: convertV2FinishReasonToV3(chunk.finishReason),
            usage: convertV2UsageToV3(chunk.usage)
          });
          break;
        default:
          controller.enqueue(chunk);
          break;
      }
    }
  }));
}
function convertV2FinishReasonToV3(finishReason) {
  return {
    unified: finishReason === "unknown" ? "other" : finishReason,
    raw: void 0
  };
}
function convertV2UsageToV3(usage) {
  return {
    inputTokens: {
      total: usage.inputTokens,
      noCache: void 0,
      cacheRead: usage.cachedInputTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: usage.outputTokens,
      text: void 0,
      reasoning: usage.reasoningTokens
    }
  };
}
function resolveLanguageModel(model) {
  if (typeof model !== "string") {
    if (model.specificationVersion !== "v3" && model.specificationVersion !== "v2") {
      let unsupportedModel = model;
      throw new UnsupportedModelVersionError({
        version: unsupportedModel.specificationVersion,
        provider: unsupportedModel.provider,
        modelId: unsupportedModel.modelId
      });
    }
    return asLanguageModelV3(model);
  }
  return getGlobalProvider().languageModel(model);
}
function getGlobalProvider() {
  var _a21;
  return (_a21 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a21 : gateway;
}
function getTotalTimeoutMs(timeout) {
  if (timeout == null)
    return;
  if (typeof timeout === "number")
    return timeout;
  return timeout.totalMs;
}
function getStepTimeoutMs(timeout) {
  if (timeout == null || typeof timeout === "number")
    return;
  return timeout.stepMs;
}
function getChunkTimeoutMs(timeout) {
  if (timeout == null || typeof timeout === "number")
    return;
  return timeout.chunkMs;
}
var imageMediaTypeSignatures = [
  {
    mediaType: "image/gif",
    bytesPrefix: [71, 73, 70]
  },
  {
    mediaType: "image/png",
    bytesPrefix: [137, 80, 78, 71]
  },
  {
    mediaType: "image/jpeg",
    bytesPrefix: [255, 216]
  },
  {
    mediaType: "image/webp",
    bytesPrefix: [
      82,
      73,
      70,
      70,
      null,
      null,
      null,
      null,
      87,
      69,
      66,
      80
    ]
  },
  {
    mediaType: "image/bmp",
    bytesPrefix: [66, 77]
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [73, 73, 42, 0]
  },
  {
    mediaType: "image/tiff",
    bytesPrefix: [77, 77, 0, 42]
  },
  {
    mediaType: "image/avif",
    bytesPrefix: [
      0,
      0,
      0,
      32,
      102,
      116,
      121,
      112,
      97,
      118,
      105,
      102
    ]
  },
  {
    mediaType: "image/heic",
    bytesPrefix: [
      0,
      0,
      0,
      32,
      102,
      116,
      121,
      112,
      104,
      101,
      105,
      99
    ]
  }
];
var stripID3 = (data) => {
  let bytes = typeof data === "string" ? convertBase64ToUint8Array(data) : data, id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;
  return bytes.slice(id3Size + 10);
};
function stripID3TagsIfPresent(data) {
  return typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && data[1] === 68 && data[2] === 51 ? stripID3(data) : data;
}
function detectMediaType({
  data,
  signatures
}) {
  let processedData = stripID3TagsIfPresent(data), bytes = typeof processedData === "string" ? convertBase64ToUint8Array(processedData.substring(0, Math.min(processedData.length, 24))) : processedData;
  for (let signature of signatures)
    if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index) => byte === null || bytes[index] === byte))
      return signature.mediaType;
  return;
}
var VERSION4 = "6.0.68", download = async ({ url: url2 }) => {
  var _a21;
  let urlText = url2.toString();
  try {
    let response = await fetch(urlText, {
      headers: withUserAgentSuffix({}, `ai-sdk/${VERSION4}`, getRuntimeEnvironmentUserAgent())
    });
    if (!response.ok)
      throw new DownloadError({
        url: urlText,
        statusCode: response.status,
        statusText: response.statusText
      });
    return {
      data: new Uint8Array(await response.arrayBuffer()),
      mediaType: (_a21 = response.headers.get("content-type")) != null ? _a21 : void 0
    };
  } catch (error48) {
    if (DownloadError.isInstance(error48))
      throw error48;
    throw new DownloadError({ url: urlText, cause: error48 });
  }
}, createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(requestedDownloads.map(async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)));
function splitDataUrl(dataUrl) {
  try {
    let [header, base64Content] = dataUrl.split(",");
    return {
      mediaType: header.split(";")[0].split(":")[1],
      base64Content
    };
  } catch (error48) {
    return {
      mediaType: void 0,
      base64Content: void 0
    };
  }
}
var dataContentSchema = exports_external.union([
  exports_external.string(),
  exports_external.instanceof(Uint8Array),
  exports_external.instanceof(ArrayBuffer),
  exports_external.custom((value) => {
    var _a21, _b16;
    return (_b16 = (_a21 = globalThis.Buffer) == null ? void 0 : _a21.isBuffer(value)) != null ? _b16 : !1;
  }, { message: "Must be a Buffer" })
]);
function convertToLanguageModelV3DataContent(content) {
  if (content instanceof Uint8Array)
    return { data: content, mediaType: void 0 };
  if (content instanceof ArrayBuffer)
    return { data: new Uint8Array(content), mediaType: void 0 };
  if (typeof content === "string")
    try {
      content = new URL(content);
    } catch (error48) {}
  if (content instanceof URL && content.protocol === "data:") {
    let { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(content.toString());
    if (dataUrlMediaType == null || base64Content == null)
      throw new AISDKError({
        name: "InvalidDataContentError",
        message: `Invalid data URL format in content ${content.toString()}`
      });
    return { data: base64Content, mediaType: dataUrlMediaType };
  }
  return { data: content, mediaType: void 0 };
}
function convertDataContentToBase64String(content) {
  if (typeof content === "string")
    return content;
  if (content instanceof ArrayBuffer)
    return convertUint8ArrayToBase64(new Uint8Array(content));
  return convertUint8ArrayToBase64(content);
}
function asArray(value) {
  return value === void 0 ? [] : Array.isArray(value) ? value : [value];
}
async function convertToLanguageModelPrompt({
  prompt,
  supportedUrls,
  download: download2 = createDefaultDownloadFunction()
}) {
  let downloadedAssets = await downloadAssets(prompt.messages, download2, supportedUrls), approvalIdToToolCallId = /* @__PURE__ */ new Map;
  for (let message of prompt.messages)
    if (message.role === "assistant" && Array.isArray(message.content)) {
      for (let part of message.content)
        if (part.type === "tool-approval-request" && "approvalId" in part && "toolCallId" in part)
          approvalIdToToolCallId.set(part.approvalId, part.toolCallId);
    }
  let approvedToolCallIds = /* @__PURE__ */ new Set;
  for (let message of prompt.messages)
    if (message.role === "tool") {
      for (let part of message.content)
        if (part.type === "tool-approval-response") {
          let toolCallId = approvalIdToToolCallId.get(part.approvalId);
          if (toolCallId)
            approvedToolCallIds.add(toolCallId);
        }
    }
  let messages = [
    ...prompt.system != null ? typeof prompt.system === "string" ? [{ role: "system", content: prompt.system }] : asArray(prompt.system).map((message) => ({
      role: "system",
      content: message.content,
      providerOptions: message.providerOptions
    })) : [],
    ...prompt.messages.map((message) => convertToLanguageModelMessage({ message, downloadedAssets }))
  ], combinedMessages = [];
  for (let message of messages) {
    if (message.role !== "tool") {
      combinedMessages.push(message);
      continue;
    }
    let lastCombinedMessage = combinedMessages.at(-1);
    if ((lastCombinedMessage == null ? void 0 : lastCombinedMessage.role) === "tool")
      lastCombinedMessage.content.push(...message.content);
    else
      combinedMessages.push(message);
  }
  let toolCallIds = /* @__PURE__ */ new Set;
  for (let message of combinedMessages)
    switch (message.role) {
      case "assistant": {
        for (let content of message.content)
          if (content.type === "tool-call" && !content.providerExecuted)
            toolCallIds.add(content.toolCallId);
        break;
      }
      case "tool": {
        for (let content of message.content)
          if (content.type === "tool-result")
            toolCallIds.delete(content.toolCallId);
        break;
      }
      case "user":
      case "system":
        for (let id of approvedToolCallIds)
          toolCallIds.delete(id);
        if (toolCallIds.size > 0)
          throw new MissingToolResultsError({
            toolCallIds: Array.from(toolCallIds)
          });
        break;
    }
  for (let id of approvedToolCallIds)
    toolCallIds.delete(id);
  if (toolCallIds.size > 0)
    throw new MissingToolResultsError({ toolCallIds: Array.from(toolCallIds) });
  return combinedMessages.filter((message) => message.role !== "tool" || message.content.length > 0);
}
function convertToLanguageModelMessage({
  message,
  downloadedAssets
}) {
  let role = message.role;
  switch (role) {
    case "system":
      return {
        role: "system",
        content: message.content,
        providerOptions: message.providerOptions
      };
    case "user": {
      if (typeof message.content === "string")
        return {
          role: "user",
          content: [{ type: "text", text: message.content }],
          providerOptions: message.providerOptions
        };
      return {
        role: "user",
        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== "text" || part.text !== ""),
        providerOptions: message.providerOptions
      };
    }
    case "assistant": {
      if (typeof message.content === "string")
        return {
          role: "assistant",
          content: [{ type: "text", text: message.content }],
          providerOptions: message.providerOptions
        };
      return {
        role: "assistant",
        content: message.content.filter((part) => part.type !== "text" || part.text !== "" || part.providerOptions != null).filter((part) => part.type !== "tool-approval-request").map((part) => {
          let providerOptions = part.providerOptions;
          switch (part.type) {
            case "file": {
              let { data, mediaType } = convertToLanguageModelV3DataContent(part.data);
              return {
                type: "file",
                data,
                filename: part.filename,
                mediaType: mediaType != null ? mediaType : part.mediaType,
                providerOptions
              };
            }
            case "reasoning":
              return {
                type: "reasoning",
                text: part.text,
                providerOptions
              };
            case "text":
              return {
                type: "text",
                text: part.text,
                providerOptions
              };
            case "tool-call":
              return {
                type: "tool-call",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                input: part.input,
                providerExecuted: part.providerExecuted,
                providerOptions
              };
            case "tool-result":
              return {
                type: "tool-result",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                output: mapToolResultOutput(part.output),
                providerOptions
              };
          }
        }),
        providerOptions: message.providerOptions
      };
    }
    case "tool":
      return {
        role: "tool",
        content: message.content.filter((part) => part.type !== "tool-approval-response" || part.providerExecuted).map((part) => {
          switch (part.type) {
            case "tool-result":
              return {
                type: "tool-result",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                output: mapToolResultOutput(part.output),
                providerOptions: part.providerOptions
              };
            case "tool-approval-response":
              return {
                type: "tool-approval-response",
                approvalId: part.approvalId,
                approved: part.approved,
                reason: part.reason
              };
          }
        }),
        providerOptions: message.providerOptions
      };
    default:
      throw new InvalidMessageRoleError({ role });
  }
}
async function downloadAssets(messages, download2, supportedUrls) {
  let plannedDownloads = messages.filter((message) => message.role === "user").map((message) => message.content).filter((content) => Array.isArray(content)).flat().filter((part) => part.type === "image" || part.type === "file").map((part) => {
    var _a21;
    let mediaType = (_a21 = part.mediaType) != null ? _a21 : part.type === "image" ? "image/*" : void 0, data = part.type === "image" ? part.image : part.data;
    if (typeof data === "string")
      try {
        data = new URL(data);
      } catch (ignored) {}
    return { mediaType, data };
  }).filter((part) => part.data instanceof URL).map((part) => ({
    url: part.data,
    isUrlSupportedByModel: part.mediaType != null && isUrlSupported({
      url: part.data.toString(),
      mediaType: part.mediaType,
      supportedUrls
    })
  })), downloadedFiles = await download2(plannedDownloads);
  return Object.fromEntries(downloadedFiles.map((file2, index) => file2 == null ? null : [
    plannedDownloads[index].url.toString(),
    { data: file2.data, mediaType: file2.mediaType }
  ]).filter((file2) => file2 != null));
}
function convertPartToLanguageModelPart(part, downloadedAssets) {
  var _a21;
  if (part.type === "text")
    return {
      type: "text",
      text: part.text,
      providerOptions: part.providerOptions
    };
  let originalData, type = part.type;
  switch (type) {
    case "image":
      originalData = part.image;
      break;
    case "file":
      originalData = part.data;
      break;
    default:
      throw Error(`Unsupported part type: ${type}`);
  }
  let { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV3DataContent(originalData), mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType, data = convertedData;
  if (data instanceof URL) {
    let downloadedFile = downloadedAssets[data.toString()];
    if (downloadedFile)
      data = downloadedFile.data, mediaType != null || (mediaType = downloadedFile.mediaType);
  }
  switch (type) {
    case "image": {
      if (data instanceof Uint8Array || typeof data === "string")
        mediaType = (_a21 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a21 : mediaType;
      return {
        type: "file",
        mediaType: mediaType != null ? mediaType : "image/*",
        filename: void 0,
        data,
        providerOptions: part.providerOptions
      };
    }
    case "file": {
      if (mediaType == null)
        throw Error("Media type is missing for file part");
      return {
        type: "file",
        mediaType,
        filename: part.filename,
        data,
        providerOptions: part.providerOptions
      };
    }
  }
}
function mapToolResultOutput(output) {
  if (output.type !== "content")
    return output;
  return {
    type: "content",
    value: output.value.map((item) => {
      if (item.type !== "media")
        return item;
      if (item.mediaType.startsWith("image/"))
        return {
          type: "image-data",
          data: item.data,
          mediaType: item.mediaType
        };
      return {
        type: "file-data",
        data: item.data,
        mediaType: item.mediaType
      };
    })
  };
}
async function createToolModelOutput({
  toolCallId,
  input,
  output,
  tool: tool2,
  errorMode
}) {
  if (errorMode === "text")
    return { type: "error-text", value: getErrorMessage(output) };
  else if (errorMode === "json")
    return { type: "error-json", value: toJSONValue(output) };
  if (tool2 == null ? void 0 : tool2.toModelOutput)
    return await tool2.toModelOutput({ toolCallId, input, output });
  return typeof output === "string" ? { type: "text", value: output } : { type: "json", value: toJSONValue(output) };
}
function toJSONValue(value) {
  return value === void 0 ? null : value;
}
function prepareCallSettings({
  maxOutputTokens,
  temperature,
  topP,
  topK,
  presencePenalty,
  frequencyPenalty,
  seed,
  stopSequences
}) {
  if (maxOutputTokens != null) {
    if (!Number.isInteger(maxOutputTokens))
      throw new InvalidArgumentError2({
        parameter: "maxOutputTokens",
        value: maxOutputTokens,
        message: "maxOutputTokens must be an integer"
      });
    if (maxOutputTokens < 1)
      throw new InvalidArgumentError2({
        parameter: "maxOutputTokens",
        value: maxOutputTokens,
        message: "maxOutputTokens must be >= 1"
      });
  }
  if (temperature != null) {
    if (typeof temperature !== "number")
      throw new InvalidArgumentError2({
        parameter: "temperature",
        value: temperature,
        message: "temperature must be a number"
      });
  }
  if (topP != null) {
    if (typeof topP !== "number")
      throw new InvalidArgumentError2({
        parameter: "topP",
        value: topP,
        message: "topP must be a number"
      });
  }
  if (topK != null) {
    if (typeof topK !== "number")
      throw new InvalidArgumentError2({
        parameter: "topK",
        value: topK,
        message: "topK must be a number"
      });
  }
  if (presencePenalty != null) {
    if (typeof presencePenalty !== "number")
      throw new InvalidArgumentError2({
        parameter: "presencePenalty",
        value: presencePenalty,
        message: "presencePenalty must be a number"
      });
  }
  if (frequencyPenalty != null) {
    if (typeof frequencyPenalty !== "number")
      throw new InvalidArgumentError2({
        parameter: "frequencyPenalty",
        value: frequencyPenalty,
        message: "frequencyPenalty must be a number"
      });
  }
  if (seed != null) {
    if (!Number.isInteger(seed))
      throw new InvalidArgumentError2({
        parameter: "seed",
        value: seed,
        message: "seed must be an integer"
      });
  }
  return {
    maxOutputTokens,
    temperature,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    stopSequences,
    seed
  };
}
function isNonEmptyObject(object2) {
  return object2 != null && Object.keys(object2).length > 0;
}
async function prepareToolsAndToolChoice({
  tools,
  toolChoice,
  activeTools
}) {
  if (!isNonEmptyObject(tools))
    return {
      tools: void 0,
      toolChoice: void 0
    };
  let filteredTools = activeTools != null ? Object.entries(tools).filter(([name21]) => activeTools.includes(name21)) : Object.entries(tools), languageModelTools = [];
  for (let [name21, tool2] of filteredTools) {
    let toolType = tool2.type;
    switch (toolType) {
      case void 0:
      case "dynamic":
      case "function":
        languageModelTools.push({
          type: "function",
          name: name21,
          description: tool2.description,
          inputSchema: await asSchema(tool2.inputSchema).jsonSchema,
          ...tool2.inputExamples != null ? { inputExamples: tool2.inputExamples } : {},
          providerOptions: tool2.providerOptions,
          ...tool2.strict != null ? { strict: tool2.strict } : {}
        });
        break;
      case "provider":
        languageModelTools.push({
          type: "provider",
          name: name21,
          id: tool2.id,
          args: tool2.args
        });
        break;
      default:
        throw Error(`Unsupported tool type: ${toolType}`);
    }
  }
  return {
    tools: languageModelTools,
    toolChoice: toolChoice == null ? { type: "auto" } : typeof toolChoice === "string" ? { type: toolChoice } : { type: "tool", toolName: toolChoice.toolName }
  };
}
var jsonValueSchema = exports_external.lazy(() => exports_external.union([
  exports_external.null(),
  exports_external.string(),
  exports_external.number(),
  exports_external.boolean(),
  exports_external.record(exports_external.string(), jsonValueSchema.optional()),
  exports_external.array(jsonValueSchema)
])), providerMetadataSchema = exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), jsonValueSchema.optional())), textPartSchema = exports_external.object({
  type: exports_external.literal("text"),
  text: exports_external.string(),
  providerOptions: providerMetadataSchema.optional()
}), imagePartSchema = exports_external.object({
  type: exports_external.literal("image"),
  image: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),
  mediaType: exports_external.string().optional(),
  providerOptions: providerMetadataSchema.optional()
}), filePartSchema = exports_external.object({
  type: exports_external.literal("file"),
  data: exports_external.union([dataContentSchema, exports_external.instanceof(URL)]),
  filename: exports_external.string().optional(),
  mediaType: exports_external.string(),
  providerOptions: providerMetadataSchema.optional()
}), reasoningPartSchema = exports_external.object({
  type: exports_external.literal("reasoning"),
  text: exports_external.string(),
  providerOptions: providerMetadataSchema.optional()
}), toolCallPartSchema = exports_external.object({
  type: exports_external.literal("tool-call"),
  toolCallId: exports_external.string(),
  toolName: exports_external.string(),
  input: exports_external.unknown(),
  providerOptions: providerMetadataSchema.optional(),
  providerExecuted: exports_external.boolean().optional()
}), outputSchema = exports_external.discriminatedUnion("type", [
  exports_external.object({
    type: exports_external.literal("text"),
    value: exports_external.string(),
    providerOptions: providerMetadataSchema.optional()
  }),
  exports_external.object({
    type: exports_external.literal("json"),
    value: jsonValueSchema,
    providerOptions: providerMetadataSchema.optional()
  }),
  exports_external.object({
    type: exports_external.literal("execution-denied"),
    reason: exports_external.string().optional(),
    providerOptions: providerMetadataSchema.optional()
  }),
  exports_external.object({
    type: exports_external.literal("error-text"),
    value: exports_external.string(),
    providerOptions: providerMetadataSchema.optional()
  }),
  exports_external.object({
    type: exports_external.literal("error-json"),
    value: jsonValueSchema,
    providerOptions: providerMetadataSchema.optional()
  }),
  exports_external.object({
    type: exports_external.literal("content"),
    value: exports_external.array(exports_external.union([
      exports_external.object({
        type: exports_external.literal("text"),
        text: exports_external.string(),
        providerOptions: providerMetadataSchema.optional()
      }),
      exports_external.object({
        type: exports_external.literal("media"),
        data: exports_external.string(),
        mediaType: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("file-data"),
        data: exports_external.string(),
        mediaType: exports_external.string(),
        filename: exports_external.string().optional(),
        providerOptions: providerMetadataSchema.optional()
      }),
      exports_external.object({
        type: exports_external.literal("file-url"),
        url: exports_external.string(),
        providerOptions: providerMetadataSchema.optional()
      }),
      exports_external.object({
        type: exports_external.literal("file-id"),
        fileId: exports_external.union([exports_external.string(), exports_external.record(exports_external.string(), exports_external.string())]),
        providerOptions: providerMetadataSchema.optional()
      }),
      exports_external.object({
        type: exports_external.literal("image-data"),
        data: exports_external.string(),
        mediaType: exports_external.string(),
        providerOptions: providerMetadataSchema.optional()
      }),
      exports_external.object({
        type: exports_external.literal("image-url"),
        url: exports_external.string(),
        providerOptions: providerMetadataSchema.optional()
      }),
      exports_external.object({
        type: exports_external.literal("image-file-id"),
        fileId: exports_external.union([exports_external.string(), exports_external.record(exports_external.string(), exports_external.string())]),
        providerOptions: providerMetadataSchema.optional()
      }),
      exports_external.object({
        type: exports_external.literal("custom"),
        providerOptions: providerMetadataSchema.optional()
      })
    ]))
  })
]), toolResultPartSchema = exports_external.object({
  type: exports_external.literal("tool-result"),
  toolCallId: exports_external.string(),
  toolName: exports_external.string(),
  output: outputSchema,
  providerOptions: providerMetadataSchema.optional()
}), toolApprovalRequestSchema = exports_external.object({
  type: exports_external.literal("tool-approval-request"),
  approvalId: exports_external.string(),
  toolCallId: exports_external.string()
}), toolApprovalResponseSchema = exports_external.object({
  type: exports_external.literal("tool-approval-response"),
  approvalId: exports_external.string(),
  approved: exports_external.boolean(),
  reason: exports_external.string().optional()
}), systemModelMessageSchema = exports_external.object({
  role: exports_external.literal("system"),
  content: exports_external.string(),
  providerOptions: providerMetadataSchema.optional()
}), userModelMessageSchema = exports_external.object({
  role: exports_external.literal("user"),
  content: exports_external.union([
    exports_external.string(),
    exports_external.array(exports_external.union([textPartSchema, imagePartSchema, filePartSchema]))
  ]),
  providerOptions: providerMetadataSchema.optional()
}), assistantModelMessageSchema = exports_external.object({
  role: exports_external.literal("assistant"),
  content: exports_external.union([
    exports_external.string(),
    exports_external.array(exports_external.union([
      textPartSchema,
      filePartSchema,
      reasoningPartSchema,
      toolCallPartSchema,
      toolResultPartSchema,
      toolApprovalRequestSchema
    ]))
  ]),
  providerOptions: providerMetadataSchema.optional()
}), toolModelMessageSchema = exports_external.object({
  role: exports_external.literal("tool"),
  content: exports_external.array(exports_external.union([toolResultPartSchema, toolApprovalResponseSchema])),
  providerOptions: providerMetadataSchema.optional()
}), modelMessageSchema = exports_external.union([
  systemModelMessageSchema,
  userModelMessageSchema,
  assistantModelMessageSchema,
  toolModelMessageSchema
]);
async function standardizePrompt(prompt) {
  if (prompt.prompt == null && prompt.messages == null)
    throw new InvalidPromptError({
      prompt,
      message: "prompt or messages must be defined"
    });
  if (prompt.prompt != null && prompt.messages != null)
    throw new InvalidPromptError({
      prompt,
      message: "prompt and messages cannot be defined at the same time"
    });
  if (prompt.system != null && typeof prompt.system !== "string" && !asArray(prompt.system).every((message) => typeof message === "object" && message !== null && ("role" in message) && message.role === "system"))
    throw new InvalidPromptError({
      prompt,
      message: "system must be a string, SystemModelMessage, or array of SystemModelMessage"
    });
  let messages;
  if (prompt.prompt != null && typeof prompt.prompt === "string")
    messages = [{ role: "user", content: prompt.prompt }];
  else if (prompt.prompt != null && Array.isArray(prompt.prompt))
    messages = prompt.prompt;
  else if (prompt.messages != null)
    messages = prompt.messages;
  else
    throw new InvalidPromptError({
      prompt,
      message: "prompt or messages must be defined"
    });
  if (messages.length === 0)
    throw new InvalidPromptError({
      prompt,
      message: "messages must not be empty"
    });
  let validationResult = await safeValidateTypes({
    value: messages,
    schema: exports_external.array(modelMessageSchema)
  });
  if (!validationResult.success)
    throw new InvalidPromptError({
      prompt,
      message: "The messages do not match the ModelMessage[] schema.",
      cause: validationResult.error
    });
  return {
    messages,
    system: prompt.system
  };
}
function wrapGatewayError(error48) {
  if (!GatewayAuthenticationError.isInstance(error48))
    return error48;
  let isProductionEnv = (process == null ? void 0 : "development") === "production", moreInfoURL = "https://ai-sdk.dev/unauthenticated-ai-gateway";
  if (isProductionEnv)
    return new AISDKError({
      name: "GatewayError",
      message: `Unauthenticated. Configure AI_GATEWAY_API_KEY or use a provider module. Learn more: ${moreInfoURL}`
    });
  return Object.assign(Error(`\x1B[1m\x1B[31mUnauthenticated request to AI Gateway.\x1B[0m

To authenticate, set the \x1B[33mAI_GATEWAY_API_KEY\x1B[0m environment variable with your API key.

Alternatively, you can use a provider module instead of the AI Gateway.

Learn more: \x1B[34m${moreInfoURL}\x1B[0m

`), { name: "GatewayAuthenticationError" });
}
function assembleOperationName({
  operationId,
  telemetry
}) {
  return {
    "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
    "resource.name": telemetry == null ? void 0 : telemetry.functionId,
    "ai.operationId": operationId,
    "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
  };
}
function getBaseTelemetryAttributes({
  model,
  settings,
  telemetry,
  headers
}) {
  var _a21;
  return {
    "ai.model.provider": model.provider,
    "ai.model.id": model.modelId,
    ...Object.entries(settings).reduce((attributes, [key, value]) => {
      if (key === "timeout") {
        let totalTimeoutMs = getTotalTimeoutMs(value);
        if (totalTimeoutMs != null)
          attributes[`ai.settings.${key}`] = totalTimeoutMs;
      } else
        attributes[`ai.settings.${key}`] = value;
      return attributes;
    }, {}),
    ...Object.entries((_a21 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a21 : {}).reduce((attributes, [key, value]) => {
      return attributes[`ai.telemetry.metadata.${key}`] = value, attributes;
    }, {}),
    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {
      if (value !== void 0)
        attributes[`ai.request.headers.${key}`] = value;
      return attributes;
    }, {})
  };
}
var noopTracer = {
  startSpan() {
    return noopSpan;
  },
  startActiveSpan(name21, arg1, arg2, arg3) {
    if (typeof arg1 === "function")
      return arg1(noopSpan);
    if (typeof arg2 === "function")
      return arg2(noopSpan);
    if (typeof arg3 === "function")
      return arg3(noopSpan);
  }
}, noopSpan = {
  spanContext() {
    return noopSpanContext;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return !1;
  },
  recordException() {
    return this;
  }
}, noopSpanContext = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
function getTracer({
  isEnabled = !1,
  tracer
} = {}) {
  if (!isEnabled)
    return noopTracer;
  if (tracer)
    return tracer;
  return trace.getTracer("ai");
}
async function recordSpan({
  name: name21,
  tracer,
  attributes,
  fn,
  endWhenDone = !0
}) {
  return tracer.startActiveSpan(name21, { attributes: await attributes }, async (span) => {
    let ctx = context.active();
    try {
      let result = await context.with(ctx, () => fn(span));
      if (endWhenDone)
        span.end();
      return result;
    } catch (error48) {
      try {
        recordErrorOnSpan(span, error48);
      } finally {
        span.end();
      }
      throw error48;
    }
  });
}
function recordErrorOnSpan(span, error48) {
  if (error48 instanceof Error)
    span.recordException({
      name: error48.name,
      message: error48.message,
      stack: error48.stack
    }), span.setStatus({
      code: SpanStatusCode.ERROR,
      message: error48.message
    });
  else
    span.setStatus({ code: SpanStatusCode.ERROR });
}
async function selectTelemetryAttributes({
  telemetry,
  attributes
}) {
  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== !0)
    return {};
  let resultAttributes = {};
  for (let [key, value] of Object.entries(attributes)) {
    if (value == null)
      continue;
    if (typeof value === "object" && "input" in value && typeof value.input === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordInputs) === !1)
        continue;
      let result = await value.input();
      if (result != null)
        resultAttributes[key] = result;
      continue;
    }
    if (typeof value === "object" && "output" in value && typeof value.output === "function") {
      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === !1)
        continue;
      let result = await value.output();
      if (result != null)
        resultAttributes[key] = result;
      continue;
    }
    resultAttributes[key] = value;
  }
  return resultAttributes;
}
function stringifyForTelemetry(prompt) {
  return JSON.stringify(prompt.map((message) => ({
    ...message,
    content: typeof message.content === "string" ? message.content : message.content.map((part) => part.type === "file" ? {
      ...part,
      data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data
    } : part)
  })));
}
function asLanguageModelUsage(usage) {
  return {
    inputTokens: usage.inputTokens.total,
    inputTokenDetails: {
      noCacheTokens: usage.inputTokens.noCache,
      cacheReadTokens: usage.inputTokens.cacheRead,
      cacheWriteTokens: usage.inputTokens.cacheWrite
    },
    outputTokens: usage.outputTokens.total,
    outputTokenDetails: {
      textTokens: usage.outputTokens.text,
      reasoningTokens: usage.outputTokens.reasoning
    },
    totalTokens: addTokenCounts(usage.inputTokens.total, usage.outputTokens.total),
    raw: usage.raw,
    reasoningTokens: usage.outputTokens.reasoning,
    cachedInputTokens: usage.inputTokens.cacheRead
  };
}
function createNullLanguageModelUsage() {
  return {
    inputTokens: void 0,
    inputTokenDetails: {
      noCacheTokens: void 0,
      cacheReadTokens: void 0,
      cacheWriteTokens: void 0
    },
    outputTokens: void 0,
    outputTokenDetails: {
      textTokens: void 0,
      reasoningTokens: void 0
    },
    totalTokens: void 0,
    raw: void 0
  };
}
function addLanguageModelUsage(usage1, usage2) {
  var _a21, _b16, _c, _d, _e, _f, _g, _h, _i, _j;
  return {
    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),
    inputTokenDetails: {
      noCacheTokens: addTokenCounts((_a21 = usage1.inputTokenDetails) == null ? void 0 : _a21.noCacheTokens, (_b16 = usage2.inputTokenDetails) == null ? void 0 : _b16.noCacheTokens),
      cacheReadTokens: addTokenCounts((_c = usage1.inputTokenDetails) == null ? void 0 : _c.cacheReadTokens, (_d = usage2.inputTokenDetails) == null ? void 0 : _d.cacheReadTokens),
      cacheWriteTokens: addTokenCounts((_e = usage1.inputTokenDetails) == null ? void 0 : _e.cacheWriteTokens, (_f = usage2.inputTokenDetails) == null ? void 0 : _f.cacheWriteTokens)
    },
    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),
    outputTokenDetails: {
      textTokens: addTokenCounts((_g = usage1.outputTokenDetails) == null ? void 0 : _g.textTokens, (_h = usage2.outputTokenDetails) == null ? void 0 : _h.textTokens),
      reasoningTokens: addTokenCounts((_i = usage1.outputTokenDetails) == null ? void 0 : _i.reasoningTokens, (_j = usage2.outputTokenDetails) == null ? void 0 : _j.reasoningTokens)
    },
    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),
    reasoningTokens: addTokenCounts(usage1.reasoningTokens, usage2.reasoningTokens),
    cachedInputTokens: addTokenCounts(usage1.cachedInputTokens, usage2.cachedInputTokens)
  };
}
function addTokenCounts(tokenCount1, tokenCount2) {
  return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);
}
function mergeObjects(base, overrides) {
  if (base === void 0 && overrides === void 0)
    return;
  if (base === void 0)
    return overrides;
  if (overrides === void 0)
    return base;
  let result = { ...base };
  for (let key in overrides)
    if (Object.prototype.hasOwnProperty.call(overrides, key)) {
      let overridesValue = overrides[key];
      if (overridesValue === void 0)
        continue;
      let baseValue = key in base ? base[key] : void 0, isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp), isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);
      if (isSourceObject && isTargetObject)
        result[key] = mergeObjects(baseValue, overridesValue);
      else
        result[key] = overridesValue;
    }
  return result;
}
function getRetryDelayInMs({
  error: error48,
  exponentialBackoffDelay
}) {
  let headers = error48.responseHeaders;
  if (!headers)
    return exponentialBackoffDelay;
  let ms, retryAfterMs = headers["retry-after-ms"];
  if (retryAfterMs) {
    let timeoutMs = parseFloat(retryAfterMs);
    if (!Number.isNaN(timeoutMs))
      ms = timeoutMs;
  }
  let retryAfter = headers["retry-after"];
  if (retryAfter && ms === void 0) {
    let timeoutSeconds = parseFloat(retryAfter);
    if (!Number.isNaN(timeoutSeconds))
      ms = timeoutSeconds * 1000;
    else
      ms = Date.parse(retryAfter) - Date.now();
  }
  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60000 || ms < exponentialBackoffDelay))
    return ms;
  return exponentialBackoffDelay;
}
var retryWithExponentialBackoffRespectingRetryHeaders = ({
  maxRetries = 2,
  initialDelayInMs = 2000,
  backoffFactor = 2,
  abortSignal
} = {}) => async (f) => _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs: initialDelayInMs,
  backoffFactor,
  abortSignal
});
async function _retryWithExponentialBackoff(f, {
  maxRetries,
  delayInMs,
  backoffFactor,
  abortSignal
}, errors3 = []) {
  try {
    return await f();
  } catch (error48) {
    if (isAbortError(error48))
      throw error48;
    if (maxRetries === 0)
      throw error48;
    let errorMessage = getErrorMessage2(error48), newErrors = [...errors3, error48], tryNumber = newErrors.length;
    if (tryNumber > maxRetries)
      throw new RetryError({
        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
        reason: "maxRetriesExceeded",
        errors: newErrors
      });
    if (error48 instanceof Error && APICallError.isInstance(error48) && error48.isRetryable === !0 && tryNumber <= maxRetries)
      return await delay(getRetryDelayInMs({
        error: error48,
        exponentialBackoffDelay: delayInMs
      }), { abortSignal }), _retryWithExponentialBackoff(f, {
        maxRetries,
        delayInMs: backoffFactor * delayInMs,
        backoffFactor,
        abortSignal
      }, newErrors);
    if (tryNumber === 1)
      throw error48;
    throw new RetryError({
      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
      reason: "errorNotRetryable",
      errors: newErrors
    });
  }
}
function prepareRetries({
  maxRetries,
  abortSignal
}) {
  if (maxRetries != null) {
    if (!Number.isInteger(maxRetries))
      throw new InvalidArgumentError2({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be an integer"
      });
    if (maxRetries < 0)
      throw new InvalidArgumentError2({
        parameter: "maxRetries",
        value: maxRetries,
        message: "maxRetries must be >= 0"
      });
  }
  let maxRetriesResult = maxRetries != null ? maxRetries : 2;
  return {
    maxRetries: maxRetriesResult,
    retry: retryWithExponentialBackoffRespectingRetryHeaders({
      maxRetries: maxRetriesResult,
      abortSignal
    })
  };
}
function collectToolApprovals({
  messages
}) {
  let lastMessage = messages.at(-1);
  if ((lastMessage == null ? void 0 : lastMessage.role) != "tool")
    return {
      approvedToolApprovals: [],
      deniedToolApprovals: []
    };
  let toolCallsByToolCallId = {};
  for (let message of messages)
    if (message.role === "assistant" && typeof message.content !== "string") {
      let content = message.content;
      for (let part of content)
        if (part.type === "tool-call")
          toolCallsByToolCallId[part.toolCallId] = part;
    }
  let toolApprovalRequestsByApprovalId = {};
  for (let message of messages)
    if (message.role === "assistant" && typeof message.content !== "string") {
      let content = message.content;
      for (let part of content)
        if (part.type === "tool-approval-request")
          toolApprovalRequestsByApprovalId[part.approvalId] = part;
    }
  let toolResults = {};
  for (let part of lastMessage.content)
    if (part.type === "tool-result")
      toolResults[part.toolCallId] = part;
  let approvedToolApprovals = [], deniedToolApprovals = [], approvalResponses = lastMessage.content.filter((part) => part.type === "tool-approval-response");
  for (let approvalResponse of approvalResponses) {
    let approvalRequest = toolApprovalRequestsByApprovalId[approvalResponse.approvalId];
    if (approvalRequest == null)
      throw new InvalidToolApprovalError({
        approvalId: approvalResponse.approvalId
      });
    if (toolResults[approvalRequest.toolCallId] != null)
      continue;
    let toolCall = toolCallsByToolCallId[approvalRequest.toolCallId];
    if (toolCall == null)
      throw new ToolCallNotFoundForApprovalError({
        toolCallId: approvalRequest.toolCallId,
        approvalId: approvalRequest.approvalId
      });
    let approval = {
      approvalRequest,
      approvalResponse,
      toolCall
    };
    if (approvalResponse.approved)
      approvedToolApprovals.push(approval);
    else
      deniedToolApprovals.push(approval);
  }
  return { approvedToolApprovals, deniedToolApprovals };
}
async function executeToolCall({
  toolCall,
  tools,
  tracer,
  telemetry,
  messages,
  abortSignal,
  experimental_context,
  onPreliminaryToolResult
}) {
  let { toolName, toolCallId, input } = toolCall, tool2 = tools == null ? void 0 : tools[toolName];
  if ((tool2 == null ? void 0 : tool2.execute) == null)
    return;
  return recordSpan({
    name: "ai.toolCall",
    attributes: selectTelemetryAttributes({
      telemetry,
      attributes: {
        ...assembleOperationName({
          operationId: "ai.toolCall",
          telemetry
        }),
        "ai.toolCall.name": toolName,
        "ai.toolCall.id": toolCallId,
        "ai.toolCall.args": {
          output: () => JSON.stringify(input)
        }
      }
    }),
    tracer,
    fn: async (span) => {
      let output;
      try {
        let stream = executeTool({
          execute: tool2.execute.bind(tool2),
          input,
          options: {
            toolCallId,
            messages,
            abortSignal,
            experimental_context
          }
        });
        for await (let part of stream)
          if (part.type === "preliminary")
            onPreliminaryToolResult == null || onPreliminaryToolResult({
              ...toolCall,
              type: "tool-result",
              output: part.output,
              preliminary: !0
            });
          else
            output = part.output;
      } catch (error48) {
        return recordErrorOnSpan(span, error48), {
          type: "tool-error",
          toolCallId,
          toolName,
          input,
          error: error48,
          dynamic: tool2.type === "dynamic",
          ...toolCall.providerMetadata != null ? { providerMetadata: toolCall.providerMetadata } : {}
        };
      }
      try {
        span.setAttributes(await selectTelemetryAttributes({
          telemetry,
          attributes: {
            "ai.toolCall.result": {
              output: () => JSON.stringify(output)
            }
          }
        }));
      } catch (ignored) {}
      return {
        type: "tool-result",
        toolCallId,
        toolName,
        input,
        output,
        dynamic: tool2.type === "dynamic",
        ...toolCall.providerMetadata != null ? { providerMetadata: toolCall.providerMetadata } : {}
      };
    }
  });
}
function extractTextContent(content) {
  let parts = content.filter((content2) => content2.type === "text");
  if (parts.length === 0)
    return;
  return parts.map((content2) => content2.text).join("");
}
var DefaultGeneratedFile = class {
  constructor({
    data,
    mediaType
  }) {
    let isUint8Array = data instanceof Uint8Array;
    this.base64Data = isUint8Array ? void 0 : data, this.uint8ArrayData = isUint8Array ? data : void 0, this.mediaType = mediaType;
  }
  get base64() {
    if (this.base64Data == null)
      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData);
    return this.base64Data;
  }
  get uint8Array() {
    if (this.uint8ArrayData == null)
      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data);
    return this.uint8ArrayData;
  }
}, DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
  constructor(options) {
    super(options);
    this.type = "file";
  }
};
async function isApprovalNeeded({
  tool: tool2,
  toolCall,
  messages,
  experimental_context
}) {
  if (tool2.needsApproval == null)
    return !1;
  if (typeof tool2.needsApproval === "boolean")
    return tool2.needsApproval;
  return await tool2.needsApproval(toolCall.input, {
    toolCallId: toolCall.toolCallId,
    messages,
    experimental_context
  });
}
var output_exports = {};
__export2(output_exports, {
  array: () => array2,
  choice: () => choice,
  json: () => json2,
  object: () => object2,
  text: () => text
});
function fixJson(input) {
  let stack = ["ROOT"], lastValidIndex = -1, literalStart = null;
  function processValueStart(char, i, swapState) {
    switch (char) {
      case '"': {
        lastValidIndex = i, stack.pop(), stack.push(swapState), stack.push("INSIDE_STRING");
        break;
      }
      case "f":
      case "t":
      case "n": {
        lastValidIndex = i, literalStart = i, stack.pop(), stack.push(swapState), stack.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        stack.pop(), stack.push(swapState), stack.push("INSIDE_NUMBER");
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        lastValidIndex = i, stack.pop(), stack.push(swapState), stack.push("INSIDE_NUMBER");
        break;
      }
      case "{": {
        lastValidIndex = i, stack.pop(), stack.push(swapState), stack.push("INSIDE_OBJECT_START");
        break;
      }
      case "[": {
        lastValidIndex = i, stack.pop(), stack.push(swapState), stack.push("INSIDE_ARRAY_START");
        break;
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop(), stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i, stack.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop(), stack.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        lastValidIndex = i, stack.pop();
        break;
      }
    }
  }
  for (let i = 0;i < input.length; i++) {
    let char = input[i];
    switch (stack[stack.length - 1]) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop(), stack.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            lastValidIndex = i, stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop(), stack.push("INSIDE_OBJECT_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop(), stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop(), stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop(), lastValidIndex = i;
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            lastValidIndex = i;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i, stack.pop();
            break;
          }
          default: {
            lastValidIndex = i, processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop(), stack.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            lastValidIndex = i, stack.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop(), lastValidIndex = i;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            if (stack.pop(), stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE")
              processAfterArrayValue(char, i);
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE")
              processAfterObjectValue(char, i);
            break;
          }
          case "}": {
            if (stack.pop(), stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE")
              processAfterObjectValue(char, i);
            break;
          }
          case "]": {
            if (stack.pop(), stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE")
              processAfterArrayValue(char, i);
            break;
          }
          default: {
            stack.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        let partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          if (stack.pop(), stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE")
            processAfterObjectValue(char, i);
          else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE")
            processAfterArrayValue(char, i);
        } else
          lastValidIndex = i;
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1;i >= 0; i--)
    switch (stack[i]) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        let partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral))
          result += "true".slice(partialLiteral.length);
        else if ("false".startsWith(partialLiteral))
          result += "false".slice(partialLiteral.length);
        else if ("null".startsWith(partialLiteral))
          result += "null".slice(partialLiteral.length);
      }
    }
  return result;
}
async function parsePartialJson(jsonText) {
  if (jsonText === void 0)
    return { value: void 0, state: "undefined-input" };
  let result = await safeParseJSON({ text: jsonText });
  if (result.success)
    return { value: result.value, state: "successful-parse" };
  if (result = await safeParseJSON({ text: fixJson(jsonText) }), result.success)
    return { value: result.value, state: "repaired-parse" };
  return { value: void 0, state: "failed-parse" };
}
var text = () => ({
  name: "text",
  responseFormat: Promise.resolve({ type: "text" }),
  async parseCompleteOutput({ text: text2 }) {
    return text2;
  },
  async parsePartialOutput({ text: text2 }) {
    return { partial: text2 };
  },
  createElementStreamTransform() {
    return;
  }
}), object2 = ({
  schema: inputSchema,
  name: name21,
  description
}) => {
  let schema = asSchema(inputSchema);
  return {
    name: "object",
    responseFormat: resolve(schema.jsonSchema).then((jsonSchema2) => ({
      type: "json",
      schema: jsonSchema2,
      ...name21 != null && { name: name21 },
      ...description != null && { description }
    })),
    async parseCompleteOutput({ text: text2 }, context2) {
      let parseResult = await safeParseJSON({ text: text2 });
      if (!parseResult.success)
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text2,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      let validationResult = await safeValidateTypes({
        value: parseResult.value,
        schema
      });
      if (!validationResult.success)
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: validationResult.error,
          text: text2,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      return validationResult.value;
    },
    async parsePartialOutput({ text: text2 }) {
      let result = await parsePartialJson(text2);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse":
          return {
            partial: result.value
          };
      }
    },
    createElementStreamTransform() {
      return;
    }
  };
}, array2 = ({
  element: inputElementSchema,
  name: name21,
  description
}) => {
  let elementSchema = asSchema(inputElementSchema);
  return {
    name: "array",
    responseFormat: resolve(elementSchema.jsonSchema).then((jsonSchema2) => {
      let { $schema, ...itemSchema } = jsonSchema2;
      return {
        type: "json",
        schema: {
          $schema: "http://json-schema.org/draft-07/schema#",
          type: "object",
          properties: {
            elements: { type: "array", items: itemSchema }
          },
          required: ["elements"],
          additionalProperties: !1
        },
        ...name21 != null && { name: name21 },
        ...description != null && { description }
      };
    }),
    async parseCompleteOutput({ text: text2 }, context2) {
      let parseResult = await safeParseJSON({ text: text2 });
      if (!parseResult.success)
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text2,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      let outerValue = parseResult.value;
      if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements))
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: new TypeValidationError({
            value: outerValue,
            cause: "response must be an object with an elements array"
          }),
          text: text2,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      for (let element of outerValue.elements) {
        let validationResult = await safeValidateTypes({
          value: element,
          schema: elementSchema
        });
        if (!validationResult.success)
          throw new NoObjectGeneratedError({
            message: "No object generated: response did not match schema.",
            cause: validationResult.error,
            text: text2,
            response: context2.response,
            usage: context2.usage,
            finishReason: context2.finishReason
          });
      }
      return outerValue.elements;
    },
    async parsePartialOutput({ text: text2 }) {
      let result = await parsePartialJson(text2);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse": {
          let outerValue = result.value;
          if (outerValue == null || typeof outerValue !== "object" || !("elements" in outerValue) || !Array.isArray(outerValue.elements))
            return;
          let rawElements = result.state === "repaired-parse" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements, parsedElements = [];
          for (let rawElement of rawElements) {
            let validationResult = await safeValidateTypes({
              value: rawElement,
              schema: elementSchema
            });
            if (validationResult.success)
              parsedElements.push(validationResult.value);
          }
          return { partial: parsedElements };
        }
      }
    },
    createElementStreamTransform() {
      let publishedElements = 0;
      return new TransformStream({
        transform({ partialOutput }, controller) {
          if (partialOutput != null)
            for (;publishedElements < partialOutput.length; publishedElements++)
              controller.enqueue(partialOutput[publishedElements]);
        }
      });
    }
  };
}, choice = ({
  options: choiceOptions,
  name: name21,
  description
}) => {
  return {
    name: "choice",
    responseFormat: Promise.resolve({
      type: "json",
      schema: {
        $schema: "http://json-schema.org/draft-07/schema#",
        type: "object",
        properties: {
          result: { type: "string", enum: choiceOptions }
        },
        required: ["result"],
        additionalProperties: !1
      },
      ...name21 != null && { name: name21 },
      ...description != null && { description }
    }),
    async parseCompleteOutput({ text: text2 }, context2) {
      let parseResult = await safeParseJSON({ text: text2 });
      if (!parseResult.success)
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text2,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      let outerValue = parseResult.value;
      if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string" || !choiceOptions.includes(outerValue.result))
        throw new NoObjectGeneratedError({
          message: "No object generated: response did not match schema.",
          cause: new TypeValidationError({
            value: outerValue,
            cause: "response must be an object that contains a choice value."
          }),
          text: text2,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      return outerValue.result;
    },
    async parsePartialOutput({ text: text2 }) {
      let result = await parsePartialJson(text2);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse": {
          let outerValue = result.value;
          if (outerValue == null || typeof outerValue !== "object" || !("result" in outerValue) || typeof outerValue.result !== "string")
            return;
          let potentialMatches = choiceOptions.filter((choiceOption) => choiceOption.startsWith(outerValue.result));
          if (result.state === "successful-parse")
            return potentialMatches.includes(outerValue.result) ? { partial: outerValue.result } : void 0;
          else
            return potentialMatches.length === 1 ? { partial: potentialMatches[0] } : void 0;
        }
      }
    },
    createElementStreamTransform() {
      return;
    }
  };
}, json2 = ({
  name: name21,
  description
} = {}) => {
  return {
    name: "json",
    responseFormat: Promise.resolve({
      type: "json",
      ...name21 != null && { name: name21 },
      ...description != null && { description }
    }),
    async parseCompleteOutput({ text: text2 }, context2) {
      let parseResult = await safeParseJSON({ text: text2 });
      if (!parseResult.success)
        throw new NoObjectGeneratedError({
          message: "No object generated: could not parse the response.",
          cause: parseResult.error,
          text: text2,
          response: context2.response,
          usage: context2.usage,
          finishReason: context2.finishReason
        });
      return parseResult.value;
    },
    async parsePartialOutput({ text: text2 }) {
      let result = await parsePartialJson(text2);
      switch (result.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse":
          return result.value === void 0 ? void 0 : { partial: result.value };
      }
    },
    createElementStreamTransform() {
      return;
    }
  };
};
async function parseToolCall({
  toolCall,
  tools,
  repairToolCall,
  system,
  messages
}) {
  var _a21;
  try {
    if (tools == null) {
      if (toolCall.providerExecuted && toolCall.dynamic)
        return await parseProviderExecutedDynamicToolCall(toolCall);
      throw new NoSuchToolError({ toolName: toolCall.toolName });
    }
    try {
      return await doParseToolCall({ toolCall, tools });
    } catch (error48) {
      if (repairToolCall == null || !(NoSuchToolError.isInstance(error48) || InvalidToolInputError.isInstance(error48)))
        throw error48;
      let repairedToolCall = null;
      try {
        repairedToolCall = await repairToolCall({
          toolCall,
          tools,
          inputSchema: async ({ toolName }) => {
            let { inputSchema } = tools[toolName];
            return await asSchema(inputSchema).jsonSchema;
          },
          system,
          messages,
          error: error48
        });
      } catch (repairError) {
        throw new ToolCallRepairError({
          cause: repairError,
          originalError: error48
        });
      }
      if (repairedToolCall == null)
        throw error48;
      return await doParseToolCall({ toolCall: repairedToolCall, tools });
    }
  } catch (error48) {
    let parsedInput = await safeParseJSON({ text: toolCall.input }), input = parsedInput.success ? parsedInput.value : toolCall.input;
    return {
      type: "tool-call",
      toolCallId: toolCall.toolCallId,
      toolName: toolCall.toolName,
      input,
      dynamic: !0,
      invalid: !0,
      error: error48,
      title: (_a21 = tools == null ? void 0 : tools[toolCall.toolName]) == null ? void 0 : _a21.title,
      providerExecuted: toolCall.providerExecuted,
      providerMetadata: toolCall.providerMetadata
    };
  }
}
async function parseProviderExecutedDynamicToolCall(toolCall) {
  let parseResult = toolCall.input.trim() === "" ? { success: !0, value: {} } : await safeParseJSON({ text: toolCall.input });
  if (parseResult.success === !1)
    throw new InvalidToolInputError({
      toolName: toolCall.toolName,
      toolInput: toolCall.input,
      cause: parseResult.error
    });
  return {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName: toolCall.toolName,
    input: parseResult.value,
    providerExecuted: !0,
    dynamic: !0,
    providerMetadata: toolCall.providerMetadata
  };
}
async function doParseToolCall({
  toolCall,
  tools
}) {
  let toolName = toolCall.toolName, tool2 = tools[toolName];
  if (tool2 == null) {
    if (toolCall.providerExecuted && toolCall.dynamic)
      return await parseProviderExecutedDynamicToolCall(toolCall);
    throw new NoSuchToolError({
      toolName: toolCall.toolName,
      availableTools: Object.keys(tools)
    });
  }
  let schema = asSchema(tool2.inputSchema), parseResult = toolCall.input.trim() === "" ? await safeValidateTypes({ value: {}, schema }) : await safeParseJSON({ text: toolCall.input, schema });
  if (parseResult.success === !1)
    throw new InvalidToolInputError({
      toolName,
      toolInput: toolCall.input,
      cause: parseResult.error
    });
  return tool2.type === "dynamic" ? {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName: toolCall.toolName,
    input: parseResult.value,
    providerExecuted: toolCall.providerExecuted,
    providerMetadata: toolCall.providerMetadata,
    dynamic: !0,
    title: tool2.title
  } : {
    type: "tool-call",
    toolCallId: toolCall.toolCallId,
    toolName,
    input: parseResult.value,
    providerExecuted: toolCall.providerExecuted,
    providerMetadata: toolCall.providerMetadata,
    title: tool2.title
  };
}
var DefaultStepResult = class {
  constructor({
    content,
    finishReason,
    rawFinishReason,
    usage,
    warnings,
    request,
    response,
    providerMetadata
  }) {
    this.content = content, this.finishReason = finishReason, this.rawFinishReason = rawFinishReason, this.usage = usage, this.warnings = warnings, this.request = request, this.response = response, this.providerMetadata = providerMetadata;
  }
  get text() {
    return this.content.filter((part) => part.type === "text").map((part) => part.text).join("");
  }
  get reasoning() {
    return this.content.filter((part) => part.type === "reasoning");
  }
  get reasoningText() {
    return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join("");
  }
  get files() {
    return this.content.filter((part) => part.type === "file").map((part) => part.file);
  }
  get sources() {
    return this.content.filter((part) => part.type === "source");
  }
  get toolCalls() {
    return this.content.filter((part) => part.type === "tool-call");
  }
  get staticToolCalls() {
    return this.toolCalls.filter((toolCall) => toolCall.dynamic !== !0);
  }
  get dynamicToolCalls() {
    return this.toolCalls.filter((toolCall) => toolCall.dynamic === !0);
  }
  get toolResults() {
    return this.content.filter((part) => part.type === "tool-result");
  }
  get staticToolResults() {
    return this.toolResults.filter((toolResult) => toolResult.dynamic !== !0);
  }
  get dynamicToolResults() {
    return this.toolResults.filter((toolResult) => toolResult.dynamic === !0);
  }
};
function stepCountIs(stepCount) {
  return ({ steps }) => steps.length === stepCount;
}
async function isStopConditionMet({
  stopConditions,
  steps
}) {
  return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);
}
async function toResponseMessages({
  content: inputContent,
  tools
}) {
  let responseMessages = [], content = [];
  for (let part of inputContent) {
    if (part.type === "source")
      continue;
    if ((part.type === "tool-result" || part.type === "tool-error") && !part.providerExecuted)
      continue;
    if (part.type === "text" && part.text.length === 0)
      continue;
    switch (part.type) {
      case "text":
        content.push({
          type: "text",
          text: part.text,
          providerOptions: part.providerMetadata
        });
        break;
      case "reasoning":
        content.push({
          type: "reasoning",
          text: part.text,
          providerOptions: part.providerMetadata
        });
        break;
      case "file":
        content.push({
          type: "file",
          data: part.file.base64,
          mediaType: part.file.mediaType,
          providerOptions: part.providerMetadata
        });
        break;
      case "tool-call":
        content.push({
          type: "tool-call",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          input: part.input,
          providerExecuted: part.providerExecuted,
          providerOptions: part.providerMetadata
        });
        break;
      case "tool-result": {
        let output = await createToolModelOutput({
          toolCallId: part.toolCallId,
          input: part.input,
          tool: tools == null ? void 0 : tools[part.toolName],
          output: part.output,
          errorMode: "none"
        });
        content.push({
          type: "tool-result",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          output,
          providerOptions: part.providerMetadata
        });
        break;
      }
      case "tool-error": {
        let output = await createToolModelOutput({
          toolCallId: part.toolCallId,
          input: part.input,
          tool: tools == null ? void 0 : tools[part.toolName],
          output: part.error,
          errorMode: "json"
        });
        content.push({
          type: "tool-result",
          toolCallId: part.toolCallId,
          toolName: part.toolName,
          output,
          providerOptions: part.providerMetadata
        });
        break;
      }
      case "tool-approval-request":
        content.push({
          type: "tool-approval-request",
          approvalId: part.approvalId,
          toolCallId: part.toolCall.toolCallId
        });
        break;
    }
  }
  if (content.length > 0)
    responseMessages.push({
      role: "assistant",
      content
    });
  let toolResultContent = [];
  for (let part of inputContent) {
    if (!(part.type === "tool-result" || part.type === "tool-error") || part.providerExecuted)
      continue;
    let output = await createToolModelOutput({
      toolCallId: part.toolCallId,
      input: part.input,
      tool: tools == null ? void 0 : tools[part.toolName],
      output: part.type === "tool-result" ? part.output : part.error,
      errorMode: part.type === "tool-error" ? "text" : "none"
    });
    toolResultContent.push({
      type: "tool-result",
      toolCallId: part.toolCallId,
      toolName: part.toolName,
      output,
      ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}
    });
  }
  if (toolResultContent.length > 0)
    responseMessages.push({
      role: "tool",
      content: toolResultContent
    });
  return responseMessages;
}
function mergeAbortSignals(...signals) {
  let validSignals = signals.filter((signal) => signal != null);
  if (validSignals.length === 0)
    return;
  if (validSignals.length === 1)
    return validSignals[0];
  let controller = new AbortController;
  for (let signal of validSignals) {
    if (signal.aborted)
      return controller.abort(signal.reason), controller.signal;
    signal.addEventListener("abort", () => {
      controller.abort(signal.reason);
    }, { once: !0 });
  }
  return controller.signal;
}
var originalGenerateId = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
async function generateText({
  model: modelArg,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries: maxRetriesArg,
  abortSignal,
  timeout,
  headers,
  stopWhen = stepCountIs(1),
  experimental_output,
  output = experimental_output,
  experimental_telemetry: telemetry,
  providerOptions,
  experimental_activeTools,
  activeTools = experimental_activeTools,
  experimental_prepareStep,
  prepareStep = experimental_prepareStep,
  experimental_repairToolCall: repairToolCall,
  experimental_download: download2,
  experimental_context,
  experimental_include: include,
  _internal: { generateId: generateId2 = originalGenerateId } = {},
  onStepFinish,
  onFinish,
  ...settings
}) {
  let model = resolveLanguageModel(modelArg), stopConditions = asArray(stopWhen), totalTimeoutMs = getTotalTimeoutMs(timeout), stepTimeoutMs = getStepTimeoutMs(timeout), stepAbortController = stepTimeoutMs != null ? new AbortController : void 0, mergedAbortSignal = mergeAbortSignals(abortSignal, totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0, stepAbortController == null ? void 0 : stepAbortController.signal), { maxRetries, retry } = prepareRetries({
    maxRetries: maxRetriesArg,
    abortSignal: mergedAbortSignal
  }), callSettings = prepareCallSettings(settings), headersWithUserAgent = withUserAgentSuffix(headers != null ? headers : {}, `ai/${VERSION4}`), baseTelemetryAttributes = getBaseTelemetryAttributes({
    model,
    telemetry,
    headers: headersWithUserAgent,
    settings: { ...callSettings, maxRetries }
  }), initialPrompt = await standardizePrompt({
    system,
    prompt,
    messages
  }), tracer = getTracer(telemetry);
  try {
    return await recordSpan({
      name: "ai.generateText",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({
            operationId: "ai.generateText",
            telemetry
          }),
          ...baseTelemetryAttributes,
          "ai.model.provider": model.provider,
          "ai.model.id": model.modelId,
          "ai.prompt": {
            input: () => JSON.stringify({ system, prompt, messages })
          }
        }
      }),
      tracer,
      fn: async (span) => {
        var _a21, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        let initialMessages = initialPrompt.messages, responseMessages = [], { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({ messages: initialMessages }), localApprovedToolApprovals = approvedToolApprovals.filter((toolApproval) => !toolApproval.toolCall.providerExecuted);
        if (deniedToolApprovals.length > 0 || localApprovedToolApprovals.length > 0) {
          let toolOutputs = await executeTools({
            toolCalls: localApprovedToolApprovals.map((toolApproval) => toolApproval.toolCall),
            tools,
            tracer,
            telemetry,
            messages: initialMessages,
            abortSignal: mergedAbortSignal,
            experimental_context
          }), toolContent = [];
          for (let output2 of toolOutputs) {
            let modelOutput = await createToolModelOutput({
              toolCallId: output2.toolCallId,
              input: output2.input,
              tool: tools == null ? void 0 : tools[output2.toolName],
              output: output2.type === "tool-result" ? output2.output : output2.error,
              errorMode: output2.type === "tool-error" ? "json" : "none"
            });
            toolContent.push({
              type: "tool-result",
              toolCallId: output2.toolCallId,
              toolName: output2.toolName,
              output: modelOutput
            });
          }
          for (let toolApproval of deniedToolApprovals)
            toolContent.push({
              type: "tool-result",
              toolCallId: toolApproval.toolCall.toolCallId,
              toolName: toolApproval.toolCall.toolName,
              output: {
                type: "execution-denied",
                reason: toolApproval.approvalResponse.reason,
                ...toolApproval.toolCall.providerExecuted && {
                  providerOptions: {
                    openai: {
                      approvalId: toolApproval.approvalResponse.approvalId
                    }
                  }
                }
              }
            });
          responseMessages.push({
            role: "tool",
            content: toolContent
          });
        }
        let providerExecutedToolApprovals = [
          ...approvedToolApprovals,
          ...deniedToolApprovals
        ].filter((toolApproval) => toolApproval.toolCall.providerExecuted);
        if (providerExecutedToolApprovals.length > 0)
          responseMessages.push({
            role: "tool",
            content: providerExecutedToolApprovals.map((toolApproval) => ({
              type: "tool-approval-response",
              approvalId: toolApproval.approvalResponse.approvalId,
              approved: toolApproval.approvalResponse.approved,
              reason: toolApproval.approvalResponse.reason,
              providerExecuted: !0
            }))
          });
        let callSettings2 = prepareCallSettings(settings), currentModelResponse, clientToolCalls = [], clientToolOutputs = [], steps = [], pendingDeferredToolCalls = /* @__PURE__ */ new Map;
        do {
          let stepTimeoutId = stepTimeoutMs != null ? setTimeout(() => stepAbortController.abort(), stepTimeoutMs) : void 0;
          try {
            let stepInputMessages = [...initialMessages, ...responseMessages], prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
              model,
              steps,
              stepNumber: steps.length,
              messages: stepInputMessages,
              experimental_context
            })), stepModel = resolveLanguageModel((_a21 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a21 : model), promptMessages = await convertToLanguageModelPrompt({
              prompt: {
                system: (_b16 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b16 : initialPrompt.system,
                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages
              },
              supportedUrls: await stepModel.supportedUrls,
              download: download2
            });
            experimental_context = (_d = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _d : experimental_context;
            let { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({
              tools,
              toolChoice: (_e = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _e : toolChoice,
              activeTools: (_f = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _f : activeTools
            });
            currentModelResponse = await retry(() => {
              var _a222;
              return recordSpan({
                name: "ai.generateText.doGenerate",
                attributes: selectTelemetryAttributes({
                  telemetry,
                  attributes: {
                    ...assembleOperationName({
                      operationId: "ai.generateText.doGenerate",
                      telemetry
                    }),
                    ...baseTelemetryAttributes,
                    "ai.model.provider": stepModel.provider,
                    "ai.model.id": stepModel.modelId,
                    "ai.prompt.messages": {
                      input: () => stringifyForTelemetry(promptMessages)
                    },
                    "ai.prompt.tools": {
                      input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))
                    },
                    "ai.prompt.toolChoice": {
                      input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                    },
                    "gen_ai.system": stepModel.provider,
                    "gen_ai.request.model": stepModel.modelId,
                    "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                    "gen_ai.request.max_tokens": settings.maxOutputTokens,
                    "gen_ai.request.presence_penalty": settings.presencePenalty,
                    "gen_ai.request.stop_sequences": settings.stopSequences,
                    "gen_ai.request.temperature": (_a222 = settings.temperature) != null ? _a222 : void 0,
                    "gen_ai.request.top_k": settings.topK,
                    "gen_ai.request.top_p": settings.topP
                  }
                }),
                tracer,
                fn: async (span2) => {
                  var _a232, _b23, _c2, _d2, _e2, _f2, _g2, _h2;
                  let stepProviderOptions = mergeObjects(providerOptions, prepareStepResult == null ? void 0 : prepareStepResult.providerOptions), result = await stepModel.doGenerate({
                    ...callSettings2,
                    tools: stepTools,
                    toolChoice: stepToolChoice,
                    responseFormat: await (output == null ? void 0 : output.responseFormat),
                    prompt: promptMessages,
                    providerOptions: stepProviderOptions,
                    abortSignal: mergedAbortSignal,
                    headers: headersWithUserAgent
                  }), responseData = {
                    id: (_b23 = (_a232 = result.response) == null ? void 0 : _a232.id) != null ? _b23 : generateId2(),
                    timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : /* @__PURE__ */ new Date,
                    modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,
                    headers: (_g2 = result.response) == null ? void 0 : _g2.headers,
                    body: (_h2 = result.response) == null ? void 0 : _h2.body
                  };
                  return span2.setAttributes(await selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.response.finishReason": result.finishReason.unified,
                      "ai.response.text": {
                        output: () => extractTextContent(result.content)
                      },
                      "ai.response.toolCalls": {
                        output: () => {
                          let toolCalls = asToolCalls(result.content);
                          return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
                        }
                      },
                      "ai.response.id": responseData.id,
                      "ai.response.model": responseData.modelId,
                      "ai.response.timestamp": responseData.timestamp.toISOString(),
                      "ai.response.providerMetadata": JSON.stringify(result.providerMetadata),
                      "ai.usage.promptTokens": result.usage.inputTokens.total,
                      "ai.usage.completionTokens": result.usage.outputTokens.total,
                      "gen_ai.response.finish_reasons": [
                        result.finishReason.unified
                      ],
                      "gen_ai.response.id": responseData.id,
                      "gen_ai.response.model": responseData.modelId,
                      "gen_ai.usage.input_tokens": result.usage.inputTokens.total,
                      "gen_ai.usage.output_tokens": result.usage.outputTokens.total
                    }
                  })), { ...result, response: responseData };
                }
              });
            });
            let stepToolCalls = await Promise.all(currentModelResponse.content.filter((part) => part.type === "tool-call").map((toolCall) => parseToolCall({
              toolCall,
              tools,
              repairToolCall,
              system,
              messages: stepInputMessages
            }))), toolApprovalRequests = {};
            for (let toolCall of stepToolCalls) {
              if (toolCall.invalid)
                continue;
              let tool2 = tools == null ? void 0 : tools[toolCall.toolName];
              if (tool2 == null)
                continue;
              if ((tool2 == null ? void 0 : tool2.onInputAvailable) != null)
                await tool2.onInputAvailable({
                  input: toolCall.input,
                  toolCallId: toolCall.toolCallId,
                  messages: stepInputMessages,
                  abortSignal: mergedAbortSignal,
                  experimental_context
                });
              if (await isApprovalNeeded({
                tool: tool2,
                toolCall,
                messages: stepInputMessages,
                experimental_context
              }))
                toolApprovalRequests[toolCall.toolCallId] = {
                  type: "tool-approval-request",
                  approvalId: generateId2(),
                  toolCall
                };
            }
            let invalidToolCalls = stepToolCalls.filter((toolCall) => toolCall.invalid && toolCall.dynamic);
            clientToolOutputs = [];
            for (let toolCall of invalidToolCalls)
              clientToolOutputs.push({
                type: "tool-error",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                input: toolCall.input,
                error: getErrorMessage2(toolCall.error),
                dynamic: !0
              });
            if (clientToolCalls = stepToolCalls.filter((toolCall) => !toolCall.providerExecuted), tools != null)
              clientToolOutputs.push(...await executeTools({
                toolCalls: clientToolCalls.filter((toolCall) => !toolCall.invalid && toolApprovalRequests[toolCall.toolCallId] == null),
                tools,
                tracer,
                telemetry,
                messages: stepInputMessages,
                abortSignal: mergedAbortSignal,
                experimental_context
              }));
            for (let toolCall of stepToolCalls) {
              if (!toolCall.providerExecuted)
                continue;
              let tool2 = tools == null ? void 0 : tools[toolCall.toolName];
              if ((tool2 == null ? void 0 : tool2.type) === "provider" && tool2.supportsDeferredResults) {
                if (!currentModelResponse.content.some((part) => part.type === "tool-result" && part.toolCallId === toolCall.toolCallId))
                  pendingDeferredToolCalls.set(toolCall.toolCallId, {
                    toolName: toolCall.toolName
                  });
              }
            }
            for (let part of currentModelResponse.content)
              if (part.type === "tool-result")
                pendingDeferredToolCalls.delete(part.toolCallId);
            let stepContent = asContent({
              content: currentModelResponse.content,
              toolCalls: stepToolCalls,
              toolOutputs: clientToolOutputs,
              toolApprovalRequests: Object.values(toolApprovalRequests),
              tools
            });
            responseMessages.push(...await toResponseMessages({
              content: stepContent,
              tools
            }));
            let stepRequest = ((_g = include == null ? void 0 : include.requestBody) != null ? _g : !0) ? (_h = currentModelResponse.request) != null ? _h : {} : { ...currentModelResponse.request, body: void 0 }, stepResponse = {
              ...currentModelResponse.response,
              messages: structuredClone(responseMessages),
              body: ((_i = include == null ? void 0 : include.responseBody) != null ? _i : !0) ? (_j = currentModelResponse.response) == null ? void 0 : _j.body : void 0
            }, currentStepResult = new DefaultStepResult({
              content: stepContent,
              finishReason: currentModelResponse.finishReason.unified,
              rawFinishReason: currentModelResponse.finishReason.raw,
              usage: asLanguageModelUsage(currentModelResponse.usage),
              warnings: currentModelResponse.warnings,
              providerMetadata: currentModelResponse.providerMetadata,
              request: stepRequest,
              response: stepResponse
            });
            logWarnings({
              warnings: (_k = currentModelResponse.warnings) != null ? _k : [],
              provider: stepModel.provider,
              model: stepModel.modelId
            }), steps.push(currentStepResult), await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
          } finally {
            if (stepTimeoutId != null)
              clearTimeout(stepTimeoutId);
          }
        } while ((clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && !await isStopConditionMet({ stopConditions, steps }));
        span.setAttributes(await selectTelemetryAttributes({
          telemetry,
          attributes: {
            "ai.response.finishReason": currentModelResponse.finishReason.unified,
            "ai.response.text": {
              output: () => extractTextContent(currentModelResponse.content)
            },
            "ai.response.toolCalls": {
              output: () => {
                let toolCalls = asToolCalls(currentModelResponse.content);
                return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
              }
            },
            "ai.response.providerMetadata": JSON.stringify(currentModelResponse.providerMetadata),
            "ai.usage.promptTokens": currentModelResponse.usage.inputTokens.total,
            "ai.usage.completionTokens": currentModelResponse.usage.outputTokens.total
          }
        }));
        let lastStep = steps[steps.length - 1], totalUsage = steps.reduce((totalUsage2, step) => {
          return addLanguageModelUsage(totalUsage2, step.usage);
        }, {
          inputTokens: void 0,
          outputTokens: void 0,
          totalTokens: void 0,
          reasoningTokens: void 0,
          cachedInputTokens: void 0
        });
        await (onFinish == null ? void 0 : onFinish({
          finishReason: lastStep.finishReason,
          rawFinishReason: lastStep.rawFinishReason,
          usage: lastStep.usage,
          content: lastStep.content,
          text: lastStep.text,
          reasoningText: lastStep.reasoningText,
          reasoning: lastStep.reasoning,
          files: lastStep.files,
          sources: lastStep.sources,
          toolCalls: lastStep.toolCalls,
          staticToolCalls: lastStep.staticToolCalls,
          dynamicToolCalls: lastStep.dynamicToolCalls,
          toolResults: lastStep.toolResults,
          staticToolResults: lastStep.staticToolResults,
          dynamicToolResults: lastStep.dynamicToolResults,
          request: lastStep.request,
          response: lastStep.response,
          warnings: lastStep.warnings,
          providerMetadata: lastStep.providerMetadata,
          steps,
          totalUsage,
          experimental_context
        }));
        let resolvedOutput;
        if (lastStep.finishReason === "stop")
          resolvedOutput = await (output != null ? output : text()).parseCompleteOutput({ text: lastStep.text }, {
            response: lastStep.response,
            usage: lastStep.usage,
            finishReason: lastStep.finishReason
          });
        return new DefaultGenerateTextResult({
          steps,
          totalUsage,
          output: resolvedOutput
        });
      }
    });
  } catch (error48) {
    throw wrapGatewayError(error48);
  }
}
async function executeTools({
  toolCalls,
  tools,
  tracer,
  telemetry,
  messages,
  abortSignal,
  experimental_context
}) {
  return (await Promise.all(toolCalls.map(async (toolCall) => executeToolCall({
    toolCall,
    tools,
    tracer,
    telemetry,
    messages,
    abortSignal,
    experimental_context
  })))).filter((output) => output != null);
}
var DefaultGenerateTextResult = class {
  constructor(options) {
    this.steps = options.steps, this._output = options.output, this.totalUsage = options.totalUsage;
  }
  get finalStep() {
    return this.steps[this.steps.length - 1];
  }
  get content() {
    return this.finalStep.content;
  }
  get text() {
    return this.finalStep.text;
  }
  get files() {
    return this.finalStep.files;
  }
  get reasoningText() {
    return this.finalStep.reasoningText;
  }
  get reasoning() {
    return this.finalStep.reasoning;
  }
  get toolCalls() {
    return this.finalStep.toolCalls;
  }
  get staticToolCalls() {
    return this.finalStep.staticToolCalls;
  }
  get dynamicToolCalls() {
    return this.finalStep.dynamicToolCalls;
  }
  get toolResults() {
    return this.finalStep.toolResults;
  }
  get staticToolResults() {
    return this.finalStep.staticToolResults;
  }
  get dynamicToolResults() {
    return this.finalStep.dynamicToolResults;
  }
  get sources() {
    return this.finalStep.sources;
  }
  get finishReason() {
    return this.finalStep.finishReason;
  }
  get rawFinishReason() {
    return this.finalStep.rawFinishReason;
  }
  get warnings() {
    return this.finalStep.warnings;
  }
  get providerMetadata() {
    return this.finalStep.providerMetadata;
  }
  get response() {
    return this.finalStep.response;
  }
  get request() {
    return this.finalStep.request;
  }
  get usage() {
    return this.finalStep.usage;
  }
  get experimental_output() {
    return this.output;
  }
  get output() {
    if (this._output == null)
      throw new NoOutputGeneratedError;
    return this._output;
  }
};
function asToolCalls(content) {
  let parts = content.filter((part) => part.type === "tool-call");
  if (parts.length === 0)
    return;
  return parts.map((toolCall) => ({
    toolCallId: toolCall.toolCallId,
    toolName: toolCall.toolName,
    input: toolCall.input
  }));
}
function asContent({
  content,
  toolCalls,
  toolOutputs,
  toolApprovalRequests,
  tools
}) {
  let contentParts = [];
  for (let part of content)
    switch (part.type) {
      case "text":
      case "reasoning":
      case "source":
        contentParts.push(part);
        break;
      case "file": {
        contentParts.push({
          type: "file",
          file: new DefaultGeneratedFile(part),
          ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
        });
        break;
      }
      case "tool-call": {
        contentParts.push(toolCalls.find((toolCall) => toolCall.toolCallId === part.toolCallId));
        break;
      }
      case "tool-result": {
        let toolCall = toolCalls.find((toolCall2) => toolCall2.toolCallId === part.toolCallId);
        if (toolCall == null) {
          let tool2 = tools == null ? void 0 : tools[part.toolName];
          if (!((tool2 == null ? void 0 : tool2.type) === "provider" && tool2.supportsDeferredResults))
            throw Error(`Tool call ${part.toolCallId} not found.`);
          if (part.isError)
            contentParts.push({
              type: "tool-error",
              toolCallId: part.toolCallId,
              toolName: part.toolName,
              input: void 0,
              error: part.result,
              providerExecuted: !0,
              dynamic: part.dynamic
            });
          else
            contentParts.push({
              type: "tool-result",
              toolCallId: part.toolCallId,
              toolName: part.toolName,
              input: void 0,
              output: part.result,
              providerExecuted: !0,
              dynamic: part.dynamic
            });
          break;
        }
        if (part.isError)
          contentParts.push({
            type: "tool-error",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            input: toolCall.input,
            error: part.result,
            providerExecuted: !0,
            dynamic: toolCall.dynamic
          });
        else
          contentParts.push({
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            input: toolCall.input,
            output: part.result,
            providerExecuted: !0,
            dynamic: toolCall.dynamic
          });
        break;
      }
      case "tool-approval-request": {
        let toolCall = toolCalls.find((toolCall2) => toolCall2.toolCallId === part.toolCallId);
        if (toolCall == null)
          throw new ToolCallNotFoundForApprovalError({
            toolCallId: part.toolCallId,
            approvalId: part.approvalId
          });
        contentParts.push({
          type: "tool-approval-request",
          approvalId: part.approvalId,
          toolCall
        });
        break;
      }
    }
  return [...contentParts, ...toolOutputs, ...toolApprovalRequests];
}
function prepareHeaders(headers, defaultHeaders) {
  let responseHeaders = new Headers(headers != null ? headers : {});
  for (let [key, value] of Object.entries(defaultHeaders))
    if (!responseHeaders.has(key))
      responseHeaders.set(key, value);
  return responseHeaders;
}
function createTextStreamResponse({
  status,
  statusText,
  headers,
  textStream
}) {
  return new Response(textStream.pipeThrough(new TextEncoderStream), {
    status: status != null ? status : 200,
    statusText,
    headers: prepareHeaders(headers, {
      "content-type": "text/plain; charset=utf-8"
    })
  });
}
function writeToServerResponse({
  response,
  status,
  statusText,
  headers,
  stream
}) {
  let statusCode = status != null ? status : 200;
  if (statusText !== void 0)
    response.writeHead(statusCode, statusText, headers);
  else
    response.writeHead(statusCode, headers);
  let reader = stream.getReader();
  (async () => {
    try {
      while (!0) {
        let { done, value } = await reader.read();
        if (done)
          break;
        if (!response.write(value))
          await new Promise((resolve3) => {
            response.once("drain", resolve3);
          });
      }
    } catch (error48) {
      throw error48;
    } finally {
      response.end();
    }
  })();
}
function pipeTextStreamToResponse({
  response,
  status,
  statusText,
  headers,
  textStream
}) {
  writeToServerResponse({
    response,
    status,
    statusText,
    headers: Object.fromEntries(prepareHeaders(headers, {
      "content-type": "text/plain; charset=utf-8"
    }).entries()),
    stream: textStream.pipeThrough(new TextEncoderStream)
  });
}
var JsonToSseTransformStream = class extends TransformStream {
  constructor() {
    super({
      transform(part, controller) {
        controller.enqueue(`data: ${JSON.stringify(part)}

`);
      },
      flush(controller) {
        controller.enqueue(`data: [DONE]

`);
      }
    });
  }
}, UI_MESSAGE_STREAM_HEADERS = {
  "content-type": "text/event-stream",
  "cache-control": "no-cache",
  connection: "keep-alive",
  "x-vercel-ai-ui-message-stream": "v1",
  "x-accel-buffering": "no"
};
function createUIMessageStreamResponse({
  status,
  statusText,
  headers,
  stream,
  consumeSseStream
}) {
  let sseStream = stream.pipeThrough(new JsonToSseTransformStream);
  if (consumeSseStream) {
    let [stream1, stream2] = sseStream.tee();
    sseStream = stream1, consumeSseStream({ stream: stream2 });
  }
  return new Response(sseStream.pipeThrough(new TextEncoderStream), {
    status,
    statusText,
    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)
  });
}
function getResponseUIMessageId({
  originalMessages,
  responseMessageId
}) {
  if (originalMessages == null)
    return;
  let lastMessage = originalMessages[originalMessages.length - 1];
  return (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage.id : typeof responseMessageId === "function" ? responseMessageId() : responseMessageId;
}
var uiMessageChunkSchema = lazySchema(() => zodSchema(exports_external.union([
  exports_external.strictObject({
    type: exports_external.literal("text-start"),
    id: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("text-delta"),
    id: exports_external.string(),
    delta: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("text-end"),
    id: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("error"),
    errorText: exports_external.string()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-input-start"),
    toolCallId: exports_external.string(),
    toolName: exports_external.string(),
    providerExecuted: exports_external.boolean().optional(),
    providerMetadata: providerMetadataSchema.optional(),
    dynamic: exports_external.boolean().optional(),
    title: exports_external.string().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-input-delta"),
    toolCallId: exports_external.string(),
    inputTextDelta: exports_external.string()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-input-available"),
    toolCallId: exports_external.string(),
    toolName: exports_external.string(),
    input: exports_external.unknown(),
    providerExecuted: exports_external.boolean().optional(),
    providerMetadata: providerMetadataSchema.optional(),
    dynamic: exports_external.boolean().optional(),
    title: exports_external.string().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-input-error"),
    toolCallId: exports_external.string(),
    toolName: exports_external.string(),
    input: exports_external.unknown(),
    providerExecuted: exports_external.boolean().optional(),
    providerMetadata: providerMetadataSchema.optional(),
    dynamic: exports_external.boolean().optional(),
    errorText: exports_external.string(),
    title: exports_external.string().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-approval-request"),
    approvalId: exports_external.string(),
    toolCallId: exports_external.string()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-output-available"),
    toolCallId: exports_external.string(),
    output: exports_external.unknown(),
    providerExecuted: exports_external.boolean().optional(),
    dynamic: exports_external.boolean().optional(),
    preliminary: exports_external.boolean().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-output-error"),
    toolCallId: exports_external.string(),
    errorText: exports_external.string(),
    providerExecuted: exports_external.boolean().optional(),
    dynamic: exports_external.boolean().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("tool-output-denied"),
    toolCallId: exports_external.string()
  }),
  exports_external.strictObject({
    type: exports_external.literal("reasoning-start"),
    id: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("reasoning-delta"),
    id: exports_external.string(),
    delta: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("reasoning-end"),
    id: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("source-url"),
    sourceId: exports_external.string(),
    url: exports_external.string(),
    title: exports_external.string().optional(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("source-document"),
    sourceId: exports_external.string(),
    mediaType: exports_external.string(),
    title: exports_external.string(),
    filename: exports_external.string().optional(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("file"),
    url: exports_external.string(),
    mediaType: exports_external.string(),
    providerMetadata: providerMetadataSchema.optional()
  }),
  exports_external.strictObject({
    type: exports_external.custom((value) => typeof value === "string" && value.startsWith("data-"), { message: 'Type must start with "data-"' }),
    id: exports_external.string().optional(),
    data: exports_external.unknown(),
    transient: exports_external.boolean().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("start-step")
  }),
  exports_external.strictObject({
    type: exports_external.literal("finish-step")
  }),
  exports_external.strictObject({
    type: exports_external.literal("start"),
    messageId: exports_external.string().optional(),
    messageMetadata: exports_external.unknown().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("finish"),
    finishReason: exports_external.enum([
      "stop",
      "length",
      "content-filter",
      "tool-calls",
      "error",
      "other"
    ]).optional(),
    messageMetadata: exports_external.unknown().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("abort"),
    reason: exports_external.string().optional()
  }),
  exports_external.strictObject({
    type: exports_external.literal("message-metadata"),
    messageMetadata: exports_external.unknown()
  })
])));
function isDataUIMessageChunk(chunk) {
  return chunk.type.startsWith("data-");
}
function isStaticToolUIPart(part) {
  return part.type.startsWith("tool-");
}
function isDynamicToolUIPart(part) {
  return part.type === "dynamic-tool";
}
function isToolUIPart(part) {
  return isStaticToolUIPart(part) || isDynamicToolUIPart(part);
}
function getStaticToolName(part) {
  return part.type.split("-").slice(1).join("-");
}
function createStreamingUIMessageState({
  lastMessage,
  messageId
}) {
  return {
    message: (lastMessage == null ? void 0 : lastMessage.role) === "assistant" ? lastMessage : {
      id: messageId,
      metadata: void 0,
      role: "assistant",
      parts: []
    },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {}
  };
}
function processUIMessageStream({
  stream,
  messageMetadataSchema,
  dataPartSchemas,
  runUpdateMessageJob,
  onError,
  onToolCall,
  onData
}) {
  return stream.pipeThrough(new TransformStream({
    async transform(chunk, controller) {
      await runUpdateMessageJob(async ({ state, write }) => {
        var _a21, _b16, _c, _d;
        function getToolInvocation(toolCallId) {
          let toolInvocation = state.message.parts.filter(isToolUIPart).find((invocation) => invocation.toolCallId === toolCallId);
          if (toolInvocation == null)
            throw new UIMessageStreamError({
              chunkType: "tool-invocation",
              chunkId: toolCallId,
              message: `No tool invocation found for tool call ID "${toolCallId}".`
            });
          return toolInvocation;
        }
        function updateToolPart(options) {
          var _a222;
          let part = state.message.parts.find((part2) => isStaticToolUIPart(part2) && part2.toolCallId === options.toolCallId), anyOptions = options, anyPart = part;
          if (part != null) {
            if (part.state = options.state, anyPart.input = anyOptions.input, anyPart.output = anyOptions.output, anyPart.errorText = anyOptions.errorText, anyPart.rawInput = anyOptions.rawInput, anyPart.preliminary = anyOptions.preliminary, options.title !== void 0)
              anyPart.title = options.title;
            if (anyPart.providerExecuted = (_a222 = anyOptions.providerExecuted) != null ? _a222 : part.providerExecuted, anyOptions.providerMetadata != null)
              part.callProviderMetadata = anyOptions.providerMetadata;
          } else
            state.message.parts.push({
              type: `tool-${options.toolName}`,
              toolCallId: options.toolCallId,
              state: options.state,
              title: options.title,
              input: anyOptions.input,
              output: anyOptions.output,
              rawInput: anyOptions.rawInput,
              errorText: anyOptions.errorText,
              providerExecuted: anyOptions.providerExecuted,
              preliminary: anyOptions.preliminary,
              ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
            });
        }
        function updateDynamicToolPart(options) {
          var _a222, _b23;
          let part = state.message.parts.find((part2) => part2.type === "dynamic-tool" && part2.toolCallId === options.toolCallId), anyOptions = options, anyPart = part;
          if (part != null) {
            if (part.state = options.state, anyPart.toolName = options.toolName, anyPart.input = anyOptions.input, anyPart.output = anyOptions.output, anyPart.errorText = anyOptions.errorText, anyPart.rawInput = (_a222 = anyOptions.rawInput) != null ? _a222 : anyPart.rawInput, anyPart.preliminary = anyOptions.preliminary, options.title !== void 0)
              anyPart.title = options.title;
            if (anyPart.providerExecuted = (_b23 = anyOptions.providerExecuted) != null ? _b23 : part.providerExecuted, anyOptions.providerMetadata != null)
              part.callProviderMetadata = anyOptions.providerMetadata;
          } else
            state.message.parts.push({
              type: "dynamic-tool",
              toolName: options.toolName,
              toolCallId: options.toolCallId,
              state: options.state,
              input: anyOptions.input,
              output: anyOptions.output,
              errorText: anyOptions.errorText,
              preliminary: anyOptions.preliminary,
              providerExecuted: anyOptions.providerExecuted,
              title: options.title,
              ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}
            });
        }
        async function updateMessageMetadata(metadata) {
          if (metadata != null) {
            let mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;
            if (messageMetadataSchema != null)
              await validateTypes({
                value: mergedMetadata,
                schema: messageMetadataSchema,
                context: {
                  field: "message.metadata",
                  entityId: state.message.id
                }
              });
            state.message.metadata = mergedMetadata;
          }
        }
        switch (chunk.type) {
          case "text-start": {
            let textPart = {
              type: "text",
              text: "",
              providerMetadata: chunk.providerMetadata,
              state: "streaming"
            };
            state.activeTextParts[chunk.id] = textPart, state.message.parts.push(textPart), write();
            break;
          }
          case "text-delta": {
            let textPart = state.activeTextParts[chunk.id];
            if (textPart == null)
              throw new UIMessageStreamError({
                chunkType: "text-delta",
                chunkId: chunk.id,
                message: `Received text-delta for missing text part with ID "${chunk.id}". Ensure a "text-start" chunk is sent before any "text-delta" chunks.`
              });
            textPart.text += chunk.delta, textPart.providerMetadata = (_a21 = chunk.providerMetadata) != null ? _a21 : textPart.providerMetadata, write();
            break;
          }
          case "text-end": {
            let textPart = state.activeTextParts[chunk.id];
            if (textPart == null)
              throw new UIMessageStreamError({
                chunkType: "text-end",
                chunkId: chunk.id,
                message: `Received text-end for missing text part with ID "${chunk.id}". Ensure a "text-start" chunk is sent before any "text-end" chunks.`
              });
            textPart.state = "done", textPart.providerMetadata = (_b16 = chunk.providerMetadata) != null ? _b16 : textPart.providerMetadata, delete state.activeTextParts[chunk.id], write();
            break;
          }
          case "reasoning-start": {
            let reasoningPart = {
              type: "reasoning",
              text: "",
              providerMetadata: chunk.providerMetadata,
              state: "streaming"
            };
            state.activeReasoningParts[chunk.id] = reasoningPart, state.message.parts.push(reasoningPart), write();
            break;
          }
          case "reasoning-delta": {
            let reasoningPart = state.activeReasoningParts[chunk.id];
            if (reasoningPart == null)
              throw new UIMessageStreamError({
                chunkType: "reasoning-delta",
                chunkId: chunk.id,
                message: `Received reasoning-delta for missing reasoning part with ID "${chunk.id}". Ensure a "reasoning-start" chunk is sent before any "reasoning-delta" chunks.`
              });
            reasoningPart.text += chunk.delta, reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata, write();
            break;
          }
          case "reasoning-end": {
            let reasoningPart = state.activeReasoningParts[chunk.id];
            if (reasoningPart == null)
              throw new UIMessageStreamError({
                chunkType: "reasoning-end",
                chunkId: chunk.id,
                message: `Received reasoning-end for missing reasoning part with ID "${chunk.id}". Ensure a "reasoning-start" chunk is sent before any "reasoning-end" chunks.`
              });
            reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata, reasoningPart.state = "done", delete state.activeReasoningParts[chunk.id], write();
            break;
          }
          case "file": {
            state.message.parts.push({
              type: "file",
              mediaType: chunk.mediaType,
              url: chunk.url
            }), write();
            break;
          }
          case "source-url": {
            state.message.parts.push({
              type: "source-url",
              sourceId: chunk.sourceId,
              url: chunk.url,
              title: chunk.title,
              providerMetadata: chunk.providerMetadata
            }), write();
            break;
          }
          case "source-document": {
            state.message.parts.push({
              type: "source-document",
              sourceId: chunk.sourceId,
              mediaType: chunk.mediaType,
              title: chunk.title,
              filename: chunk.filename,
              providerMetadata: chunk.providerMetadata
            }), write();
            break;
          }
          case "tool-input-start": {
            let toolInvocations = state.message.parts.filter(isStaticToolUIPart);
            if (state.partialToolCalls[chunk.toolCallId] = {
              text: "",
              toolName: chunk.toolName,
              index: toolInvocations.length,
              dynamic: chunk.dynamic,
              title: chunk.title
            }, chunk.dynamic)
              updateDynamicToolPart({
                toolCallId: chunk.toolCallId,
                toolName: chunk.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: chunk.providerExecuted,
                title: chunk.title,
                providerMetadata: chunk.providerMetadata
              });
            else
              updateToolPart({
                toolCallId: chunk.toolCallId,
                toolName: chunk.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: chunk.providerExecuted,
                title: chunk.title,
                providerMetadata: chunk.providerMetadata
              });
            write();
            break;
          }
          case "tool-input-delta": {
            let partialToolCall = state.partialToolCalls[chunk.toolCallId];
            if (partialToolCall == null)
              throw new UIMessageStreamError({
                chunkType: "tool-input-delta",
                chunkId: chunk.toolCallId,
                message: `Received tool-input-delta for missing tool call with ID "${chunk.toolCallId}". Ensure a "tool-input-start" chunk is sent before any "tool-input-delta" chunks.`
              });
            partialToolCall.text += chunk.inputTextDelta;
            let { value: partialArgs } = await parsePartialJson(partialToolCall.text);
            if (partialToolCall.dynamic)
              updateDynamicToolPart({
                toolCallId: chunk.toolCallId,
                toolName: partialToolCall.toolName,
                state: "input-streaming",
                input: partialArgs,
                title: partialToolCall.title
              });
            else
              updateToolPart({
                toolCallId: chunk.toolCallId,
                toolName: partialToolCall.toolName,
                state: "input-streaming",
                input: partialArgs,
                title: partialToolCall.title
              });
            write();
            break;
          }
          case "tool-input-available": {
            if (chunk.dynamic)
              updateDynamicToolPart({
                toolCallId: chunk.toolCallId,
                toolName: chunk.toolName,
                state: "input-available",
                input: chunk.input,
                providerExecuted: chunk.providerExecuted,
                providerMetadata: chunk.providerMetadata,
                title: chunk.title
              });
            else
              updateToolPart({
                toolCallId: chunk.toolCallId,
                toolName: chunk.toolName,
                state: "input-available",
                input: chunk.input,
                providerExecuted: chunk.providerExecuted,
                providerMetadata: chunk.providerMetadata,
                title: chunk.title
              });
            if (write(), onToolCall && !chunk.providerExecuted)
              await onToolCall({
                toolCall: chunk
              });
            break;
          }
          case "tool-input-error": {
            if (chunk.dynamic)
              updateDynamicToolPart({
                toolCallId: chunk.toolCallId,
                toolName: chunk.toolName,
                state: "output-error",
                input: chunk.input,
                errorText: chunk.errorText,
                providerExecuted: chunk.providerExecuted,
                providerMetadata: chunk.providerMetadata
              });
            else
              updateToolPart({
                toolCallId: chunk.toolCallId,
                toolName: chunk.toolName,
                state: "output-error",
                input: void 0,
                rawInput: chunk.input,
                errorText: chunk.errorText,
                providerExecuted: chunk.providerExecuted,
                providerMetadata: chunk.providerMetadata
              });
            write();
            break;
          }
          case "tool-approval-request": {
            let toolInvocation = getToolInvocation(chunk.toolCallId);
            toolInvocation.state = "approval-requested", toolInvocation.approval = { id: chunk.approvalId }, write();
            break;
          }
          case "tool-output-denied": {
            let toolInvocation = getToolInvocation(chunk.toolCallId);
            toolInvocation.state = "output-denied", write();
            break;
          }
          case "tool-output-available": {
            let toolInvocation = getToolInvocation(chunk.toolCallId);
            if (toolInvocation.type === "dynamic-tool")
              updateDynamicToolPart({
                toolCallId: chunk.toolCallId,
                toolName: toolInvocation.toolName,
                state: "output-available",
                input: toolInvocation.input,
                output: chunk.output,
                preliminary: chunk.preliminary,
                providerExecuted: chunk.providerExecuted,
                title: toolInvocation.title
              });
            else
              updateToolPart({
                toolCallId: chunk.toolCallId,
                toolName: getStaticToolName(toolInvocation),
                state: "output-available",
                input: toolInvocation.input,
                output: chunk.output,
                providerExecuted: chunk.providerExecuted,
                preliminary: chunk.preliminary,
                title: toolInvocation.title
              });
            write();
            break;
          }
          case "tool-output-error": {
            let toolInvocation = getToolInvocation(chunk.toolCallId);
            if (toolInvocation.type === "dynamic-tool")
              updateDynamicToolPart({
                toolCallId: chunk.toolCallId,
                toolName: toolInvocation.toolName,
                state: "output-error",
                input: toolInvocation.input,
                errorText: chunk.errorText,
                providerExecuted: chunk.providerExecuted,
                title: toolInvocation.title
              });
            else
              updateToolPart({
                toolCallId: chunk.toolCallId,
                toolName: getStaticToolName(toolInvocation),
                state: "output-error",
                input: toolInvocation.input,
                rawInput: toolInvocation.rawInput,
                errorText: chunk.errorText,
                providerExecuted: chunk.providerExecuted,
                title: toolInvocation.title
              });
            write();
            break;
          }
          case "start-step": {
            state.message.parts.push({ type: "step-start" });
            break;
          }
          case "finish-step": {
            state.activeTextParts = {}, state.activeReasoningParts = {};
            break;
          }
          case "start": {
            if (chunk.messageId != null)
              state.message.id = chunk.messageId;
            if (await updateMessageMetadata(chunk.messageMetadata), chunk.messageId != null || chunk.messageMetadata != null)
              write();
            break;
          }
          case "finish": {
            if (chunk.finishReason != null)
              state.finishReason = chunk.finishReason;
            if (await updateMessageMetadata(chunk.messageMetadata), chunk.messageMetadata != null)
              write();
            break;
          }
          case "message-metadata": {
            if (await updateMessageMetadata(chunk.messageMetadata), chunk.messageMetadata != null)
              write();
            break;
          }
          case "error": {
            onError == null || onError(Error(chunk.errorText));
            break;
          }
          default:
            if (isDataUIMessageChunk(chunk)) {
              if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {
                let partIdx = state.message.parts.findIndex((p) => ("id" in p) && ("data" in p) && p.id === chunk.id && p.type === chunk.type), actualPartIdx = partIdx >= 0 ? partIdx : state.message.parts.length;
                await validateTypes({
                  value: chunk.data,
                  schema: dataPartSchemas[chunk.type],
                  context: {
                    field: `message.parts[${actualPartIdx}].data`,
                    entityName: chunk.type,
                    entityId: chunk.id
                  }
                });
              }
              let dataChunk = chunk;
              if (dataChunk.transient) {
                onData == null || onData(dataChunk);
                break;
              }
              let existingUIPart = dataChunk.id != null ? state.message.parts.find((chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id) : void 0;
              if (existingUIPart != null)
                existingUIPart.data = dataChunk.data;
              else
                state.message.parts.push(dataChunk);
              onData == null || onData(dataChunk), write();
            }
        }
        controller.enqueue(chunk);
      });
    }
  }));
}
function handleUIMessageStreamFinish({
  messageId,
  originalMessages = [],
  onFinish,
  onError,
  stream
}) {
  let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];
  if ((lastMessage == null ? void 0 : lastMessage.role) !== "assistant")
    lastMessage = void 0;
  else
    messageId = lastMessage.id;
  let isAborted2 = !1, idInjectedStream = stream.pipeThrough(new TransformStream({
    transform(chunk, controller) {
      if (chunk.type === "start") {
        let startChunk = chunk;
        if (startChunk.messageId == null && messageId != null)
          startChunk.messageId = messageId;
      }
      if (chunk.type === "abort")
        isAborted2 = !0;
      controller.enqueue(chunk);
    }
  }));
  if (onFinish == null)
    return idInjectedStream;
  let state = createStreamingUIMessageState({
    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,
    messageId: messageId != null ? messageId : ""
  }), runUpdateMessageJob = async (job) => {
    await job({ state, write: () => {} });
  }, finishCalled = !1, callOnFinish = async () => {
    if (finishCalled || !onFinish)
      return;
    finishCalled = !0;
    let isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);
    await onFinish({
      isAborted: isAborted2,
      isContinuation,
      responseMessage: state.message,
      messages: [
        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,
        state.message
      ],
      finishReason: state.finishReason
    });
  };
  return processUIMessageStream({
    stream: idInjectedStream,
    runUpdateMessageJob,
    onError
  }).pipeThrough(new TransformStream({
    transform(chunk, controller) {
      controller.enqueue(chunk);
    },
    async cancel() {
      await callOnFinish();
    },
    async flush() {
      await callOnFinish();
    }
  }));
}
function pipeUIMessageStreamToResponse({
  response,
  status,
  statusText,
  headers,
  stream,
  consumeSseStream
}) {
  let sseStream = stream.pipeThrough(new JsonToSseTransformStream);
  if (consumeSseStream) {
    let [stream1, stream2] = sseStream.tee();
    sseStream = stream1, consumeSseStream({ stream: stream2 });
  }
  writeToServerResponse({
    response,
    status,
    statusText,
    headers: Object.fromEntries(prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()),
    stream: sseStream.pipeThrough(new TextEncoderStream)
  });
}
function createAsyncIterableStream(source) {
  let stream = source.pipeThrough(new TransformStream);
  return stream[Symbol.asyncIterator] = function() {
    let reader = this.getReader(), finished = !1;
    async function cleanup(cancelStream) {
      var _a21;
      if (finished)
        return;
      finished = !0;
      try {
        if (cancelStream)
          await ((_a21 = reader.cancel) == null ? void 0 : _a21.call(reader));
      } finally {
        try {
          reader.releaseLock();
        } catch (e) {}
      }
    }
    return {
      async next() {
        if (finished)
          return { done: !0, value: void 0 };
        let { done, value } = await reader.read();
        if (done)
          return await cleanup(!0), { done: !0, value: void 0 };
        return { done: !1, value };
      },
      async return() {
        return await cleanup(!0), { done: !0, value: void 0 };
      },
      async throw(err) {
        throw await cleanup(!0), err;
      }
    };
  }, stream;
}
async function consumeStream({
  stream,
  onError
}) {
  let reader = stream.getReader();
  try {
    while (!0) {
      let { done } = await reader.read();
      if (done)
        break;
    }
  } catch (error48) {
    onError == null || onError(error48);
  } finally {
    reader.releaseLock();
  }
}
function createResolvablePromise() {
  let resolve3, reject;
  return {
    promise: new Promise((res, rej) => {
      resolve3 = res, reject = rej;
    }),
    resolve: resolve3,
    reject
  };
}
function createStitchableStream() {
  let innerStreamReaders = [], controller = null, isClosed = !1, waitForNewStream = createResolvablePromise(), terminate = () => {
    isClosed = !0, waitForNewStream.resolve(), innerStreamReaders.forEach((reader) => reader.cancel()), innerStreamReaders = [], controller == null || controller.close();
  }, processPull = async () => {
    if (isClosed && innerStreamReaders.length === 0) {
      controller == null || controller.close();
      return;
    }
    if (innerStreamReaders.length === 0)
      return waitForNewStream = createResolvablePromise(), await waitForNewStream.promise, processPull();
    try {
      let { value, done } = await innerStreamReaders[0].read();
      if (done)
        if (innerStreamReaders.shift(), innerStreamReaders.length === 0 && isClosed)
          controller == null || controller.close();
        else
          await processPull();
      else
        controller == null || controller.enqueue(value);
    } catch (error48) {
      controller == null || controller.error(error48), innerStreamReaders.shift(), terminate();
    }
  };
  return {
    stream: new ReadableStream({
      start(controllerParam) {
        controller = controllerParam;
      },
      pull: processPull,
      async cancel() {
        for (let reader of innerStreamReaders)
          await reader.cancel();
        innerStreamReaders = [], isClosed = !0;
      }
    }),
    addStream: (innerStream) => {
      if (isClosed)
        throw Error("Cannot add inner stream: outer stream is closed");
      innerStreamReaders.push(innerStream.getReader()), waitForNewStream.resolve();
    },
    close: () => {
      if (isClosed = !0, waitForNewStream.resolve(), innerStreamReaders.length === 0)
        controller == null || controller.close();
    },
    terminate
  };
}
function now() {
  var _a21, _b16;
  return (_b16 = (_a21 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a21.now()) != null ? _b16 : Date.now();
}
function runToolsTransformation({
  tools,
  generatorStream,
  tracer,
  telemetry,
  system,
  messages,
  abortSignal,
  repairToolCall,
  experimental_context,
  generateId: generateId2
}) {
  let toolResultsStreamController = null, toolResultsStream = new ReadableStream({
    start(controller) {
      toolResultsStreamController = controller;
    }
  }), outstandingToolResults = /* @__PURE__ */ new Set, toolInputs = /* @__PURE__ */ new Map, toolCallsByToolCallId = /* @__PURE__ */ new Map, canClose = !1, finishChunk = void 0;
  function attemptClose() {
    if (canClose && outstandingToolResults.size === 0) {
      if (finishChunk != null)
        toolResultsStreamController.enqueue(finishChunk);
      toolResultsStreamController.close();
    }
  }
  let forwardStream = new TransformStream({
    async transform(chunk, controller) {
      let chunkType = chunk.type;
      switch (chunkType) {
        case "stream-start":
        case "text-start":
        case "text-delta":
        case "text-end":
        case "reasoning-start":
        case "reasoning-delta":
        case "reasoning-end":
        case "tool-input-start":
        case "tool-input-delta":
        case "tool-input-end":
        case "source":
        case "response-metadata":
        case "error":
        case "raw": {
          controller.enqueue(chunk);
          break;
        }
        case "file": {
          controller.enqueue({
            type: "file",
            file: new DefaultGeneratedFileWithType({
              data: chunk.data,
              mediaType: chunk.mediaType
            })
          });
          break;
        }
        case "finish": {
          finishChunk = {
            type: "finish",
            finishReason: chunk.finishReason.unified,
            rawFinishReason: chunk.finishReason.raw,
            usage: asLanguageModelUsage(chunk.usage),
            providerMetadata: chunk.providerMetadata
          };
          break;
        }
        case "tool-approval-request": {
          let toolCall = toolCallsByToolCallId.get(chunk.toolCallId);
          if (toolCall == null) {
            toolResultsStreamController.enqueue({
              type: "error",
              error: new ToolCallNotFoundForApprovalError({
                toolCallId: chunk.toolCallId,
                approvalId: chunk.approvalId
              })
            });
            break;
          }
          controller.enqueue({
            type: "tool-approval-request",
            approvalId: chunk.approvalId,
            toolCall
          });
          break;
        }
        case "tool-call": {
          try {
            let toolCall = await parseToolCall({
              toolCall: chunk,
              tools,
              repairToolCall,
              system,
              messages
            });
            if (toolCallsByToolCallId.set(toolCall.toolCallId, toolCall), controller.enqueue(toolCall), toolCall.invalid) {
              toolResultsStreamController.enqueue({
                type: "tool-error",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                input: toolCall.input,
                error: getErrorMessage2(toolCall.error),
                dynamic: !0,
                title: toolCall.title
              });
              break;
            }
            let tool2 = tools == null ? void 0 : tools[toolCall.toolName];
            if (tool2 == null)
              break;
            if (tool2.onInputAvailable != null)
              await tool2.onInputAvailable({
                input: toolCall.input,
                toolCallId: toolCall.toolCallId,
                messages,
                abortSignal,
                experimental_context
              });
            if (await isApprovalNeeded({
              tool: tool2,
              toolCall,
              messages,
              experimental_context
            })) {
              toolResultsStreamController.enqueue({
                type: "tool-approval-request",
                approvalId: generateId2(),
                toolCall
              });
              break;
            }
            if (toolInputs.set(toolCall.toolCallId, toolCall.input), tool2.execute != null && toolCall.providerExecuted !== !0) {
              let toolExecutionId = generateId2();
              outstandingToolResults.add(toolExecutionId), executeToolCall({
                toolCall,
                tools,
                tracer,
                telemetry,
                messages,
                abortSignal,
                experimental_context,
                onPreliminaryToolResult: (result) => {
                  toolResultsStreamController.enqueue(result);
                }
              }).then((result) => {
                toolResultsStreamController.enqueue(result);
              }).catch((error48) => {
                toolResultsStreamController.enqueue({
                  type: "error",
                  error: error48
                });
              }).finally(() => {
                outstandingToolResults.delete(toolExecutionId), attemptClose();
              });
            }
          } catch (error48) {
            toolResultsStreamController.enqueue({ type: "error", error: error48 });
          }
          break;
        }
        case "tool-result": {
          let toolName = chunk.toolName;
          if (chunk.isError)
            toolResultsStreamController.enqueue({
              type: "tool-error",
              toolCallId: chunk.toolCallId,
              toolName,
              input: toolInputs.get(chunk.toolCallId),
              providerExecuted: !0,
              error: chunk.result,
              dynamic: chunk.dynamic
            });
          else
            controller.enqueue({
              type: "tool-result",
              toolCallId: chunk.toolCallId,
              toolName,
              input: toolInputs.get(chunk.toolCallId),
              output: chunk.result,
              providerExecuted: !0,
              dynamic: chunk.dynamic
            });
          break;
        }
        default:
          throw Error(`Unhandled chunk type: ${chunkType}`);
      }
    },
    flush() {
      canClose = !0, attemptClose();
    }
  });
  return new ReadableStream({
    async start(controller) {
      return Promise.all([
        generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({
          write(chunk) {
            controller.enqueue(chunk);
          },
          close() {}
        })),
        toolResultsStream.pipeTo(new WritableStream({
          write(chunk) {
            controller.enqueue(chunk);
          },
          close() {
            controller.close();
          }
        }))
      ]);
    }
  });
}
var originalGenerateId2 = createIdGenerator({
  prefix: "aitxt",
  size: 24
});
function streamText({
  model,
  tools,
  toolChoice,
  system,
  prompt,
  messages,
  maxRetries,
  abortSignal,
  timeout,
  headers,
  stopWhen = stepCountIs(1),
  experimental_output,
  output = experimental_output,
  experimental_telemetry: telemetry,
  prepareStep,
  providerOptions,
  experimental_activeTools,
  activeTools = experimental_activeTools,
  experimental_repairToolCall: repairToolCall,
  experimental_transform: transform2,
  experimental_download: download2,
  includeRawChunks = !1,
  onChunk,
  onError = ({ error: error48 }) => {
    console.error(error48);
  },
  onFinish,
  onAbort,
  onStepFinish,
  experimental_context,
  experimental_include: include,
  _internal: { now: now2 = now, generateId: generateId2 = originalGenerateId2 } = {},
  ...settings
}) {
  let totalTimeoutMs = getTotalTimeoutMs(timeout), stepTimeoutMs = getStepTimeoutMs(timeout), chunkTimeoutMs = getChunkTimeoutMs(timeout), stepAbortController = stepTimeoutMs != null ? new AbortController : void 0, chunkAbortController = chunkTimeoutMs != null ? new AbortController : void 0;
  return new DefaultStreamTextResult({
    model: resolveLanguageModel(model),
    telemetry,
    headers,
    settings,
    maxRetries,
    abortSignal: mergeAbortSignals(abortSignal, totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0, stepAbortController == null ? void 0 : stepAbortController.signal, chunkAbortController == null ? void 0 : chunkAbortController.signal),
    stepTimeoutMs,
    stepAbortController,
    chunkTimeoutMs,
    chunkAbortController,
    system,
    prompt,
    messages,
    tools,
    toolChoice,
    transforms: asArray(transform2),
    activeTools,
    repairToolCall,
    stopConditions: asArray(stopWhen),
    output,
    providerOptions,
    prepareStep,
    includeRawChunks,
    onChunk,
    onError,
    onFinish,
    onAbort,
    onStepFinish,
    now: now2,
    generateId: generateId2,
    experimental_context,
    download: download2,
    include
  });
}
function createOutputTransformStream(output) {
  let firstTextChunkId = void 0, text2 = "", textChunk = "", textProviderMetadata = void 0, lastPublishedJson = "";
  function publishTextChunk({
    controller,
    partialOutput = void 0
  }) {
    controller.enqueue({
      part: {
        type: "text-delta",
        id: firstTextChunkId,
        text: textChunk,
        providerMetadata: textProviderMetadata
      },
      partialOutput
    }), textChunk = "";
  }
  return new TransformStream({
    async transform(chunk, controller) {
      var _a21;
      if (chunk.type === "finish-step" && textChunk.length > 0)
        publishTextChunk({ controller });
      if (chunk.type !== "text-delta" && chunk.type !== "text-start" && chunk.type !== "text-end") {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      if (firstTextChunkId == null)
        firstTextChunkId = chunk.id;
      else if (chunk.id !== firstTextChunkId) {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      if (chunk.type === "text-start") {
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      if (chunk.type === "text-end") {
        if (textChunk.length > 0)
          publishTextChunk({ controller });
        controller.enqueue({ part: chunk, partialOutput: void 0 });
        return;
      }
      text2 += chunk.text, textChunk += chunk.text, textProviderMetadata = (_a21 = chunk.providerMetadata) != null ? _a21 : textProviderMetadata;
      let result = await output.parsePartialOutput({ text: text2 });
      if (result !== void 0) {
        let currentJson = JSON.stringify(result.partial);
        if (currentJson !== lastPublishedJson)
          publishTextChunk({ controller, partialOutput: result.partial }), lastPublishedJson = currentJson;
      }
    }
  });
}
var DefaultStreamTextResult = class {
  constructor({
    model,
    telemetry,
    headers,
    settings,
    maxRetries: maxRetriesArg,
    abortSignal,
    stepTimeoutMs,
    stepAbortController,
    chunkTimeoutMs,
    chunkAbortController,
    system,
    prompt,
    messages,
    tools,
    toolChoice,
    transforms,
    activeTools,
    repairToolCall,
    stopConditions,
    output,
    providerOptions,
    prepareStep,
    includeRawChunks,
    now: now2,
    generateId: generateId2,
    onChunk,
    onError,
    onFinish,
    onAbort,
    onStepFinish,
    experimental_context,
    download: download2,
    include
  }) {
    this._totalUsage = new DelayedPromise, this._finishReason = new DelayedPromise, this._rawFinishReason = new DelayedPromise, this._steps = new DelayedPromise, this.outputSpecification = output, this.includeRawChunks = includeRawChunks, this.tools = tools;
    let stepFinish, recordedContent = [], recordedResponseMessages = [], recordedFinishReason = void 0, recordedRawFinishReason = void 0, recordedTotalUsage = void 0, recordedRequest = {}, recordedWarnings = [], recordedSteps = [], pendingDeferredToolCalls = /* @__PURE__ */ new Map, rootSpan, activeTextContent = {}, activeReasoningContent = {}, eventProcessor = new TransformStream({
      async transform(chunk, controller) {
        var _a21, _b16, _c, _d;
        controller.enqueue(chunk);
        let { part } = chunk;
        if (part.type === "text-delta" || part.type === "reasoning-delta" || part.type === "source" || part.type === "tool-call" || part.type === "tool-result" || part.type === "tool-input-start" || part.type === "tool-input-delta" || part.type === "raw")
          await (onChunk == null ? void 0 : onChunk({ chunk: part }));
        if (part.type === "error")
          await onError({ error: wrapGatewayError(part.error) });
        if (part.type === "text-start")
          activeTextContent[part.id] = {
            type: "text",
            text: "",
            providerMetadata: part.providerMetadata
          }, recordedContent.push(activeTextContent[part.id]);
        if (part.type === "text-delta") {
          let activeText = activeTextContent[part.id];
          if (activeText == null) {
            controller.enqueue({
              part: {
                type: "error",
                error: `text part ${part.id} not found`
              },
              partialOutput: void 0
            });
            return;
          }
          activeText.text += part.text, activeText.providerMetadata = (_a21 = part.providerMetadata) != null ? _a21 : activeText.providerMetadata;
        }
        if (part.type === "text-end") {
          let activeText = activeTextContent[part.id];
          if (activeText == null) {
            controller.enqueue({
              part: {
                type: "error",
                error: `text part ${part.id} not found`
              },
              partialOutput: void 0
            });
            return;
          }
          activeText.providerMetadata = (_b16 = part.providerMetadata) != null ? _b16 : activeText.providerMetadata, delete activeTextContent[part.id];
        }
        if (part.type === "reasoning-start")
          activeReasoningContent[part.id] = {
            type: "reasoning",
            text: "",
            providerMetadata: part.providerMetadata
          }, recordedContent.push(activeReasoningContent[part.id]);
        if (part.type === "reasoning-delta") {
          let activeReasoning = activeReasoningContent[part.id];
          if (activeReasoning == null) {
            controller.enqueue({
              part: {
                type: "error",
                error: `reasoning part ${part.id} not found`
              },
              partialOutput: void 0
            });
            return;
          }
          activeReasoning.text += part.text, activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;
        }
        if (part.type === "reasoning-end") {
          let activeReasoning = activeReasoningContent[part.id];
          if (activeReasoning == null) {
            controller.enqueue({
              part: {
                type: "error",
                error: `reasoning part ${part.id} not found`
              },
              partialOutput: void 0
            });
            return;
          }
          activeReasoning.providerMetadata = (_d = part.providerMetadata) != null ? _d : activeReasoning.providerMetadata, delete activeReasoningContent[part.id];
        }
        if (part.type === "file")
          recordedContent.push({ type: "file", file: part.file });
        if (part.type === "source")
          recordedContent.push(part);
        if (part.type === "tool-call")
          recordedContent.push(part);
        if (part.type === "tool-result" && !part.preliminary)
          recordedContent.push(part);
        if (part.type === "tool-approval-request")
          recordedContent.push(part);
        if (part.type === "tool-error")
          recordedContent.push(part);
        if (part.type === "start-step")
          recordedContent = [], activeReasoningContent = {}, activeTextContent = {}, recordedRequest = part.request, recordedWarnings = part.warnings;
        if (part.type === "finish-step") {
          let stepMessages = await toResponseMessages({
            content: recordedContent,
            tools
          }), currentStepResult = new DefaultStepResult({
            content: recordedContent,
            finishReason: part.finishReason,
            rawFinishReason: part.rawFinishReason,
            usage: part.usage,
            warnings: recordedWarnings,
            request: recordedRequest,
            response: {
              ...part.response,
              messages: [...recordedResponseMessages, ...stepMessages]
            },
            providerMetadata: part.providerMetadata
          });
          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult)), logWarnings({
            warnings: recordedWarnings,
            provider: model.provider,
            model: model.modelId
          }), recordedSteps.push(currentStepResult), recordedResponseMessages.push(...stepMessages), stepFinish.resolve();
        }
        if (part.type === "finish")
          recordedTotalUsage = part.totalUsage, recordedFinishReason = part.finishReason, recordedRawFinishReason = part.rawFinishReason;
      },
      async flush(controller) {
        try {
          if (recordedSteps.length === 0) {
            let error48 = (abortSignal == null ? void 0 : abortSignal.aborted) ? abortSignal.reason : new NoOutputGeneratedError({
              message: "No output generated. Check the stream for errors."
            });
            self2._finishReason.reject(error48), self2._rawFinishReason.reject(error48), self2._totalUsage.reject(error48), self2._steps.reject(error48);
            return;
          }
          let finishReason = recordedFinishReason != null ? recordedFinishReason : "other", totalUsage = recordedTotalUsage != null ? recordedTotalUsage : createNullLanguageModelUsage();
          self2._finishReason.resolve(finishReason), self2._rawFinishReason.resolve(recordedRawFinishReason), self2._totalUsage.resolve(totalUsage), self2._steps.resolve(recordedSteps);
          let finalStep = recordedSteps[recordedSteps.length - 1];
          await (onFinish == null ? void 0 : onFinish({
            finishReason: finalStep.finishReason,
            rawFinishReason: finalStep.rawFinishReason,
            totalUsage,
            usage: finalStep.usage,
            content: finalStep.content,
            text: finalStep.text,
            reasoningText: finalStep.reasoningText,
            reasoning: finalStep.reasoning,
            files: finalStep.files,
            sources: finalStep.sources,
            toolCalls: finalStep.toolCalls,
            staticToolCalls: finalStep.staticToolCalls,
            dynamicToolCalls: finalStep.dynamicToolCalls,
            toolResults: finalStep.toolResults,
            staticToolResults: finalStep.staticToolResults,
            dynamicToolResults: finalStep.dynamicToolResults,
            request: finalStep.request,
            response: finalStep.response,
            warnings: finalStep.warnings,
            providerMetadata: finalStep.providerMetadata,
            steps: recordedSteps,
            experimental_context
          })), rootSpan.setAttributes(await selectTelemetryAttributes({
            telemetry,
            attributes: {
              "ai.response.finishReason": finishReason,
              "ai.response.text": { output: () => finalStep.text },
              "ai.response.toolCalls": {
                output: () => {
                  var _a21;
                  return ((_a21 = finalStep.toolCalls) == null ? void 0 : _a21.length) ? JSON.stringify(finalStep.toolCalls) : void 0;
                }
              },
              "ai.response.providerMetadata": JSON.stringify(finalStep.providerMetadata),
              "ai.usage.inputTokens": totalUsage.inputTokens,
              "ai.usage.outputTokens": totalUsage.outputTokens,
              "ai.usage.totalTokens": totalUsage.totalTokens,
              "ai.usage.reasoningTokens": totalUsage.reasoningTokens,
              "ai.usage.cachedInputTokens": totalUsage.cachedInputTokens
            }
          }));
        } catch (error48) {
          controller.error(error48);
        } finally {
          rootSpan.end();
        }
      }
    }), stitchableStream = createStitchableStream();
    this.addStream = stitchableStream.addStream, this.closeStream = stitchableStream.close;
    let reader = stitchableStream.stream.getReader(), stream = new ReadableStream({
      async start(controller) {
        controller.enqueue({ type: "start" });
      },
      async pull(controller) {
        function abort() {
          onAbort == null || onAbort({ steps: recordedSteps }), controller.enqueue({
            type: "abort",
            ...(abortSignal == null ? void 0 : abortSignal.reason) !== void 0 ? { reason: getErrorMessage(abortSignal.reason) } : {}
          }), controller.close();
        }
        try {
          let { done, value } = await reader.read();
          if (done) {
            controller.close();
            return;
          }
          if (abortSignal == null ? void 0 : abortSignal.aborted) {
            abort();
            return;
          }
          controller.enqueue(value);
        } catch (error48) {
          if (isAbortError(error48) && (abortSignal == null ? void 0 : abortSignal.aborted))
            abort();
          else
            controller.error(error48);
        }
      },
      cancel(reason) {
        return stitchableStream.stream.cancel(reason);
      }
    });
    for (let transform2 of transforms)
      stream = stream.pipeThrough(transform2({
        tools,
        stopStream() {
          stitchableStream.terminate();
        }
      }));
    this.baseStream = stream.pipeThrough(createOutputTransformStream(output != null ? output : text())).pipeThrough(eventProcessor);
    let { maxRetries, retry } = prepareRetries({
      maxRetries: maxRetriesArg,
      abortSignal
    }), tracer = getTracer(telemetry), callSettings = prepareCallSettings(settings), baseTelemetryAttributes = getBaseTelemetryAttributes({
      model,
      telemetry,
      headers,
      settings: { ...callSettings, maxRetries }
    }), self2 = this;
    recordSpan({
      name: "ai.streamText",
      attributes: selectTelemetryAttributes({
        telemetry,
        attributes: {
          ...assembleOperationName({ operationId: "ai.streamText", telemetry }),
          ...baseTelemetryAttributes,
          "ai.prompt": {
            input: () => JSON.stringify({ system, prompt, messages })
          }
        }
      }),
      tracer,
      endWhenDone: !1,
      fn: async (rootSpanArg) => {
        rootSpan = rootSpanArg;
        let initialPrompt = await standardizePrompt({
          system,
          prompt,
          messages
        }), initialMessages = initialPrompt.messages, initialResponseMessages = [], { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({ messages: initialMessages });
        if (deniedToolApprovals.length > 0 || approvedToolApprovals.length > 0) {
          let providerExecutedToolApprovals = [
            ...approvedToolApprovals,
            ...deniedToolApprovals
          ].filter((toolApproval) => toolApproval.toolCall.providerExecuted), localApprovedToolApprovals = approvedToolApprovals.filter((toolApproval) => !toolApproval.toolCall.providerExecuted), localDeniedToolApprovals = deniedToolApprovals.filter((toolApproval) => !toolApproval.toolCall.providerExecuted), deniedProviderExecutedToolApprovals = deniedToolApprovals.filter((toolApproval) => toolApproval.toolCall.providerExecuted), toolExecutionStepStreamController, toolExecutionStepStream = new ReadableStream({
            start(controller) {
              toolExecutionStepStreamController = controller;
            }
          });
          self2.addStream(toolExecutionStepStream);
          try {
            for (let toolApproval of [
              ...localDeniedToolApprovals,
              ...deniedProviderExecutedToolApprovals
            ])
              toolExecutionStepStreamController == null || toolExecutionStepStreamController.enqueue({
                type: "tool-output-denied",
                toolCallId: toolApproval.toolCall.toolCallId,
                toolName: toolApproval.toolCall.toolName
              });
            let toolOutputs = [];
            if (await Promise.all(localApprovedToolApprovals.map(async (toolApproval) => {
              let result = await executeToolCall({
                toolCall: toolApproval.toolCall,
                tools,
                tracer,
                telemetry,
                messages: initialMessages,
                abortSignal,
                experimental_context,
                onPreliminaryToolResult: (result2) => {
                  toolExecutionStepStreamController == null || toolExecutionStepStreamController.enqueue(result2);
                }
              });
              if (result != null)
                toolExecutionStepStreamController == null || toolExecutionStepStreamController.enqueue(result), toolOutputs.push(result);
            })), providerExecutedToolApprovals.length > 0)
              initialResponseMessages.push({
                role: "tool",
                content: providerExecutedToolApprovals.map((toolApproval) => ({
                  type: "tool-approval-response",
                  approvalId: toolApproval.approvalResponse.approvalId,
                  approved: toolApproval.approvalResponse.approved,
                  reason: toolApproval.approvalResponse.reason,
                  providerExecuted: !0
                }))
              });
            if (toolOutputs.length > 0 || localDeniedToolApprovals.length > 0) {
              let localToolContent = [];
              for (let output2 of toolOutputs)
                localToolContent.push({
                  type: "tool-result",
                  toolCallId: output2.toolCallId,
                  toolName: output2.toolName,
                  output: await createToolModelOutput({
                    toolCallId: output2.toolCallId,
                    input: output2.input,
                    tool: tools == null ? void 0 : tools[output2.toolName],
                    output: output2.type === "tool-result" ? output2.output : output2.error,
                    errorMode: output2.type === "tool-error" ? "json" : "none"
                  })
                });
              for (let toolApproval of localDeniedToolApprovals)
                localToolContent.push({
                  type: "tool-result",
                  toolCallId: toolApproval.toolCall.toolCallId,
                  toolName: toolApproval.toolCall.toolName,
                  output: {
                    type: "execution-denied",
                    reason: toolApproval.approvalResponse.reason
                  }
                });
              initialResponseMessages.push({
                role: "tool",
                content: localToolContent
              });
            }
          } finally {
            toolExecutionStepStreamController == null || toolExecutionStepStreamController.close();
          }
        }
        recordedResponseMessages.push(...initialResponseMessages);
        async function streamStep({
          currentStep,
          responseMessages,
          usage
        }) {
          var _a21, _b16, _c, _d, _e, _f, _g;
          let includeRawChunks2 = self2.includeRawChunks, stepTimeoutId = stepTimeoutMs != null ? setTimeout(() => stepAbortController.abort(), stepTimeoutMs) : void 0, chunkTimeoutId = void 0;
          function resetChunkTimeout() {
            if (chunkTimeoutMs != null) {
              if (chunkTimeoutId != null)
                clearTimeout(chunkTimeoutId);
              chunkTimeoutId = setTimeout(() => chunkAbortController.abort(), chunkTimeoutMs);
            }
          }
          function clearChunkTimeout() {
            if (chunkTimeoutId != null)
              clearTimeout(chunkTimeoutId), chunkTimeoutId = void 0;
          }
          function clearStepTimeout() {
            if (stepTimeoutId != null)
              clearTimeout(stepTimeoutId);
          }
          try {
            stepFinish = new DelayedPromise;
            let stepInputMessages = [...initialMessages, ...responseMessages], prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
              model,
              steps: recordedSteps,
              stepNumber: recordedSteps.length,
              messages: stepInputMessages,
              experimental_context
            })), stepModel = resolveLanguageModel((_a21 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a21 : model), promptMessages = await convertToLanguageModelPrompt({
              prompt: {
                system: (_b16 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b16 : initialPrompt.system,
                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages
              },
              supportedUrls: await stepModel.supportedUrls,
              download: download2
            }), { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({
              tools,
              toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,
              activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools
            });
            experimental_context = (_f = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _f : experimental_context;
            let stepProviderOptions = mergeObjects(providerOptions, prepareStepResult == null ? void 0 : prepareStepResult.providerOptions), {
              result: { stream: stream2, response, request },
              doStreamSpan,
              startTimestampMs
            } = await retry(() => recordSpan({
              name: "ai.streamText.doStream",
              attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                  ...assembleOperationName({
                    operationId: "ai.streamText.doStream",
                    telemetry
                  }),
                  ...baseTelemetryAttributes,
                  "ai.model.provider": stepModel.provider,
                  "ai.model.id": stepModel.modelId,
                  "ai.prompt.messages": {
                    input: () => stringifyForTelemetry(promptMessages)
                  },
                  "ai.prompt.tools": {
                    input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))
                  },
                  "ai.prompt.toolChoice": {
                    input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                  },
                  "gen_ai.system": stepModel.provider,
                  "gen_ai.request.model": stepModel.modelId,
                  "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                  "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                  "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                  "gen_ai.request.stop_sequences": callSettings.stopSequences,
                  "gen_ai.request.temperature": callSettings.temperature,
                  "gen_ai.request.top_k": callSettings.topK,
                  "gen_ai.request.top_p": callSettings.topP
                }
              }),
              tracer,
              endWhenDone: !1,
              fn: async (doStreamSpan2) => ({
                startTimestampMs: now2(),
                doStreamSpan: doStreamSpan2,
                result: await stepModel.doStream({
                  ...callSettings,
                  tools: stepTools,
                  toolChoice: stepToolChoice,
                  responseFormat: await (output == null ? void 0 : output.responseFormat),
                  prompt: promptMessages,
                  providerOptions: stepProviderOptions,
                  abortSignal,
                  headers,
                  includeRawChunks: includeRawChunks2
                })
              })
            })), streamWithToolResults = runToolsTransformation({
              tools,
              generatorStream: stream2,
              tracer,
              telemetry,
              system,
              messages: stepInputMessages,
              repairToolCall,
              abortSignal,
              experimental_context,
              generateId: generateId2
            }), stepRequest = ((_g = include == null ? void 0 : include.requestBody) != null ? _g : !0) ? request != null ? request : {} : { ...request, body: void 0 }, stepToolCalls = [], stepToolOutputs = [], warnings, activeToolCallToolNames = {}, stepFinishReason = "other", stepRawFinishReason = void 0, stepUsage = createNullLanguageModelUsage(), stepProviderMetadata, stepFirstChunk = !0, stepResponse = {
              id: generateId2(),
              timestamp: /* @__PURE__ */ new Date,
              modelId: model.modelId
            }, activeText = "";
            self2.addStream(streamWithToolResults.pipeThrough(new TransformStream({
              async transform(chunk, controller) {
                var _a222, _b23, _c2, _d2, _e2;
                if (resetChunkTimeout(), chunk.type === "stream-start") {
                  warnings = chunk.warnings;
                  return;
                }
                if (stepFirstChunk) {
                  let msToFirstChunk = now2() - startTimestampMs;
                  stepFirstChunk = !1, doStreamSpan.addEvent("ai.stream.firstChunk", {
                    "ai.response.msToFirstChunk": msToFirstChunk
                  }), doStreamSpan.setAttributes({
                    "ai.response.msToFirstChunk": msToFirstChunk
                  }), controller.enqueue({
                    type: "start-step",
                    request: stepRequest,
                    warnings: warnings != null ? warnings : []
                  });
                }
                let chunkType = chunk.type;
                switch (chunkType) {
                  case "tool-approval-request":
                  case "text-start":
                  case "text-end": {
                    controller.enqueue(chunk);
                    break;
                  }
                  case "text-delta": {
                    if (chunk.delta.length > 0)
                      controller.enqueue({
                        type: "text-delta",
                        id: chunk.id,
                        text: chunk.delta,
                        providerMetadata: chunk.providerMetadata
                      }), activeText += chunk.delta;
                    break;
                  }
                  case "reasoning-start":
                  case "reasoning-end": {
                    controller.enqueue(chunk);
                    break;
                  }
                  case "reasoning-delta": {
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: chunk.id,
                      text: chunk.delta,
                      providerMetadata: chunk.providerMetadata
                    });
                    break;
                  }
                  case "tool-call": {
                    controller.enqueue(chunk), stepToolCalls.push(chunk);
                    break;
                  }
                  case "tool-result": {
                    if (controller.enqueue(chunk), !chunk.preliminary)
                      stepToolOutputs.push(chunk);
                    break;
                  }
                  case "tool-error": {
                    controller.enqueue(chunk), stepToolOutputs.push(chunk);
                    break;
                  }
                  case "response-metadata": {
                    stepResponse = {
                      id: (_a222 = chunk.id) != null ? _a222 : stepResponse.id,
                      timestamp: (_b23 = chunk.timestamp) != null ? _b23 : stepResponse.timestamp,
                      modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId
                    };
                    break;
                  }
                  case "finish": {
                    stepUsage = chunk.usage, stepFinishReason = chunk.finishReason, stepRawFinishReason = chunk.rawFinishReason, stepProviderMetadata = chunk.providerMetadata;
                    let msToFinish = now2() - startTimestampMs;
                    doStreamSpan.addEvent("ai.stream.finish"), doStreamSpan.setAttributes({
                      "ai.response.msToFinish": msToFinish,
                      "ai.response.avgOutputTokensPerSecond": 1000 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish
                    });
                    break;
                  }
                  case "file": {
                    controller.enqueue(chunk);
                    break;
                  }
                  case "source": {
                    controller.enqueue(chunk);
                    break;
                  }
                  case "tool-input-start": {
                    activeToolCallToolNames[chunk.id] = chunk.toolName;
                    let tool2 = tools == null ? void 0 : tools[chunk.toolName];
                    if ((tool2 == null ? void 0 : tool2.onInputStart) != null)
                      await tool2.onInputStart({
                        toolCallId: chunk.id,
                        messages: stepInputMessages,
                        abortSignal,
                        experimental_context
                      });
                    controller.enqueue({
                      ...chunk,
                      dynamic: (_e2 = chunk.dynamic) != null ? _e2 : (tool2 == null ? void 0 : tool2.type) === "dynamic",
                      title: tool2 == null ? void 0 : tool2.title
                    });
                    break;
                  }
                  case "tool-input-end": {
                    delete activeToolCallToolNames[chunk.id], controller.enqueue(chunk);
                    break;
                  }
                  case "tool-input-delta": {
                    let toolName = activeToolCallToolNames[chunk.id], tool2 = tools == null ? void 0 : tools[toolName];
                    if ((tool2 == null ? void 0 : tool2.onInputDelta) != null)
                      await tool2.onInputDelta({
                        inputTextDelta: chunk.delta,
                        toolCallId: chunk.id,
                        messages: stepInputMessages,
                        abortSignal,
                        experimental_context
                      });
                    controller.enqueue(chunk);
                    break;
                  }
                  case "error": {
                    controller.enqueue(chunk), stepFinishReason = "error";
                    break;
                  }
                  case "raw": {
                    if (includeRawChunks2)
                      controller.enqueue(chunk);
                    break;
                  }
                  default:
                    throw Error(`Unknown chunk type: ${chunkType}`);
                }
              },
              async flush(controller) {
                let stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;
                try {
                  doStreamSpan.setAttributes(await selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                      "ai.response.finishReason": stepFinishReason,
                      "ai.response.text": {
                        output: () => activeText
                      },
                      "ai.response.toolCalls": {
                        output: () => stepToolCallsJson
                      },
                      "ai.response.id": stepResponse.id,
                      "ai.response.model": stepResponse.modelId,
                      "ai.response.timestamp": stepResponse.timestamp.toISOString(),
                      "ai.response.providerMetadata": JSON.stringify(stepProviderMetadata),
                      "ai.usage.inputTokens": stepUsage.inputTokens,
                      "ai.usage.outputTokens": stepUsage.outputTokens,
                      "ai.usage.totalTokens": stepUsage.totalTokens,
                      "ai.usage.reasoningTokens": stepUsage.reasoningTokens,
                      "ai.usage.cachedInputTokens": stepUsage.cachedInputTokens,
                      "gen_ai.response.finish_reasons": [
                        stepFinishReason
                      ],
                      "gen_ai.response.id": stepResponse.id,
                      "gen_ai.response.model": stepResponse.modelId,
                      "gen_ai.usage.input_tokens": stepUsage.inputTokens,
                      "gen_ai.usage.output_tokens": stepUsage.outputTokens
                    }
                  }));
                } catch (error48) {} finally {
                  doStreamSpan.end();
                }
                controller.enqueue({
                  type: "finish-step",
                  finishReason: stepFinishReason,
                  rawFinishReason: stepRawFinishReason,
                  usage: stepUsage,
                  providerMetadata: stepProviderMetadata,
                  response: {
                    ...stepResponse,
                    headers: response == null ? void 0 : response.headers
                  }
                });
                let combinedUsage = addLanguageModelUsage(usage, stepUsage);
                await stepFinish.promise;
                let clientToolCalls = stepToolCalls.filter((toolCall) => toolCall.providerExecuted !== !0), clientToolOutputs = stepToolOutputs.filter((toolOutput) => toolOutput.providerExecuted !== !0);
                for (let toolCall of stepToolCalls) {
                  if (toolCall.providerExecuted !== !0)
                    continue;
                  let tool2 = tools == null ? void 0 : tools[toolCall.toolName];
                  if ((tool2 == null ? void 0 : tool2.type) === "provider" && tool2.supportsDeferredResults) {
                    if (!stepToolOutputs.some((output2) => (output2.type === "tool-result" || output2.type === "tool-error") && output2.toolCallId === toolCall.toolCallId))
                      pendingDeferredToolCalls.set(toolCall.toolCallId, {
                        toolName: toolCall.toolName
                      });
                  }
                }
                for (let output2 of stepToolOutputs)
                  if (output2.type === "tool-result" || output2.type === "tool-error")
                    pendingDeferredToolCalls.delete(output2.toolCallId);
                if (clearStepTimeout(), clearChunkTimeout(), (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && !await isStopConditionMet({
                  stopConditions,
                  steps: recordedSteps
                })) {
                  responseMessages.push(...await toResponseMessages({
                    content: recordedSteps[recordedSteps.length - 1].content,
                    tools
                  }));
                  try {
                    await streamStep({
                      currentStep: currentStep + 1,
                      responseMessages,
                      usage: combinedUsage
                    });
                  } catch (error48) {
                    controller.enqueue({
                      type: "error",
                      error: error48
                    }), self2.closeStream();
                  }
                } else
                  controller.enqueue({
                    type: "finish",
                    finishReason: stepFinishReason,
                    rawFinishReason: stepRawFinishReason,
                    totalUsage: combinedUsage
                  }), self2.closeStream();
              }
            })));
          } finally {
            clearStepTimeout(), clearChunkTimeout();
          }
        }
        await streamStep({
          currentStep: 0,
          responseMessages: initialResponseMessages,
          usage: createNullLanguageModelUsage()
        });
      }
    }).catch((error48) => {
      self2.addStream(new ReadableStream({
        start(controller) {
          controller.enqueue({ type: "error", error: error48 }), controller.close();
        }
      })), self2.closeStream();
    });
  }
  get steps() {
    return this.consumeStream(), this._steps.promise;
  }
  get finalStep() {
    return this.steps.then((steps) => steps[steps.length - 1]);
  }
  get content() {
    return this.finalStep.then((step) => step.content);
  }
  get warnings() {
    return this.finalStep.then((step) => step.warnings);
  }
  get providerMetadata() {
    return this.finalStep.then((step) => step.providerMetadata);
  }
  get text() {
    return this.finalStep.then((step) => step.text);
  }
  get reasoningText() {
    return this.finalStep.then((step) => step.reasoningText);
  }
  get reasoning() {
    return this.finalStep.then((step) => step.reasoning);
  }
  get sources() {
    return this.finalStep.then((step) => step.sources);
  }
  get files() {
    return this.finalStep.then((step) => step.files);
  }
  get toolCalls() {
    return this.finalStep.then((step) => step.toolCalls);
  }
  get staticToolCalls() {
    return this.finalStep.then((step) => step.staticToolCalls);
  }
  get dynamicToolCalls() {
    return this.finalStep.then((step) => step.dynamicToolCalls);
  }
  get toolResults() {
    return this.finalStep.then((step) => step.toolResults);
  }
  get staticToolResults() {
    return this.finalStep.then((step) => step.staticToolResults);
  }
  get dynamicToolResults() {
    return this.finalStep.then((step) => step.dynamicToolResults);
  }
  get usage() {
    return this.finalStep.then((step) => step.usage);
  }
  get request() {
    return this.finalStep.then((step) => step.request);
  }
  get response() {
    return this.finalStep.then((step) => step.response);
  }
  get totalUsage() {
    return this.consumeStream(), this._totalUsage.promise;
  }
  get finishReason() {
    return this.consumeStream(), this._finishReason.promise;
  }
  get rawFinishReason() {
    return this.consumeStream(), this._rawFinishReason.promise;
  }
  teeStream() {
    let [stream1, stream2] = this.baseStream.tee();
    return this.baseStream = stream2, stream1;
  }
  get textStream() {
    return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({
      transform({ part }, controller) {
        if (part.type === "text-delta")
          controller.enqueue(part.text);
      }
    })));
  }
  get fullStream() {
    return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({
      transform({ part }, controller) {
        controller.enqueue(part);
      }
    })));
  }
  async consumeStream(options) {
    var _a21;
    try {
      await consumeStream({
        stream: this.fullStream,
        onError: options == null ? void 0 : options.onError
      });
    } catch (error48) {
      (_a21 = options == null ? void 0 : options.onError) == null || _a21.call(options, error48);
    }
  }
  get experimental_partialOutputStream() {
    return this.partialOutputStream;
  }
  get partialOutputStream() {
    return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({
      transform({ partialOutput }, controller) {
        if (partialOutput != null)
          controller.enqueue(partialOutput);
      }
    })));
  }
  get elementStream() {
    var _a21, _b16, _c;
    let transform2 = (_a21 = this.outputSpecification) == null ? void 0 : _a21.createElementStreamTransform();
    if (transform2 == null)
      throw new UnsupportedFunctionalityError({
        functionality: `element streams in ${(_c = (_b16 = this.outputSpecification) == null ? void 0 : _b16.name) != null ? _c : "text"} mode`
      });
    return createAsyncIterableStream(this.teeStream().pipeThrough(transform2));
  }
  get output() {
    return this.finalStep.then((step) => {
      var _a21;
      return ((_a21 = this.outputSpecification) != null ? _a21 : text()).parseCompleteOutput({ text: step.text }, {
        response: step.response,
        usage: step.usage,
        finishReason: step.finishReason
      });
    });
  }
  toUIMessageStream({
    originalMessages,
    generateMessageId,
    onFinish,
    messageMetadata,
    sendReasoning = !0,
    sendSources = !1,
    sendStart = !0,
    sendFinish = !0,
    onError = getErrorMessage
  } = {}) {
    let responseMessageId = generateMessageId != null ? getResponseUIMessageId({
      originalMessages,
      responseMessageId: generateMessageId
    }) : void 0, isDynamic = (part) => {
      var _a21;
      let tool2 = (_a21 = this.tools) == null ? void 0 : _a21[part.toolName];
      if (tool2 == null)
        return part.dynamic;
      return (tool2 == null ? void 0 : tool2.type) === "dynamic" ? !0 : void 0;
    }, baseStream = this.fullStream.pipeThrough(new TransformStream({
      transform: async (part, controller) => {
        let messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({ part }), partType = part.type;
        switch (partType) {
          case "text-start": {
            controller.enqueue({
              type: "text-start",
              id: part.id,
              ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
            });
            break;
          }
          case "text-delta": {
            controller.enqueue({
              type: "text-delta",
              id: part.id,
              delta: part.text,
              ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
            });
            break;
          }
          case "text-end": {
            controller.enqueue({
              type: "text-end",
              id: part.id,
              ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
            });
            break;
          }
          case "reasoning-start": {
            controller.enqueue({
              type: "reasoning-start",
              id: part.id,
              ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
            });
            break;
          }
          case "reasoning-delta": {
            if (sendReasoning)
              controller.enqueue({
                type: "reasoning-delta",
                id: part.id,
                delta: part.text,
                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
              });
            break;
          }
          case "reasoning-end": {
            controller.enqueue({
              type: "reasoning-end",
              id: part.id,
              ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
            });
            break;
          }
          case "file": {
            controller.enqueue({
              type: "file",
              mediaType: part.file.mediaType,
              url: `data:${part.file.mediaType};base64,${part.file.base64}`
            });
            break;
          }
          case "source": {
            if (sendSources && part.sourceType === "url")
              controller.enqueue({
                type: "source-url",
                sourceId: part.id,
                url: part.url,
                title: part.title,
                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
              });
            if (sendSources && part.sourceType === "document")
              controller.enqueue({
                type: "source-document",
                sourceId: part.id,
                mediaType: part.mediaType,
                title: part.title,
                filename: part.filename,
                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}
              });
            break;
          }
          case "tool-input-start": {
            let dynamic = isDynamic(part);
            controller.enqueue({
              type: "tool-input-start",
              toolCallId: part.id,
              toolName: part.toolName,
              ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
              ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
              ...dynamic != null ? { dynamic } : {},
              ...part.title != null ? { title: part.title } : {}
            });
            break;
          }
          case "tool-input-delta": {
            controller.enqueue({
              type: "tool-input-delta",
              toolCallId: part.id,
              inputTextDelta: part.delta
            });
            break;
          }
          case "tool-call": {
            let dynamic = isDynamic(part);
            if (part.invalid)
              controller.enqueue({
                type: "tool-input-error",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                input: part.input,
                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
                ...dynamic != null ? { dynamic } : {},
                errorText: onError(part.error),
                ...part.title != null ? { title: part.title } : {}
              });
            else
              controller.enqueue({
                type: "tool-input-available",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                input: part.input,
                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},
                ...dynamic != null ? { dynamic } : {},
                ...part.title != null ? { title: part.title } : {}
              });
            break;
          }
          case "tool-approval-request": {
            controller.enqueue({
              type: "tool-approval-request",
              approvalId: part.approvalId,
              toolCallId: part.toolCall.toolCallId
            });
            break;
          }
          case "tool-result": {
            let dynamic = isDynamic(part);
            controller.enqueue({
              type: "tool-output-available",
              toolCallId: part.toolCallId,
              output: part.output,
              ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
              ...part.preliminary != null ? { preliminary: part.preliminary } : {},
              ...dynamic != null ? { dynamic } : {}
            });
            break;
          }
          case "tool-error": {
            let dynamic = isDynamic(part);
            controller.enqueue({
              type: "tool-output-error",
              toolCallId: part.toolCallId,
              errorText: onError(part.error),
              ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},
              ...dynamic != null ? { dynamic } : {}
            });
            break;
          }
          case "tool-output-denied": {
            controller.enqueue({
              type: "tool-output-denied",
              toolCallId: part.toolCallId
            });
            break;
          }
          case "error": {
            controller.enqueue({
              type: "error",
              errorText: onError(part.error)
            });
            break;
          }
          case "start-step": {
            controller.enqueue({ type: "start-step" });
            break;
          }
          case "finish-step": {
            controller.enqueue({ type: "finish-step" });
            break;
          }
          case "start": {
            if (sendStart)
              controller.enqueue({
                type: "start",
                ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {},
                ...responseMessageId != null ? { messageId: responseMessageId } : {}
              });
            break;
          }
          case "finish": {
            if (sendFinish)
              controller.enqueue({
                type: "finish",
                finishReason: part.finishReason,
                ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}
              });
            break;
          }
          case "abort": {
            controller.enqueue(part);
            break;
          }
          case "tool-input-end":
            break;
          case "raw":
            break;
          default:
            throw Error(`Unknown chunk type: ${partType}`);
        }
        if (messageMetadataValue != null && partType !== "start" && partType !== "finish")
          controller.enqueue({
            type: "message-metadata",
            messageMetadata: messageMetadataValue
          });
      }
    }));
    return createAsyncIterableStream(handleUIMessageStreamFinish({
      stream: baseStream,
      messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),
      originalMessages,
      onFinish,
      onError
    }));
  }
  pipeUIMessageStreamToResponse(response, {
    originalMessages,
    generateMessageId,
    onFinish,
    messageMetadata,
    sendReasoning,
    sendSources,
    sendFinish,
    sendStart,
    onError,
    ...init
  } = {}) {
    pipeUIMessageStreamToResponse({
      response,
      stream: this.toUIMessageStream({
        originalMessages,
        generateMessageId,
        onFinish,
        messageMetadata,
        sendReasoning,
        sendSources,
        sendFinish,
        sendStart,
        onError
      }),
      ...init
    });
  }
  pipeTextStreamToResponse(response, init) {
    pipeTextStreamToResponse({
      response,
      textStream: this.textStream,
      ...init
    });
  }
  toUIMessageStreamResponse({
    originalMessages,
    generateMessageId,
    onFinish,
    messageMetadata,
    sendReasoning,
    sendSources,
    sendFinish,
    sendStart,
    onError,
    ...init
  } = {}) {
    return createUIMessageStreamResponse({
      stream: this.toUIMessageStream({
        originalMessages,
        generateMessageId,
        onFinish,
        messageMetadata,
        sendReasoning,
        sendSources,
        sendFinish,
        sendStart,
        onError
      }),
      ...init
    });
  }
  toTextStreamResponse(init) {
    return createTextStreamResponse({
      textStream: this.textStream,
      ...init
    });
  }
};
var uiMessagesSchema = lazySchema(() => zodSchema(exports_external.array(exports_external.object({
  id: exports_external.string(),
  role: exports_external.enum(["system", "user", "assistant"]),
  metadata: exports_external.unknown().optional(),
  parts: exports_external.array(exports_external.union([
    exports_external.object({
      type: exports_external.literal("text"),
      text: exports_external.string(),
      state: exports_external.enum(["streaming", "done"]).optional(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    exports_external.object({
      type: exports_external.literal("reasoning"),
      text: exports_external.string(),
      state: exports_external.enum(["streaming", "done"]).optional(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    exports_external.object({
      type: exports_external.literal("source-url"),
      sourceId: exports_external.string(),
      url: exports_external.string(),
      title: exports_external.string().optional(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    exports_external.object({
      type: exports_external.literal("source-document"),
      sourceId: exports_external.string(),
      mediaType: exports_external.string(),
      title: exports_external.string(),
      filename: exports_external.string().optional(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    exports_external.object({
      type: exports_external.literal("file"),
      mediaType: exports_external.string(),
      filename: exports_external.string().optional(),
      url: exports_external.string(),
      providerMetadata: providerMetadataSchema.optional()
    }),
    exports_external.object({
      type: exports_external.literal("step-start")
    }),
    exports_external.object({
      type: exports_external.string().startsWith("data-"),
      id: exports_external.string().optional(),
      data: exports_external.unknown()
    }),
    exports_external.object({
      type: exports_external.literal("dynamic-tool"),
      toolName: exports_external.string(),
      toolCallId: exports_external.string(),
      state: exports_external.literal("input-streaming"),
      input: exports_external.unknown().optional(),
      providerExecuted: exports_external.boolean().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      approval: exports_external.never().optional()
    }),
    exports_external.object({
      type: exports_external.literal("dynamic-tool"),
      toolName: exports_external.string(),
      toolCallId: exports_external.string(),
      state: exports_external.literal("input-available"),
      input: exports_external.unknown(),
      providerExecuted: exports_external.boolean().optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.never().optional()
    }),
    exports_external.object({
      type: exports_external.literal("dynamic-tool"),
      toolName: exports_external.string(),
      toolCallId: exports_external.string(),
      state: exports_external.literal("approval-requested"),
      input: exports_external.unknown(),
      providerExecuted: exports_external.boolean().optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.never().optional(),
        reason: exports_external.never().optional()
      })
    }),
    exports_external.object({
      type: exports_external.literal("dynamic-tool"),
      toolName: exports_external.string(),
      toolCallId: exports_external.string(),
      state: exports_external.literal("approval-responded"),
      input: exports_external.unknown(),
      providerExecuted: exports_external.boolean().optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.boolean(),
        reason: exports_external.string().optional()
      })
    }),
    exports_external.object({
      type: exports_external.literal("dynamic-tool"),
      toolName: exports_external.string(),
      toolCallId: exports_external.string(),
      state: exports_external.literal("output-available"),
      input: exports_external.unknown(),
      providerExecuted: exports_external.boolean().optional(),
      output: exports_external.unknown(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      preliminary: exports_external.boolean().optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.literal(!0),
        reason: exports_external.string().optional()
      }).optional()
    }),
    exports_external.object({
      type: exports_external.literal("dynamic-tool"),
      toolName: exports_external.string(),
      toolCallId: exports_external.string(),
      state: exports_external.literal("output-error"),
      input: exports_external.unknown(),
      rawInput: exports_external.unknown().optional(),
      providerExecuted: exports_external.boolean().optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.string(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.literal(!0),
        reason: exports_external.string().optional()
      }).optional()
    }),
    exports_external.object({
      type: exports_external.literal("dynamic-tool"),
      toolName: exports_external.string(),
      toolCallId: exports_external.string(),
      state: exports_external.literal("output-denied"),
      input: exports_external.unknown(),
      providerExecuted: exports_external.boolean().optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.literal(!1),
        reason: exports_external.string().optional()
      })
    }),
    exports_external.object({
      type: exports_external.string().startsWith("tool-"),
      toolCallId: exports_external.string(),
      state: exports_external.literal("input-streaming"),
      providerExecuted: exports_external.boolean().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      input: exports_external.unknown().optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      approval: exports_external.never().optional()
    }),
    exports_external.object({
      type: exports_external.string().startsWith("tool-"),
      toolCallId: exports_external.string(),
      state: exports_external.literal("input-available"),
      providerExecuted: exports_external.boolean().optional(),
      input: exports_external.unknown(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.never().optional()
    }),
    exports_external.object({
      type: exports_external.string().startsWith("tool-"),
      toolCallId: exports_external.string(),
      state: exports_external.literal("approval-requested"),
      input: exports_external.unknown(),
      providerExecuted: exports_external.boolean().optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.never().optional(),
        reason: exports_external.never().optional()
      })
    }),
    exports_external.object({
      type: exports_external.string().startsWith("tool-"),
      toolCallId: exports_external.string(),
      state: exports_external.literal("approval-responded"),
      input: exports_external.unknown(),
      providerExecuted: exports_external.boolean().optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.boolean(),
        reason: exports_external.string().optional()
      })
    }),
    exports_external.object({
      type: exports_external.string().startsWith("tool-"),
      toolCallId: exports_external.string(),
      state: exports_external.literal("output-available"),
      providerExecuted: exports_external.boolean().optional(),
      input: exports_external.unknown(),
      output: exports_external.unknown(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      preliminary: exports_external.boolean().optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.literal(!0),
        reason: exports_external.string().optional()
      }).optional()
    }),
    exports_external.object({
      type: exports_external.string().startsWith("tool-"),
      toolCallId: exports_external.string(),
      state: exports_external.literal("output-error"),
      providerExecuted: exports_external.boolean().optional(),
      input: exports_external.unknown(),
      rawInput: exports_external.unknown().optional(),
      output: exports_external.never().optional(),
      errorText: exports_external.string(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.literal(!0),
        reason: exports_external.string().optional()
      }).optional()
    }),
    exports_external.object({
      type: exports_external.string().startsWith("tool-"),
      toolCallId: exports_external.string(),
      state: exports_external.literal("output-denied"),
      providerExecuted: exports_external.boolean().optional(),
      input: exports_external.unknown(),
      output: exports_external.never().optional(),
      errorText: exports_external.never().optional(),
      callProviderMetadata: providerMetadataSchema.optional(),
      approval: exports_external.object({
        id: exports_external.string(),
        approved: exports_external.literal(!1),
        reason: exports_external.string().optional()
      })
    })
  ])).nonempty("Message must contain at least one part")
})).nonempty("Messages array must not be empty")));
var originalGenerateId3 = createIdGenerator({ prefix: "aiobj", size: 24 });
var originalGenerateId4 = createIdGenerator({ prefix: "aiobj", size: 24 });
var name20 = "AI_NoSuchProviderError", marker20 = `vercel.ai.error.${name20}`, symbol20 = Symbol.for(marker20), _a20;
_a20 = symbol20;
// node_modules/@ai-sdk/mistral/dist/index.mjs
function convertMistralUsage(usage) {
  if (usage == null)
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  let { prompt_tokens: promptTokens, completion_tokens: completionTokens } = usage;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens,
      cacheRead: void 0,
      cacheWrite: void 0
    },
    outputTokens: {
      total: completionTokens,
      text: completionTokens,
      reasoning: void 0
    },
    raw: usage
  };
}
function formatFileUrl({
  data,
  mediaType
}) {
  return data instanceof URL ? data.toString() : `data:${mediaType};base64,${convertToBase64(data)}`;
}
function convertToMistralChatMessages(prompt) {
  var _a21;
  let messages = [];
  for (let i = 0;i < prompt.length; i++) {
    let { role, content } = prompt[i], isLastMessage = i === prompt.length - 1;
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text":
                return { type: "text", text: part.text };
              case "file":
                if (part.mediaType.startsWith("image/")) {
                  let mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: formatFileUrl({ data: part.data, mediaType })
                  };
                } else if (part.mediaType === "application/pdf")
                  return {
                    type: "document_url",
                    document_url: formatFileUrl({
                      data: part.data,
                      mediaType: "application/pdf"
                    })
                  };
                else
                  throw new UnsupportedFunctionalityError({
                    functionality: "Only images and PDF file parts are supported"
                  });
            }
          })
        });
        break;
      }
      case "assistant": {
        let text2 = "", toolCalls = [];
        for (let part of content)
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              text2 += part.text;
              break;
            }
            default:
              throw Error(`Unsupported content type in assistant message: ${part.type}`);
          }
        messages.push({
          role: "assistant",
          content: text2,
          prefix: isLastMessage ? !0 : void 0,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (let toolResponse of content) {
          if (toolResponse.type === "tool-approval-response")
            continue;
          let output = toolResponse.output, contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_a21 = output.reason) != null ? _a21 : "Tool execution denied.";
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            name: toolResponse.toolName,
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  }
  return messages;
}
function getResponseMetadata({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1000) : void 0
  };
}
function mapMistralFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
    case "model_length":
      return "length";
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
var mistralLanguageModelOptions = exports_external.object({
  safePrompt: exports_external.boolean().optional(),
  documentImageLimit: exports_external.number().optional(),
  documentPageLimit: exports_external.number().optional(),
  structuredOutputs: exports_external.boolean().optional(),
  strictJsonSchema: exports_external.boolean().optional(),
  parallelToolCalls: exports_external.boolean().optional()
}), mistralErrorDataSchema = exports_external.object({
  object: exports_external.literal("error"),
  message: exports_external.string(),
  type: exports_external.string(),
  param: exports_external.string().nullable(),
  code: exports_external.string().nullable()
}), mistralFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: mistralErrorDataSchema,
  errorToMessage: (data) => data.message
});
function prepareTools({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  let toolWarnings = [];
  if (tools == null)
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  let mistralTools = [];
  for (let tool2 of tools)
    if (tool2.type === "provider")
      toolWarnings.push({
        type: "unsupported",
        feature: `provider-defined tool ${tool2.id}`
      });
    else
      mistralTools.push({
        type: "function",
        function: {
          name: tool2.name,
          description: tool2.description,
          parameters: tool2.inputSchema,
          ...tool2.strict != null ? { strict: tool2.strict } : {}
        }
      });
  if (toolChoice == null)
    return { tools: mistralTools, toolChoice: void 0, toolWarnings };
  let type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: mistralTools, toolChoice: type, toolWarnings };
    case "required":
      return { tools: mistralTools, toolChoice: "any", toolWarnings };
    case "tool":
      return {
        tools: mistralTools.filter((tool2) => tool2.function.name === toolChoice.toolName),
        toolChoice: "any",
        toolWarnings
      };
    default:
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${type}`
      });
  }
}
var MistralChatLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.supportedUrls = {
      "application/pdf": [/^https:\/\/.*$/]
    };
    var _a21;
    this.modelId = modelId, this.config = config2, this.generateId = (_a21 = config2.generateId) != null ? _a21 : generateId;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    providerOptions,
    tools,
    toolChoice
  }) {
    var _a21, _b16, _c, _d;
    let warnings = [], options = (_a21 = await parseProviderOptions({
      provider: "mistral",
      providerOptions,
      schema: mistralLanguageModelOptions
    })) != null ? _a21 : {};
    if (topK != null)
      warnings.push({ type: "unsupported", feature: "topK" });
    if (frequencyPenalty != null)
      warnings.push({ type: "unsupported", feature: "frequencyPenalty" });
    if (presencePenalty != null)
      warnings.push({ type: "unsupported", feature: "presencePenalty" });
    if (stopSequences != null)
      warnings.push({ type: "unsupported", feature: "stopSequences" });
    let structuredOutputs = (_b16 = options.structuredOutputs) != null ? _b16 : !0, strictJsonSchema = (_c = options.strictJsonSchema) != null ? _c : !1;
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && !(responseFormat == null ? void 0 : responseFormat.schema))
      prompt = injectJsonInstructionIntoMessages({
        messages: prompt,
        schema: responseFormat.schema
      });
    let baseArgs = {
      model: this.modelId,
      safe_prompt: options.safePrompt,
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      random_seed: seed,
      response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && (responseFormat == null ? void 0 : responseFormat.schema) != null ? {
        type: "json_schema",
        json_schema: {
          schema: responseFormat.schema,
          strict: strictJsonSchema,
          name: (_d = responseFormat.name) != null ? _d : "response",
          description: responseFormat.description
        }
      } : { type: "json_object" } : void 0,
      document_image_limit: options.documentImageLimit,
      document_page_limit: options.documentPageLimit,
      messages: convertToMistralChatMessages(prompt)
    }, {
      tools: mistralTools,
      toolChoice: mistralToolChoice,
      toolWarnings
    } = prepareTools({
      tools,
      toolChoice
    });
    return {
      args: {
        ...baseArgs,
        tools: mistralTools,
        tool_choice: mistralToolChoice,
        ...mistralTools != null && options.parallelToolCalls !== void 0 ? { parallel_tool_calls: options.parallelToolCalls } : {}
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  async doGenerate(options) {
    var _a21;
    let { args: body, warnings } = await this.getArgs(options), {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: `${this.config.baseURL}/chat/completions`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: mistralFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(mistralChatResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), choice2 = response.choices[0], content = [];
    if (choice2.message.content != null && Array.isArray(choice2.message.content)) {
      for (let part of choice2.message.content)
        if (part.type === "thinking") {
          let reasoningText = extractReasoningContent(part.thinking);
          if (reasoningText.length > 0)
            content.push({ type: "reasoning", text: reasoningText });
        } else if (part.type === "text") {
          if (part.text.length > 0)
            content.push({ type: "text", text: part.text });
        }
    } else {
      let text2 = extractTextContent2(choice2.message.content);
      if (text2 != null && text2.length > 0)
        content.push({ type: "text", text: text2 });
    }
    if (choice2.message.tool_calls != null)
      for (let toolCall of choice2.message.tool_calls)
        content.push({
          type: "tool-call",
          toolCallId: toolCall.id,
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
    return {
      content,
      finishReason: {
        unified: mapMistralFinishReason(choice2.finish_reason),
        raw: (_a21 = choice2.finish_reason) != null ? _a21 : void 0
      },
      usage: convertMistralUsage(response.usage),
      request: { body },
      response: {
        ...getResponseMetadata(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    let { args, warnings } = await this.getArgs(options), body = { ...args, stream: !0 }, { responseHeaders, value: response } = await postJsonToApi({
      url: `${this.config.baseURL}/chat/completions`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: mistralFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(mistralChatChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), finishReason = {
      unified: "other",
      raw: void 0
    }, usage = void 0, isFirstChunk = !0, activeText = !1, activeReasoningId = null, generateId2 = this.generateId;
    return {
      stream: response.pipeThrough(new TransformStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings });
        },
        transform(chunk, controller) {
          if (options.includeRawChunks)
            controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
          if (!chunk.success) {
            controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          let value = chunk.value;
          if (isFirstChunk)
            isFirstChunk = !1, controller.enqueue({
              type: "response-metadata",
              ...getResponseMetadata(value)
            });
          if (value.usage != null)
            usage = value.usage;
          let choice2 = value.choices[0], delta = choice2.delta, textContent = extractTextContent2(delta.content);
          if (delta.content != null && Array.isArray(delta.content)) {
            for (let part of delta.content)
              if (part.type === "thinking") {
                let reasoningDelta = extractReasoningContent(part.thinking);
                if (reasoningDelta.length > 0) {
                  if (activeReasoningId == null) {
                    if (activeText)
                      controller.enqueue({ type: "text-end", id: "0" }), activeText = !1;
                    activeReasoningId = generateId2(), controller.enqueue({
                      type: "reasoning-start",
                      id: activeReasoningId
                    });
                  }
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: activeReasoningId,
                    delta: reasoningDelta
                  });
                }
              }
          }
          if (textContent != null && textContent.length > 0) {
            if (!activeText) {
              if (activeReasoningId != null)
                controller.enqueue({
                  type: "reasoning-end",
                  id: activeReasoningId
                }), activeReasoningId = null;
              controller.enqueue({ type: "text-start", id: "0" }), activeText = !0;
            }
            controller.enqueue({
              type: "text-delta",
              id: "0",
              delta: textContent
            });
          }
          if ((delta == null ? void 0 : delta.tool_calls) != null)
            for (let toolCall of delta.tool_calls) {
              let toolCallId = toolCall.id, toolName = toolCall.function.name, input = toolCall.function.arguments;
              controller.enqueue({
                type: "tool-input-start",
                id: toolCallId,
                toolName
              }), controller.enqueue({
                type: "tool-input-delta",
                id: toolCallId,
                delta: input
              }), controller.enqueue({
                type: "tool-input-end",
                id: toolCallId
              }), controller.enqueue({
                type: "tool-call",
                toolCallId,
                toolName,
                input
              });
            }
          if (choice2.finish_reason != null)
            finishReason = {
              unified: mapMistralFinishReason(choice2.finish_reason),
              raw: choice2.finish_reason
            };
        },
        flush(controller) {
          if (activeReasoningId != null)
            controller.enqueue({
              type: "reasoning-end",
              id: activeReasoningId
            });
          if (activeText)
            controller.enqueue({ type: "text-end", id: "0" });
          controller.enqueue({
            type: "finish",
            finishReason,
            usage: convertMistralUsage(usage)
          });
        }
      })),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function extractReasoningContent(thinking) {
  return thinking.filter((chunk) => chunk.type === "text").map((chunk) => chunk.text).join("");
}
function extractTextContent2(content) {
  if (typeof content === "string")
    return content;
  if (content == null)
    return;
  let textContent = [];
  for (let chunk of content) {
    let { type } = chunk;
    switch (type) {
      case "text":
        textContent.push(chunk.text);
        break;
      case "thinking":
      case "image_url":
      case "reference":
        break;
      default:
        throw Error(`Unsupported type: ${type}`);
    }
  }
  return textContent.length ? textContent.join("") : void 0;
}
var mistralContentSchema = exports_external.union([
  exports_external.string(),
  exports_external.array(exports_external.discriminatedUnion("type", [
    exports_external.object({
      type: exports_external.literal("text"),
      text: exports_external.string()
    }),
    exports_external.object({
      type: exports_external.literal("image_url"),
      image_url: exports_external.union([
        exports_external.string(),
        exports_external.object({
          url: exports_external.string(),
          detail: exports_external.string().nullable()
        })
      ])
    }),
    exports_external.object({
      type: exports_external.literal("reference"),
      reference_ids: exports_external.array(exports_external.union([exports_external.string(), exports_external.number()]))
    }),
    exports_external.object({
      type: exports_external.literal("thinking"),
      thinking: exports_external.array(exports_external.object({
        type: exports_external.literal("text"),
        text: exports_external.string()
      }))
    })
  ]))
]).nullish(), mistralUsageSchema = exports_external.object({
  prompt_tokens: exports_external.number(),
  completion_tokens: exports_external.number(),
  total_tokens: exports_external.number()
}), mistralChatResponseSchema = exports_external.object({
  id: exports_external.string().nullish(),
  created: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  choices: exports_external.array(exports_external.object({
    message: exports_external.object({
      role: exports_external.literal("assistant"),
      content: mistralContentSchema,
      tool_calls: exports_external.array(exports_external.object({
        id: exports_external.string(),
        function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() })
      })).nullish()
    }),
    index: exports_external.number(),
    finish_reason: exports_external.string().nullish()
  })),
  object: exports_external.literal("chat.completion"),
  usage: mistralUsageSchema
}), mistralChatChunkSchema = exports_external.object({
  id: exports_external.string().nullish(),
  created: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  choices: exports_external.array(exports_external.object({
    delta: exports_external.object({
      role: exports_external.enum(["assistant"]).optional(),
      content: mistralContentSchema,
      tool_calls: exports_external.array(exports_external.object({
        id: exports_external.string(),
        function: exports_external.object({ name: exports_external.string(), arguments: exports_external.string() })
      })).nullish()
    }),
    finish_reason: exports_external.string().nullish(),
    index: exports_external.number()
  })),
  usage: mistralUsageSchema.nullish()
}), MistralEmbeddingModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.maxEmbeddingsPerCall = 32, this.supportsParallelCalls = !1, this.modelId = modelId, this.config = config2;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    abortSignal,
    headers
  }) {
    if (values.length > this.maxEmbeddingsPerCall)
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    let {
      responseHeaders,
      value: response,
      rawValue
    } = await postJsonToApi({
      url: `${this.config.baseURL}/embeddings`,
      headers: combineHeaders(this.config.headers(), headers),
      body: {
        model: this.modelId,
        input: values,
        encoding_format: "float"
      },
      failedResponseHandler: mistralFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(MistralTextEmbeddingResponseSchema),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      warnings: [],
      embeddings: response.data.map((item) => item.embedding),
      usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
      response: { headers: responseHeaders, body: rawValue }
    };
  }
}, MistralTextEmbeddingResponseSchema = exports_external.object({
  data: exports_external.array(exports_external.object({ embedding: exports_external.array(exports_external.number()) })),
  usage: exports_external.object({ prompt_tokens: exports_external.number() }).nullish()
}), VERSION5 = "3.0.18";
function createMistral(options = {}) {
  var _a21;
  let baseURL = (_a21 = withoutTrailingSlash(options.baseURL)) != null ? _a21 : "https://api.mistral.ai/v1", getHeaders = () => withUserAgentSuffix({
    Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "MISTRAL_API_KEY",
      description: "Mistral"
    })}`,
    ...options.headers
  }, `ai-sdk/mistral/${VERSION5}`), createChatModel = (modelId) => new MistralChatLanguageModel(modelId, {
    provider: "mistral.chat",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch,
    generateId: options.generateId
  }), createEmbeddingModel = (modelId) => new MistralEmbeddingModel(modelId, {
    provider: "mistral.embedding",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  }), provider = function(modelId) {
    if (new.target)
      throw Error("The Mistral model function cannot be called with the new keyword.");
    return createChatModel(modelId);
  };
  return provider.specificationVersion = "v3", provider.languageModel = createChatModel, provider.chat = createChatModel, provider.embedding = createEmbeddingModel, provider.embeddingModel = createEmbeddingModel, provider.textEmbedding = createEmbeddingModel, provider.textEmbeddingModel = createEmbeddingModel, provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  }, provider;
}
var mistral = createMistral();
// node_modules/@ai-sdk/google/dist/index.mjs
var VERSION6 = "3.0.20", googleErrorDataSchema = lazySchema(() => zodSchema(exports_external.object({
  error: exports_external.object({
    code: exports_external.number().nullable(),
    message: exports_external.string(),
    status: exports_external.string()
  })
}))), googleFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: googleErrorDataSchema,
  errorToMessage: (data) => data.error.message
}), googleGenerativeAIEmbeddingProviderOptions = lazySchema(() => zodSchema(exports_external.object({
  outputDimensionality: exports_external.number().optional(),
  taskType: exports_external.enum([
    "SEMANTIC_SIMILARITY",
    "CLASSIFICATION",
    "CLUSTERING",
    "RETRIEVAL_DOCUMENT",
    "RETRIEVAL_QUERY",
    "QUESTION_ANSWERING",
    "FACT_VERIFICATION",
    "CODE_RETRIEVAL_QUERY"
  ]).optional()
}))), GoogleGenerativeAIEmbeddingModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.maxEmbeddingsPerCall = 2048, this.supportsParallelCalls = !0, this.modelId = modelId, this.config = config2;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    let googleOptions = await parseProviderOptions({
      provider: "google",
      providerOptions,
      schema: googleGenerativeAIEmbeddingProviderOptions
    });
    if (values.length > this.maxEmbeddingsPerCall)
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    let mergedHeaders = combineHeaders(await resolve(this.config.headers), headers);
    if (values.length === 1) {
      let {
        responseHeaders: responseHeaders2,
        value: response2,
        rawValue: rawValue2
      } = await postJsonToApi({
        url: `${this.config.baseURL}/models/${this.modelId}:embedContent`,
        headers: mergedHeaders,
        body: {
          model: `models/${this.modelId}`,
          content: {
            parts: [{ text: values[0] }]
          },
          outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
          taskType: googleOptions == null ? void 0 : googleOptions.taskType
        },
        failedResponseHandler: googleFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(googleGenerativeAISingleEmbeddingResponseSchema),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        warnings: [],
        embeddings: [response2.embedding.values],
        usage: void 0,
        response: { headers: responseHeaders2, body: rawValue2 }
      };
    }
    let {
      responseHeaders,
      value: response,
      rawValue
    } = await postJsonToApi({
      url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
      headers: mergedHeaders,
      body: {
        requests: values.map((value) => ({
          model: `models/${this.modelId}`,
          content: { role: "user", parts: [{ text: value }] },
          outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
          taskType: googleOptions == null ? void 0 : googleOptions.taskType
        }))
      },
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(googleGenerativeAITextEmbeddingResponseSchema),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      warnings: [],
      embeddings: response.embeddings.map((item) => item.values),
      usage: void 0,
      response: { headers: responseHeaders, body: rawValue }
    };
  }
}, googleGenerativeAITextEmbeddingResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  embeddings: exports_external.array(exports_external.object({ values: exports_external.array(exports_external.number()) }))
}))), googleGenerativeAISingleEmbeddingResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  embedding: exports_external.object({ values: exports_external.array(exports_external.number()) })
})));
function convertGoogleGenerativeAIUsage(usage) {
  var _a21, _b16, _c, _d;
  if (usage == null)
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  let promptTokens = (_a21 = usage.promptTokenCount) != null ? _a21 : 0, candidatesTokens = (_b16 = usage.candidatesTokenCount) != null ? _b16 : 0, cachedContentTokens = (_c = usage.cachedContentTokenCount) != null ? _c : 0, thoughtsTokens = (_d = usage.thoughtsTokenCount) != null ? _d : 0;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens - cachedContentTokens,
      cacheRead: cachedContentTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: candidatesTokens + thoughtsTokens,
      text: candidatesTokens,
      reasoning: thoughtsTokens
    },
    raw: usage
  };
}
function convertJSONSchemaToOpenAPISchema(jsonSchema2, isRoot = !0) {
  if (jsonSchema2 == null)
    return;
  if (isEmptyObjectSchema(jsonSchema2)) {
    if (isRoot)
      return;
    if (typeof jsonSchema2 === "object" && jsonSchema2.description)
      return { type: "object", description: jsonSchema2.description };
    return { type: "object" };
  }
  if (typeof jsonSchema2 === "boolean")
    return { type: "boolean", properties: {} };
  let {
    type,
    description,
    required: required2,
    properties,
    items,
    allOf,
    anyOf,
    oneOf,
    format,
    const: constValue,
    minLength,
    enum: enumValues
  } = jsonSchema2, result = {};
  if (description)
    result.description = description;
  if (required2)
    result.required = required2;
  if (format)
    result.format = format;
  if (constValue !== void 0)
    result.enum = [constValue];
  if (type)
    if (Array.isArray(type)) {
      let hasNull = type.includes("null"), nonNullTypes = type.filter((t) => t !== "null");
      if (nonNullTypes.length === 0)
        result.type = "null";
      else if (result.anyOf = nonNullTypes.map((t) => ({ type: t })), hasNull)
        result.nullable = !0;
    } else
      result.type = type;
  if (enumValues !== void 0)
    result.enum = enumValues;
  if (properties != null)
    result.properties = Object.entries(properties).reduce((acc, [key, value]) => {
      return acc[key] = convertJSONSchemaToOpenAPISchema(value, !1), acc;
    }, {});
  if (items)
    result.items = Array.isArray(items) ? items.map((item) => convertJSONSchemaToOpenAPISchema(item, !1)) : convertJSONSchemaToOpenAPISchema(items, !1);
  if (allOf)
    result.allOf = allOf.map((item) => convertJSONSchemaToOpenAPISchema(item, !1));
  if (anyOf)
    if (anyOf.some((schema) => typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null")) {
      let nonNullSchemas = anyOf.filter((schema) => !(typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null"));
      if (nonNullSchemas.length === 1) {
        let converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0], !1);
        if (typeof converted === "object")
          result.nullable = !0, Object.assign(result, converted);
      } else
        result.anyOf = nonNullSchemas.map((item) => convertJSONSchemaToOpenAPISchema(item, !1)), result.nullable = !0;
    } else
      result.anyOf = anyOf.map((item) => convertJSONSchemaToOpenAPISchema(item, !1));
  if (oneOf)
    result.oneOf = oneOf.map((item) => convertJSONSchemaToOpenAPISchema(item, !1));
  if (minLength !== void 0)
    result.minLength = minLength;
  return result;
}
function isEmptyObjectSchema(jsonSchema2) {
  return jsonSchema2 != null && typeof jsonSchema2 === "object" && jsonSchema2.type === "object" && (jsonSchema2.properties == null || Object.keys(jsonSchema2.properties).length === 0) && !jsonSchema2.additionalProperties;
}
function convertToGoogleGenerativeAIMessages(prompt, options) {
  var _a21, _b16, _c;
  let systemInstructionParts = [], contents = [], systemMessagesAllowed = !0, isGemmaModel = (_a21 = options == null ? void 0 : options.isGemmaModel) != null ? _a21 : !1, providerOptionsName = (_b16 = options == null ? void 0 : options.providerOptionsName) != null ? _b16 : "google";
  for (let { role, content } of prompt)
    switch (role) {
      case "system": {
        if (!systemMessagesAllowed)
          throw new UnsupportedFunctionalityError({
            functionality: "system messages are only supported at the beginning of the conversation"
          });
        systemInstructionParts.push({ text: content });
        break;
      }
      case "user": {
        systemMessagesAllowed = !1;
        let parts = [];
        for (let part of content)
          switch (part.type) {
            case "text": {
              parts.push({ text: part.text });
              break;
            }
            case "file": {
              let mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
              parts.push(part.data instanceof URL ? {
                fileData: {
                  mimeType: mediaType,
                  fileUri: part.data.toString()
                }
              } : {
                inlineData: {
                  mimeType: mediaType,
                  data: convertToBase64(part.data)
                }
              });
              break;
            }
          }
        contents.push({ role: "user", parts });
        break;
      }
      case "assistant": {
        systemMessagesAllowed = !1, contents.push({
          role: "model",
          parts: content.map((part) => {
            var _a24;
            let providerOpts = (_a24 = part.providerOptions) == null ? void 0 : _a24[providerOptionsName], thoughtSignature = (providerOpts == null ? void 0 : providerOpts.thoughtSignature) != null ? String(providerOpts.thoughtSignature) : void 0;
            switch (part.type) {
              case "text":
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thoughtSignature
                };
              case "reasoning":
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thought: !0,
                  thoughtSignature
                };
              case "file": {
                if (part.data instanceof URL)
                  throw new UnsupportedFunctionalityError({
                    functionality: "File data URLs in assistant messages are not supported"
                  });
                return {
                  inlineData: {
                    mimeType: part.mediaType,
                    data: convertToBase64(part.data)
                  },
                  thoughtSignature
                };
              }
              case "tool-call":
                return {
                  functionCall: {
                    name: part.toolName,
                    args: part.input
                  },
                  thoughtSignature
                };
            }
          }).filter((part) => part !== void 0)
        });
        break;
      }
      case "tool": {
        systemMessagesAllowed = !1;
        let parts = [];
        for (let part of content) {
          if (part.type === "tool-approval-response")
            continue;
          let output = part.output;
          if (output.type === "content")
            for (let contentPart of output.value)
              switch (contentPart.type) {
                case "text":
                  parts.push({
                    functionResponse: {
                      name: part.toolName,
                      response: {
                        name: part.toolName,
                        content: contentPart.text
                      }
                    }
                  });
                  break;
                case "image-data":
                  parts.push({
                    inlineData: {
                      mimeType: contentPart.mediaType,
                      data: contentPart.data
                    }
                  }, {
                    text: "Tool executed successfully and returned this image as a response"
                  });
                  break;
                default:
                  parts.push({ text: JSON.stringify(contentPart) });
                  break;
              }
          else
            parts.push({
              functionResponse: {
                name: part.toolName,
                response: {
                  name: part.toolName,
                  content: output.type === "execution-denied" ? (_c = output.reason) != null ? _c : "Tool execution denied." : output.value
                }
              }
            });
        }
        contents.push({
          role: "user",
          parts
        });
        break;
      }
    }
  if (isGemmaModel && systemInstructionParts.length > 0 && contents.length > 0 && contents[0].role === "user") {
    let systemText = systemInstructionParts.map((part) => part.text).join(`

`);
    contents[0].parts.unshift({ text: systemText + `

` });
  }
  return {
    systemInstruction: systemInstructionParts.length > 0 && !isGemmaModel ? { parts: systemInstructionParts } : void 0,
    contents
  };
}
function getModelPath(modelId) {
  return modelId.includes("/") ? modelId : `models/${modelId}`;
}
var googleGenerativeAIProviderOptions = lazySchema(() => zodSchema(exports_external.object({
  responseModalities: exports_external.array(exports_external.enum(["TEXT", "IMAGE"])).optional(),
  thinkingConfig: exports_external.object({
    thinkingBudget: exports_external.number().optional(),
    includeThoughts: exports_external.boolean().optional(),
    thinkingLevel: exports_external.enum(["minimal", "low", "medium", "high"]).optional()
  }).optional(),
  cachedContent: exports_external.string().optional(),
  structuredOutputs: exports_external.boolean().optional(),
  safetySettings: exports_external.array(exports_external.object({
    category: exports_external.enum([
      "HARM_CATEGORY_UNSPECIFIED",
      "HARM_CATEGORY_HATE_SPEECH",
      "HARM_CATEGORY_DANGEROUS_CONTENT",
      "HARM_CATEGORY_HARASSMENT",
      "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "HARM_CATEGORY_CIVIC_INTEGRITY"
    ]),
    threshold: exports_external.enum([
      "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
      "BLOCK_LOW_AND_ABOVE",
      "BLOCK_MEDIUM_AND_ABOVE",
      "BLOCK_ONLY_HIGH",
      "BLOCK_NONE",
      "OFF"
    ])
  })).optional(),
  threshold: exports_external.enum([
    "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
    "BLOCK_LOW_AND_ABOVE",
    "BLOCK_MEDIUM_AND_ABOVE",
    "BLOCK_ONLY_HIGH",
    "BLOCK_NONE",
    "OFF"
  ]).optional(),
  audioTimestamp: exports_external.boolean().optional(),
  labels: exports_external.record(exports_external.string(), exports_external.string()).optional(),
  mediaResolution: exports_external.enum([
    "MEDIA_RESOLUTION_UNSPECIFIED",
    "MEDIA_RESOLUTION_LOW",
    "MEDIA_RESOLUTION_MEDIUM",
    "MEDIA_RESOLUTION_HIGH"
  ]).optional(),
  imageConfig: exports_external.object({
    aspectRatio: exports_external.enum([
      "1:1",
      "2:3",
      "3:2",
      "3:4",
      "4:3",
      "4:5",
      "5:4",
      "9:16",
      "16:9",
      "21:9"
    ]).optional(),
    imageSize: exports_external.enum(["1K", "2K", "4K"]).optional()
  }).optional(),
  retrievalConfig: exports_external.object({
    latLng: exports_external.object({
      latitude: exports_external.number(),
      longitude: exports_external.number()
    }).optional()
  }).optional()
})));
function prepareTools2({
  tools,
  toolChoice,
  modelId
}) {
  var _a21;
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  let toolWarnings = [], isLatest = [
    "gemini-flash-latest",
    "gemini-flash-lite-latest",
    "gemini-pro-latest"
  ].some((id) => id === modelId), isGemini2orNewer = modelId.includes("gemini-2") || modelId.includes("gemini-3") || isLatest, supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b"), supportsFileSearch = modelId.includes("gemini-2.5") || modelId.includes("gemini-3");
  if (tools == null)
    return { tools: void 0, toolConfig: void 0, toolWarnings };
  let hasFunctionTools = tools.some((tool2) => tool2.type === "function"), hasProviderTools = tools.some((tool2) => tool2.type === "provider");
  if (hasFunctionTools && hasProviderTools)
    toolWarnings.push({
      type: "unsupported",
      feature: "combination of function and provider-defined tools"
    });
  if (hasProviderTools) {
    let googleTools2 = [];
    return tools.filter((tool2) => tool2.type === "provider").forEach((tool2) => {
      switch (tool2.id) {
        case "google.google_search":
          if (isGemini2orNewer)
            googleTools2.push({ googleSearch: {} });
          else if (supportsDynamicRetrieval)
            googleTools2.push({
              googleSearchRetrieval: {
                dynamicRetrievalConfig: {
                  mode: tool2.args.mode,
                  dynamicThreshold: tool2.args.dynamicThreshold
                }
              }
            });
          else
            googleTools2.push({ googleSearchRetrieval: {} });
          break;
        case "google.enterprise_web_search":
          if (isGemini2orNewer)
            googleTools2.push({ enterpriseWebSearch: {} });
          else
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "Enterprise Web Search requires Gemini 2.0 or newer."
            });
          break;
        case "google.url_context":
          if (isGemini2orNewer)
            googleTools2.push({ urlContext: {} });
          else
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The URL context tool is not supported with other Gemini models than Gemini 2."
            });
          break;
        case "google.code_execution":
          if (isGemini2orNewer)
            googleTools2.push({ codeExecution: {} });
          else
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The code execution tools is not supported with other Gemini models than Gemini 2."
            });
          break;
        case "google.file_search":
          if (supportsFileSearch)
            googleTools2.push({ fileSearch: { ...tool2.args } });
          else
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The file search tool is only supported with Gemini 2.5 models and Gemini 3 models."
            });
          break;
        case "google.vertex_rag_store":
          if (isGemini2orNewer)
            googleTools2.push({
              retrieval: {
                vertex_rag_store: {
                  rag_resources: {
                    rag_corpus: tool2.args.ragCorpus
                  },
                  similarity_top_k: tool2.args.topK
                }
              }
            });
          else
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The RAG store tool is not supported with other Gemini models than Gemini 2."
            });
          break;
        case "google.google_maps":
          if (isGemini2orNewer)
            googleTools2.push({ googleMaps: {} });
          else
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`,
              details: "The Google Maps grounding tool is not supported with Gemini models other than Gemini 2 or newer."
            });
          break;
        default:
          toolWarnings.push({
            type: "unsupported",
            feature: `provider-defined tool ${tool2.id}`
          });
          break;
      }
    }), {
      tools: googleTools2.length > 0 ? googleTools2 : void 0,
      toolConfig: void 0,
      toolWarnings
    };
  }
  let functionDeclarations = [];
  for (let tool2 of tools)
    switch (tool2.type) {
      case "function":
        functionDeclarations.push({
          name: tool2.name,
          description: (_a21 = tool2.description) != null ? _a21 : "",
          parameters: convertJSONSchemaToOpenAPISchema(tool2.inputSchema)
        });
        break;
      default:
        toolWarnings.push({
          type: "unsupported",
          feature: `function tool ${tool2.name}`
        });
        break;
    }
  if (toolChoice == null)
    return {
      tools: [{ functionDeclarations }],
      toolConfig: void 0,
      toolWarnings
    };
  let type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: { functionCallingConfig: { mode: "AUTO" } },
        toolWarnings
      };
    case "none":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: { functionCallingConfig: { mode: "NONE" } },
        toolWarnings
      };
    case "required":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: { functionCallingConfig: { mode: "ANY" } },
        toolWarnings
      };
    case "tool":
      return {
        tools: [{ functionDeclarations }],
        toolConfig: {
          functionCallingConfig: {
            mode: "ANY",
            allowedFunctionNames: [toolChoice.toolName]
          }
        },
        toolWarnings
      };
    default:
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${type}`
      });
  }
}
function mapGoogleGenerativeAIFinishReason({
  finishReason,
  hasToolCalls
}) {
  switch (finishReason) {
    case "STOP":
      return hasToolCalls ? "tool-calls" : "stop";
    case "MAX_TOKENS":
      return "length";
    case "IMAGE_SAFETY":
    case "RECITATION":
    case "SAFETY":
    case "BLOCKLIST":
    case "PROHIBITED_CONTENT":
    case "SPII":
      return "content-filter";
    case "MALFORMED_FUNCTION_CALL":
      return "error";
    case "FINISH_REASON_UNSPECIFIED":
    case "OTHER":
    default:
      return "other";
  }
}
var GoogleGenerativeAILanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3";
    var _a21;
    this.modelId = modelId, this.config = config2, this.generateId = (_a21 = config2.generateId) != null ? _a21 : generateId;
  }
  get provider() {
    return this.config.provider;
  }
  get supportedUrls() {
    var _a21, _b16, _c;
    return (_c = (_b16 = (_a21 = this.config).supportedUrls) == null ? void 0 : _b16.call(_a21)) != null ? _c : {};
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    tools,
    toolChoice,
    providerOptions
  }) {
    var _a21;
    let warnings = [], providerOptionsName = this.config.provider.includes("vertex") ? "vertex" : "google", googleOptions = await parseProviderOptions({
      provider: providerOptionsName,
      providerOptions,
      schema: googleGenerativeAIProviderOptions
    });
    if (googleOptions == null && providerOptionsName !== "google")
      googleOptions = await parseProviderOptions({
        provider: "google",
        providerOptions,
        schema: googleGenerativeAIProviderOptions
      });
    if ((tools == null ? void 0 : tools.some((tool2) => tool2.type === "provider" && tool2.id === "google.vertex_rag_store")) && !this.config.provider.startsWith("google.vertex."))
      warnings.push({
        type: "other",
        message: `The 'vertex_rag_store' tool is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
      });
    let isGemmaModel = this.modelId.toLowerCase().startsWith("gemma-"), { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(prompt, { isGemmaModel, providerOptionsName }), {
      tools: googleTools2,
      toolConfig: googleToolConfig,
      toolWarnings
    } = prepareTools2({
      tools,
      toolChoice,
      modelId: this.modelId
    });
    return {
      args: {
        generationConfig: {
          maxOutputTokens,
          temperature,
          topK,
          topP,
          frequencyPenalty,
          presencePenalty,
          stopSequences,
          seed,
          responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
          responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && ((_a21 = googleOptions == null ? void 0 : googleOptions.structuredOutputs) != null ? _a21 : !0) ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0,
          ...(googleOptions == null ? void 0 : googleOptions.audioTimestamp) && {
            audioTimestamp: googleOptions.audioTimestamp
          },
          responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,
          thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig,
          ...(googleOptions == null ? void 0 : googleOptions.mediaResolution) && {
            mediaResolution: googleOptions.mediaResolution
          },
          ...(googleOptions == null ? void 0 : googleOptions.imageConfig) && {
            imageConfig: googleOptions.imageConfig
          }
        },
        contents,
        systemInstruction: isGemmaModel ? void 0 : systemInstruction,
        safetySettings: googleOptions == null ? void 0 : googleOptions.safetySettings,
        tools: googleTools2,
        toolConfig: (googleOptions == null ? void 0 : googleOptions.retrievalConfig) ? {
          ...googleToolConfig,
          retrievalConfig: googleOptions.retrievalConfig
        } : googleToolConfig,
        cachedContent: googleOptions == null ? void 0 : googleOptions.cachedContent,
        labels: googleOptions == null ? void 0 : googleOptions.labels
      },
      warnings: [...warnings, ...toolWarnings],
      providerOptionsName
    };
  }
  async doGenerate(options) {
    var _a21, _b16, _c, _d, _e, _f, _g, _h, _i;
    let { args, warnings, providerOptionsName } = await this.getArgs(options), mergedHeaders = combineHeaders(await resolve(this.config.headers), options.headers), {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: `${this.config.baseURL}/${getModelPath(this.modelId)}:generateContent`,
      headers: mergedHeaders,
      body: args,
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(responseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), candidate = response.candidates[0], content = [], parts = (_b16 = (_a21 = candidate.content) == null ? void 0 : _a21.parts) != null ? _b16 : [], usageMetadata = response.usageMetadata, lastCodeExecutionToolCallId;
    for (let part of parts)
      if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
        let toolCallId = this.config.generateId();
        lastCodeExecutionToolCallId = toolCallId, content.push({
          type: "tool-call",
          toolCallId,
          toolName: "code_execution",
          input: JSON.stringify(part.executableCode),
          providerExecuted: !0
        });
      } else if ("codeExecutionResult" in part && part.codeExecutionResult)
        content.push({
          type: "tool-result",
          toolCallId: lastCodeExecutionToolCallId,
          toolName: "code_execution",
          result: {
            outcome: part.codeExecutionResult.outcome,
            output: part.codeExecutionResult.output
          }
        }), lastCodeExecutionToolCallId = void 0;
      else if ("text" in part && part.text != null && part.text.length > 0)
        content.push({
          type: part.thought === !0 ? "reasoning" : "text",
          text: part.text,
          providerMetadata: part.thoughtSignature ? {
            [providerOptionsName]: {
              thoughtSignature: part.thoughtSignature
            }
          } : void 0
        });
      else if ("functionCall" in part)
        content.push({
          type: "tool-call",
          toolCallId: this.config.generateId(),
          toolName: part.functionCall.name,
          input: JSON.stringify(part.functionCall.args),
          providerMetadata: part.thoughtSignature ? {
            [providerOptionsName]: {
              thoughtSignature: part.thoughtSignature
            }
          } : void 0
        });
      else if ("inlineData" in part)
        content.push({
          type: "file",
          data: part.inlineData.data,
          mediaType: part.inlineData.mimeType,
          providerMetadata: part.thoughtSignature ? {
            [providerOptionsName]: {
              thoughtSignature: part.thoughtSignature
            }
          } : void 0
        });
    let sources = (_d = extractSources({
      groundingMetadata: candidate.groundingMetadata,
      generateId: this.config.generateId
    })) != null ? _d : [];
    for (let source of sources)
      content.push(source);
    return {
      content,
      finishReason: {
        unified: mapGoogleGenerativeAIFinishReason({
          finishReason: candidate.finishReason,
          hasToolCalls: content.some((part) => part.type === "tool-call" && !part.providerExecuted)
        }),
        raw: (_e = candidate.finishReason) != null ? _e : void 0
      },
      usage: convertGoogleGenerativeAIUsage(usageMetadata),
      warnings,
      providerMetadata: {
        [providerOptionsName]: {
          promptFeedback: (_f = response.promptFeedback) != null ? _f : null,
          groundingMetadata: (_g = candidate.groundingMetadata) != null ? _g : null,
          urlContextMetadata: (_h = candidate.urlContextMetadata) != null ? _h : null,
          safetyRatings: (_i = candidate.safetyRatings) != null ? _i : null,
          usageMetadata: usageMetadata != null ? usageMetadata : null
        }
      },
      request: { body: args },
      response: {
        headers: responseHeaders,
        body: rawResponse
      }
    };
  }
  async doStream(options) {
    let { args, warnings, providerOptionsName } = await this.getArgs(options), headers = combineHeaders(await resolve(this.config.headers), options.headers), { responseHeaders, value: response } = await postJsonToApi({
      url: `${this.config.baseURL}/${getModelPath(this.modelId)}:streamGenerateContent?alt=sse`,
      headers,
      body: args,
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(chunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), finishReason = {
      unified: "other",
      raw: void 0
    }, usage = void 0, providerMetadata = void 0, generateId3 = this.config.generateId, hasToolCalls = !1, currentTextBlockId = null, currentReasoningBlockId = null, blockCounter = 0, emittedSourceUrls = /* @__PURE__ */ new Set, lastCodeExecutionToolCallId;
    return {
      stream: response.pipeThrough(new TransformStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings });
        },
        transform(chunk, controller) {
          var _a21, _b16, _c, _d, _e, _f, _g;
          if (options.includeRawChunks)
            controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
          if (!chunk.success) {
            controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          let value = chunk.value, usageMetadata = value.usageMetadata;
          if (usageMetadata != null)
            usage = usageMetadata;
          let candidate = (_a21 = value.candidates) == null ? void 0 : _a21[0];
          if (candidate == null)
            return;
          let content = candidate.content, sources = extractSources({
            groundingMetadata: candidate.groundingMetadata,
            generateId: generateId3
          });
          if (sources != null) {
            for (let source of sources)
              if (source.sourceType === "url" && !emittedSourceUrls.has(source.url))
                emittedSourceUrls.add(source.url), controller.enqueue(source);
          }
          if (content != null) {
            let parts = (_b16 = content.parts) != null ? _b16 : [];
            for (let part of parts)
              if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
                let toolCallId = generateId3();
                lastCodeExecutionToolCallId = toolCallId, controller.enqueue({
                  type: "tool-call",
                  toolCallId,
                  toolName: "code_execution",
                  input: JSON.stringify(part.executableCode),
                  providerExecuted: !0
                });
              } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                let toolCallId = lastCodeExecutionToolCallId;
                if (toolCallId)
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId,
                    toolName: "code_execution",
                    result: {
                      outcome: part.codeExecutionResult.outcome,
                      output: part.codeExecutionResult.output
                    }
                  }), lastCodeExecutionToolCallId = void 0;
              } else if ("text" in part && part.text != null && part.text.length > 0)
                if (part.thought === !0) {
                  if (currentTextBlockId !== null)
                    controller.enqueue({
                      type: "text-end",
                      id: currentTextBlockId
                    }), currentTextBlockId = null;
                  if (currentReasoningBlockId === null)
                    currentReasoningBlockId = String(blockCounter++), controller.enqueue({
                      type: "reasoning-start",
                      id: currentReasoningBlockId,
                      providerMetadata: part.thoughtSignature ? {
                        [providerOptionsName]: {
                          thoughtSignature: part.thoughtSignature
                        }
                      } : void 0
                    });
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: currentReasoningBlockId,
                    delta: part.text,
                    providerMetadata: part.thoughtSignature ? {
                      [providerOptionsName]: {
                        thoughtSignature: part.thoughtSignature
                      }
                    } : void 0
                  });
                } else {
                  if (currentReasoningBlockId !== null)
                    controller.enqueue({
                      type: "reasoning-end",
                      id: currentReasoningBlockId
                    }), currentReasoningBlockId = null;
                  if (currentTextBlockId === null)
                    currentTextBlockId = String(blockCounter++), controller.enqueue({
                      type: "text-start",
                      id: currentTextBlockId,
                      providerMetadata: part.thoughtSignature ? {
                        [providerOptionsName]: {
                          thoughtSignature: part.thoughtSignature
                        }
                      } : void 0
                    });
                  controller.enqueue({
                    type: "text-delta",
                    id: currentTextBlockId,
                    delta: part.text,
                    providerMetadata: part.thoughtSignature ? {
                      [providerOptionsName]: {
                        thoughtSignature: part.thoughtSignature
                      }
                    } : void 0
                  });
                }
              else if ("inlineData" in part)
                controller.enqueue({
                  type: "file",
                  mediaType: part.inlineData.mimeType,
                  data: part.inlineData.data
                });
            let toolCallDeltas = getToolCallsFromParts({
              parts: content.parts,
              generateId: generateId3,
              providerOptionsName
            });
            if (toolCallDeltas != null)
              for (let toolCall of toolCallDeltas)
                controller.enqueue({
                  type: "tool-input-start",
                  id: toolCall.toolCallId,
                  toolName: toolCall.toolName,
                  providerMetadata: toolCall.providerMetadata
                }), controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.toolCallId,
                  delta: toolCall.args,
                  providerMetadata: toolCall.providerMetadata
                }), controller.enqueue({
                  type: "tool-input-end",
                  id: toolCall.toolCallId,
                  providerMetadata: toolCall.providerMetadata
                }), controller.enqueue({
                  type: "tool-call",
                  toolCallId: toolCall.toolCallId,
                  toolName: toolCall.toolName,
                  input: toolCall.args,
                  providerMetadata: toolCall.providerMetadata
                }), hasToolCalls = !0;
          }
          if (candidate.finishReason != null) {
            if (finishReason = {
              unified: mapGoogleGenerativeAIFinishReason({
                finishReason: candidate.finishReason,
                hasToolCalls
              }),
              raw: candidate.finishReason
            }, providerMetadata = {
              [providerOptionsName]: {
                promptFeedback: (_d = value.promptFeedback) != null ? _d : null,
                groundingMetadata: (_e = candidate.groundingMetadata) != null ? _e : null,
                urlContextMetadata: (_f = candidate.urlContextMetadata) != null ? _f : null,
                safetyRatings: (_g = candidate.safetyRatings) != null ? _g : null
              }
            }, usageMetadata != null)
              providerMetadata[providerOptionsName].usageMetadata = usageMetadata;
          }
        },
        flush(controller) {
          if (currentTextBlockId !== null)
            controller.enqueue({
              type: "text-end",
              id: currentTextBlockId
            });
          if (currentReasoningBlockId !== null)
            controller.enqueue({
              type: "reasoning-end",
              id: currentReasoningBlockId
            });
          controller.enqueue({
            type: "finish",
            finishReason,
            usage: convertGoogleGenerativeAIUsage(usage),
            providerMetadata
          });
        }
      })),
      response: { headers: responseHeaders },
      request: { body: args }
    };
  }
};
function getToolCallsFromParts({
  parts,
  generateId: generateId3,
  providerOptionsName
}) {
  let functionCallParts = parts == null ? void 0 : parts.filter((part) => ("functionCall" in part));
  return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part) => ({
    type: "tool-call",
    toolCallId: generateId3(),
    toolName: part.functionCall.name,
    args: JSON.stringify(part.functionCall.args),
    providerMetadata: part.thoughtSignature ? {
      [providerOptionsName]: {
        thoughtSignature: part.thoughtSignature
      }
    } : void 0
  }));
}
function extractSources({
  groundingMetadata,
  generateId: generateId3
}) {
  var _a21, _b16, _c, _d, _e;
  if (!(groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks))
    return;
  let sources = [];
  for (let chunk of groundingMetadata.groundingChunks)
    if (chunk.web != null)
      sources.push({
        type: "source",
        sourceType: "url",
        id: generateId3(),
        url: chunk.web.uri,
        title: (_a21 = chunk.web.title) != null ? _a21 : void 0
      });
    else if (chunk.retrievedContext != null) {
      let uri = chunk.retrievedContext.uri, fileSearchStore = chunk.retrievedContext.fileSearchStore;
      if (uri && (uri.startsWith("http://") || uri.startsWith("https://")))
        sources.push({
          type: "source",
          sourceType: "url",
          id: generateId3(),
          url: uri,
          title: (_b16 = chunk.retrievedContext.title) != null ? _b16 : void 0
        });
      else if (uri) {
        let title = (_c = chunk.retrievedContext.title) != null ? _c : "Unknown Document", mediaType = "application/octet-stream", filename = void 0;
        if (uri.endsWith(".pdf"))
          mediaType = "application/pdf", filename = uri.split("/").pop();
        else if (uri.endsWith(".txt"))
          mediaType = "text/plain", filename = uri.split("/").pop();
        else if (uri.endsWith(".docx"))
          mediaType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document", filename = uri.split("/").pop();
        else if (uri.endsWith(".doc"))
          mediaType = "application/msword", filename = uri.split("/").pop();
        else if (uri.match(/\.(md|markdown)$/))
          mediaType = "text/markdown", filename = uri.split("/").pop();
        else
          filename = uri.split("/").pop();
        sources.push({
          type: "source",
          sourceType: "document",
          id: generateId3(),
          mediaType,
          title,
          filename
        });
      } else if (fileSearchStore) {
        let title = (_d = chunk.retrievedContext.title) != null ? _d : "Unknown Document";
        sources.push({
          type: "source",
          sourceType: "document",
          id: generateId3(),
          mediaType: "application/octet-stream",
          title,
          filename: fileSearchStore.split("/").pop()
        });
      }
    } else if (chunk.maps != null) {
      if (chunk.maps.uri)
        sources.push({
          type: "source",
          sourceType: "url",
          id: generateId3(),
          url: chunk.maps.uri,
          title: (_e = chunk.maps.title) != null ? _e : void 0
        });
    }
  return sources.length > 0 ? sources : void 0;
}
var getGroundingMetadataSchema = () => exports_external.object({
  webSearchQueries: exports_external.array(exports_external.string()).nullish(),
  retrievalQueries: exports_external.array(exports_external.string()).nullish(),
  searchEntryPoint: exports_external.object({ renderedContent: exports_external.string() }).nullish(),
  groundingChunks: exports_external.array(exports_external.object({
    web: exports_external.object({ uri: exports_external.string(), title: exports_external.string().nullish() }).nullish(),
    retrievedContext: exports_external.object({
      uri: exports_external.string().nullish(),
      title: exports_external.string().nullish(),
      text: exports_external.string().nullish(),
      fileSearchStore: exports_external.string().nullish()
    }).nullish(),
    maps: exports_external.object({
      uri: exports_external.string().nullish(),
      title: exports_external.string().nullish(),
      text: exports_external.string().nullish(),
      placeId: exports_external.string().nullish()
    }).nullish()
  })).nullish(),
  groundingSupports: exports_external.array(exports_external.object({
    segment: exports_external.object({
      startIndex: exports_external.number().nullish(),
      endIndex: exports_external.number().nullish(),
      text: exports_external.string().nullish()
    }).nullish(),
    segment_text: exports_external.string().nullish(),
    groundingChunkIndices: exports_external.array(exports_external.number()).nullish(),
    supportChunkIndices: exports_external.array(exports_external.number()).nullish(),
    confidenceScores: exports_external.array(exports_external.number()).nullish(),
    confidenceScore: exports_external.array(exports_external.number()).nullish()
  })).nullish(),
  retrievalMetadata: exports_external.union([
    exports_external.object({
      webDynamicRetrievalScore: exports_external.number()
    }),
    exports_external.object({})
  ]).nullish()
}), getContentSchema = () => exports_external.object({
  parts: exports_external.array(exports_external.union([
    exports_external.object({
      functionCall: exports_external.object({
        name: exports_external.string(),
        args: exports_external.unknown()
      }),
      thoughtSignature: exports_external.string().nullish()
    }),
    exports_external.object({
      inlineData: exports_external.object({
        mimeType: exports_external.string(),
        data: exports_external.string()
      }),
      thoughtSignature: exports_external.string().nullish()
    }),
    exports_external.object({
      executableCode: exports_external.object({
        language: exports_external.string(),
        code: exports_external.string()
      }).nullish(),
      codeExecutionResult: exports_external.object({
        outcome: exports_external.string(),
        output: exports_external.string()
      }).nullish(),
      text: exports_external.string().nullish(),
      thought: exports_external.boolean().nullish(),
      thoughtSignature: exports_external.string().nullish()
    })
  ])).nullish()
}), getSafetyRatingSchema = () => exports_external.object({
  category: exports_external.string().nullish(),
  probability: exports_external.string().nullish(),
  probabilityScore: exports_external.number().nullish(),
  severity: exports_external.string().nullish(),
  severityScore: exports_external.number().nullish(),
  blocked: exports_external.boolean().nullish()
}), usageSchema = exports_external.object({
  cachedContentTokenCount: exports_external.number().nullish(),
  thoughtsTokenCount: exports_external.number().nullish(),
  promptTokenCount: exports_external.number().nullish(),
  candidatesTokenCount: exports_external.number().nullish(),
  totalTokenCount: exports_external.number().nullish(),
  trafficType: exports_external.string().nullish()
}), getUrlContextMetadataSchema = () => exports_external.object({
  urlMetadata: exports_external.array(exports_external.object({
    retrievedUrl: exports_external.string(),
    urlRetrievalStatus: exports_external.string()
  }))
}), responseSchema = lazySchema(() => zodSchema(exports_external.object({
  candidates: exports_external.array(exports_external.object({
    content: getContentSchema().nullish().or(exports_external.object({}).strict()),
    finishReason: exports_external.string().nullish(),
    safetyRatings: exports_external.array(getSafetyRatingSchema()).nullish(),
    groundingMetadata: getGroundingMetadataSchema().nullish(),
    urlContextMetadata: getUrlContextMetadataSchema().nullish()
  })),
  usageMetadata: usageSchema.nullish(),
  promptFeedback: exports_external.object({
    blockReason: exports_external.string().nullish(),
    safetyRatings: exports_external.array(getSafetyRatingSchema()).nullish()
  }).nullish()
}))), chunkSchema = lazySchema(() => zodSchema(exports_external.object({
  candidates: exports_external.array(exports_external.object({
    content: getContentSchema().nullish(),
    finishReason: exports_external.string().nullish(),
    safetyRatings: exports_external.array(getSafetyRatingSchema()).nullish(),
    groundingMetadata: getGroundingMetadataSchema().nullish(),
    urlContextMetadata: getUrlContextMetadataSchema().nullish()
  })).nullish(),
  usageMetadata: usageSchema.nullish(),
  promptFeedback: exports_external.object({
    blockReason: exports_external.string().nullish(),
    safetyRatings: exports_external.array(getSafetyRatingSchema()).nullish()
  }).nullish()
}))), codeExecution = createProviderToolFactoryWithOutputSchema({
  id: "google.code_execution",
  inputSchema: exports_external.object({
    language: exports_external.string().describe("The programming language of the code."),
    code: exports_external.string().describe("The code to be executed.")
  }),
  outputSchema: exports_external.object({
    outcome: exports_external.string().describe('The outcome of the execution (e.g., "OUTCOME_OK").'),
    output: exports_external.string().describe("The output from the code execution.")
  })
}), enterpriseWebSearch = createProviderToolFactory({
  id: "google.enterprise_web_search",
  inputSchema: lazySchema(() => zodSchema(exports_external.object({})))
}), fileSearchArgsBaseSchema = exports_external.object({
  fileSearchStoreNames: exports_external.array(exports_external.string()).describe("The names of the file_search_stores to retrieve from. Example: `fileSearchStores/my-file-search-store-123`"),
  topK: exports_external.number().int().positive().describe("The number of file search retrieval chunks to retrieve.").optional(),
  metadataFilter: exports_external.string().describe("Metadata filter to apply to the file search retrieval documents. See https://google.aip.dev/160 for the syntax of the filter expression.").optional()
}).passthrough(), fileSearchArgsSchema = lazySchema(() => zodSchema(fileSearchArgsBaseSchema)), fileSearch = createProviderToolFactory({
  id: "google.file_search",
  inputSchema: fileSearchArgsSchema
}), googleMaps = createProviderToolFactory({
  id: "google.google_maps",
  inputSchema: lazySchema(() => zodSchema(exports_external.object({})))
}), googleSearch = createProviderToolFactory({
  id: "google.google_search",
  inputSchema: lazySchema(() => zodSchema(exports_external.object({
    mode: exports_external.enum(["MODE_DYNAMIC", "MODE_UNSPECIFIED"]).default("MODE_UNSPECIFIED"),
    dynamicThreshold: exports_external.number().default(1)
  })))
}), urlContext = createProviderToolFactory({
  id: "google.url_context",
  inputSchema: lazySchema(() => zodSchema(exports_external.object({})))
}), vertexRagStore = createProviderToolFactory({
  id: "google.vertex_rag_store",
  inputSchema: exports_external.object({
    ragCorpus: exports_external.string(),
    topK: exports_external.number().optional()
  })
}), googleTools = {
  googleSearch,
  enterpriseWebSearch,
  googleMaps,
  urlContext,
  fileSearch,
  codeExecution,
  vertexRagStore
}, GoogleGenerativeAIImageModel = class {
  constructor(modelId, settings, config2) {
    this.modelId = modelId, this.settings = settings, this.config = config2, this.specificationVersion = "v3";
  }
  get maxImagesPerCall() {
    var _a21;
    return (_a21 = this.settings.maxImagesPerCall) != null ? _a21 : 4;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate(options) {
    var _a21, _b16, _c;
    let {
      prompt,
      n = 1,
      size,
      aspectRatio = "1:1",
      seed,
      providerOptions,
      headers,
      abortSignal,
      files,
      mask
    } = options, warnings = [];
    if (files != null && files.length > 0)
      throw Error("Google Generative AI does not support image editing. Use Google Vertex AI (@ai-sdk/google-vertex) for image editing capabilities.");
    if (mask != null)
      throw Error("Google Generative AI does not support image editing with masks. Use Google Vertex AI (@ai-sdk/google-vertex) for image editing capabilities.");
    if (size != null)
      warnings.push({
        type: "unsupported",
        feature: "size",
        details: "This model does not support the `size` option. Use `aspectRatio` instead."
      });
    if (seed != null)
      warnings.push({
        type: "unsupported",
        feature: "seed",
        details: "This model does not support the `seed` option through this provider."
      });
    let googleOptions = await parseProviderOptions({
      provider: "google",
      providerOptions,
      schema: googleImageProviderOptionsSchema
    }), currentDate = (_c = (_b16 = (_a21 = this.config._internal) == null ? void 0 : _a21.currentDate) == null ? void 0 : _b16.call(_a21)) != null ? _c : /* @__PURE__ */ new Date, parameters = {
      sampleCount: n
    };
    if (aspectRatio != null)
      parameters.aspectRatio = aspectRatio;
    if (googleOptions)
      Object.assign(parameters, googleOptions);
    let body = {
      instances: [{ prompt }],
      parameters
    }, { responseHeaders, value: response } = await postJsonToApi({
      url: `${this.config.baseURL}/models/${this.modelId}:predict`,
      headers: combineHeaders(await resolve(this.config.headers), headers),
      body,
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(googleImageResponseSchema),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.predictions.map((p) => p.bytesBase64Encoded),
      warnings: warnings != null ? warnings : [],
      providerMetadata: {
        google: {
          images: response.predictions.map((prediction) => ({}))
        }
      },
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      }
    };
  }
}, googleImageResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  predictions: exports_external.array(exports_external.object({ bytesBase64Encoded: exports_external.string() })).default([])
}))), googleImageProviderOptionsSchema = lazySchema(() => zodSchema(exports_external.object({
  personGeneration: exports_external.enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
  aspectRatio: exports_external.enum(["1:1", "3:4", "4:3", "9:16", "16:9"]).nullish()
}))), GoogleGenerativeAIVideoModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId, this.config = config2, this.specificationVersion = "v3";
  }
  get provider() {
    return this.config.provider;
  }
  get maxVideosPerCall() {
    return 4;
  }
  async doGenerate(options) {
    var _a21, _b16, _c, _d, _e, _f, _g, _h;
    let currentDate = (_c = (_b16 = (_a21 = this.config._internal) == null ? void 0 : _a21.currentDate) == null ? void 0 : _b16.call(_a21)) != null ? _c : /* @__PURE__ */ new Date, warnings = [], googleOptions = await parseProviderOptions({
      provider: "google",
      providerOptions: options.providerOptions,
      schema: googleVideoProviderOptionsSchema
    }), instances = [{}], instance = instances[0];
    if (options.prompt != null)
      instance.prompt = options.prompt;
    if (options.image != null)
      if (options.image.type === "url")
        warnings.push({
          type: "unsupported",
          feature: "URL-based image input",
          details: "Google Generative AI video models require base64-encoded images. URL will be ignored."
        });
      else {
        let base64Data = typeof options.image.data === "string" ? options.image.data : convertUint8ArrayToBase64(options.image.data);
        instance.image = {
          inlineData: {
            mimeType: options.image.mediaType || "image/png",
            data: base64Data
          }
        };
      }
    if ((googleOptions == null ? void 0 : googleOptions.referenceImages) != null)
      instance.referenceImages = googleOptions.referenceImages.map((refImg) => {
        if (refImg.bytesBase64Encoded)
          return {
            inlineData: {
              mimeType: "image/png",
              data: refImg.bytesBase64Encoded
            }
          };
        else if (refImg.gcsUri)
          return {
            gcsUri: refImg.gcsUri
          };
        return refImg;
      });
    let parameters = {
      sampleCount: options.n
    };
    if (options.aspectRatio)
      parameters.aspectRatio = options.aspectRatio;
    if (options.resolution) {
      let resolutionMap = {
        "1280x720": "720p",
        "1920x1080": "1080p",
        "3840x2160": "4k"
      };
      parameters.resolution = resolutionMap[options.resolution] || options.resolution;
    }
    if (options.duration)
      parameters.durationSeconds = options.duration;
    if (options.seed)
      parameters.seed = options.seed;
    if (googleOptions != null) {
      let opts = googleOptions;
      if (opts.personGeneration !== void 0 && opts.personGeneration !== null)
        parameters.personGeneration = opts.personGeneration;
      if (opts.negativePrompt !== void 0 && opts.negativePrompt !== null)
        parameters.negativePrompt = opts.negativePrompt;
      for (let [key, value] of Object.entries(opts))
        if (![
          "pollIntervalMs",
          "pollTimeoutMs",
          "personGeneration",
          "negativePrompt",
          "referenceImages"
        ].includes(key))
          parameters[key] = value;
    }
    let { value: operation } = await postJsonToApi({
      url: `${this.config.baseURL}/models/${this.modelId}:predictLongRunning`,
      headers: combineHeaders(await resolve(this.config.headers), options.headers),
      body: {
        instances,
        parameters
      },
      successfulResponseHandler: createJsonResponseHandler(googleOperationSchema),
      failedResponseHandler: googleFailedResponseHandler,
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), operationName = operation.name;
    if (!operationName)
      throw new AISDKError({
        name: "GOOGLE_VIDEO_GENERATION_ERROR",
        message: "No operation name returned from API"
      });
    let pollIntervalMs = (_d = googleOptions == null ? void 0 : googleOptions.pollIntervalMs) != null ? _d : 1e4, pollTimeoutMs = (_e = googleOptions == null ? void 0 : googleOptions.pollTimeoutMs) != null ? _e : 600000, startTime = Date.now(), finalOperation = operation, responseHeaders;
    while (!finalOperation.done) {
      if (Date.now() - startTime > pollTimeoutMs)
        throw new AISDKError({
          name: "GOOGLE_VIDEO_GENERATION_TIMEOUT",
          message: `Video generation timed out after ${pollTimeoutMs}ms`
        });
      if (await delay(pollIntervalMs), (_f = options.abortSignal) == null ? void 0 : _f.aborted)
        throw new AISDKError({
          name: "GOOGLE_VIDEO_GENERATION_ABORTED",
          message: "Video generation request was aborted"
        });
      let { value: statusOperation, responseHeaders: pollHeaders } = await getFromApi({
        url: `${this.config.baseURL}/${operationName}`,
        headers: combineHeaders(await resolve(this.config.headers), options.headers),
        successfulResponseHandler: createJsonResponseHandler(googleOperationSchema),
        failedResponseHandler: googleFailedResponseHandler,
        abortSignal: options.abortSignal,
        fetch: this.config.fetch
      });
      finalOperation = statusOperation, responseHeaders = pollHeaders;
    }
    if (finalOperation.error)
      throw new AISDKError({
        name: "GOOGLE_VIDEO_GENERATION_FAILED",
        message: `Video generation failed: ${finalOperation.error.message}`
      });
    let response = finalOperation.response;
    if (!((_g = response == null ? void 0 : response.generateVideoResponse) == null ? void 0 : _g.generatedSamples) || response.generateVideoResponse.generatedSamples.length === 0)
      throw new AISDKError({
        name: "GOOGLE_VIDEO_GENERATION_ERROR",
        message: `No videos in response. Response: ${JSON.stringify(finalOperation)}`
      });
    let videos = [], videoMetadata = [], resolvedHeaders = await resolve(this.config.headers), apiKey = resolvedHeaders == null ? void 0 : resolvedHeaders["x-goog-api-key"];
    for (let generatedSample of response.generateVideoResponse.generatedSamples)
      if ((_h = generatedSample.video) == null ? void 0 : _h.uri) {
        let urlWithAuth = apiKey ? `${generatedSample.video.uri}${generatedSample.video.uri.includes("?") ? "&" : "?"}key=${apiKey}` : generatedSample.video.uri;
        videos.push({
          type: "url",
          url: urlWithAuth,
          mediaType: "video/mp4"
        }), videoMetadata.push({
          uri: generatedSample.video.uri
        });
      }
    if (videos.length === 0)
      throw new AISDKError({
        name: "GOOGLE_VIDEO_GENERATION_ERROR",
        message: "No valid videos in response"
      });
    return {
      videos,
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      },
      providerMetadata: {
        google: {
          videos: videoMetadata
        }
      }
    };
  }
}, googleOperationSchema = exports_external.object({
  name: exports_external.string().nullish(),
  done: exports_external.boolean().nullish(),
  error: exports_external.object({
    code: exports_external.number().nullish(),
    message: exports_external.string(),
    status: exports_external.string().nullish()
  }).nullish(),
  response: exports_external.object({
    generateVideoResponse: exports_external.object({
      generatedSamples: exports_external.array(exports_external.object({
        video: exports_external.object({
          uri: exports_external.string().nullish()
        }).nullish()
      })).nullish()
    }).nullish()
  }).nullish()
}), googleVideoProviderOptionsSchema = lazySchema(() => zodSchema(exports_external.object({
  pollIntervalMs: exports_external.number().positive().nullish(),
  pollTimeoutMs: exports_external.number().positive().nullish(),
  personGeneration: exports_external.enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
  negativePrompt: exports_external.string().nullish(),
  referenceImages: exports_external.array(exports_external.object({
    bytesBase64Encoded: exports_external.string().nullish(),
    gcsUri: exports_external.string().nullish()
  })).nullish()
}).passthrough()));
function createGoogleGenerativeAI(options = {}) {
  var _a21, _b16;
  let baseURL = (_a21 = withoutTrailingSlash(options.baseURL)) != null ? _a21 : "https://generativelanguage.googleapis.com/v1beta", providerName = (_b16 = options.name) != null ? _b16 : "google.generative-ai", getHeaders = () => withUserAgentSuffix({
    "x-goog-api-key": loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
      description: "Google Generative AI"
    }),
    ...options.headers
  }, `ai-sdk/google/${VERSION6}`), createChatModel = (modelId) => {
    var _a24;
    return new GoogleGenerativeAILanguageModel(modelId, {
      provider: providerName,
      baseURL,
      headers: getHeaders,
      generateId: (_a24 = options.generateId) != null ? _a24 : generateId,
      supportedUrls: () => ({
        "*": [
          new RegExp(`^${baseURL}/files/.*$`),
          new RegExp("^https://(?:www\\.)?youtube\\.com/watch\\?v=[\\w-]+(?:&[\\w=&.-]*)?$"),
          new RegExp("^https://youtu\\.be/[\\w-]+(?:\\?[\\w=&.-]*)?$")
        ]
      }),
      fetch: options.fetch
    });
  }, createEmbeddingModel = (modelId) => new GoogleGenerativeAIEmbeddingModel(modelId, {
    provider: providerName,
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  }), createImageModel = (modelId, settings = {}) => new GoogleGenerativeAIImageModel(modelId, settings, {
    provider: providerName,
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  }), createVideoModel = (modelId) => {
    var _a24;
    return new GoogleGenerativeAIVideoModel(modelId, {
      provider: providerName,
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: (_a24 = options.generateId) != null ? _a24 : generateId
    });
  }, provider = function(modelId) {
    if (new.target)
      throw Error("The Google Generative AI model function cannot be called with the new keyword.");
    return createChatModel(modelId);
  };
  return provider.specificationVersion = "v3", provider.languageModel = createChatModel, provider.chat = createChatModel, provider.generativeAI = createChatModel, provider.embedding = createEmbeddingModel, provider.embeddingModel = createEmbeddingModel, provider.textEmbedding = createEmbeddingModel, provider.textEmbeddingModel = createEmbeddingModel, provider.image = createImageModel, provider.imageModel = createImageModel, provider.video = createVideoModel, provider.tools = googleTools, provider;
}
var google = createGoogleGenerativeAI();
// node_modules/@ai-sdk/openai/dist/index.mjs
var openaiErrorDataSchema = exports_external.object({
  error: exports_external.object({
    message: exports_external.string(),
    type: exports_external.string().nullish(),
    param: exports_external.any().nullish(),
    code: exports_external.union([exports_external.string(), exports_external.number()]).nullish()
  })
}), openaiFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: openaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
function getOpenAILanguageModelCapabilities(modelId) {
  let supportsFlexProcessing = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat"), supportsPriorityProcessing = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini"), isReasoningModel = modelId.startsWith("o1") || modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("codex-mini") || modelId.startsWith("computer-use-preview") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat"), supportsNonReasoningParameters = modelId.startsWith("gpt-5.1") || modelId.startsWith("gpt-5.2");
  return {
    supportsFlexProcessing,
    supportsPriorityProcessing,
    isReasoningModel,
    systemMessageMode: isReasoningModel ? "developer" : "system",
    supportsNonReasoningParameters
  };
}
function convertOpenAIChatUsage(usage) {
  var _a21, _b16, _c, _d, _e, _f;
  if (usage == null)
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  let promptTokens = (_a21 = usage.prompt_tokens) != null ? _a21 : 0, completionTokens = (_b16 = usage.completion_tokens) != null ? _b16 : 0, cachedTokens = (_d = (_c = usage.prompt_tokens_details) == null ? void 0 : _c.cached_tokens) != null ? _d : 0, reasoningTokens = (_f = (_e = usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens - cachedTokens,
      cacheRead: cachedTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: completionTokens,
      text: completionTokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function convertToOpenAIChatMessages({
  prompt,
  systemMessageMode = "system"
}) {
  var _a21;
  let messages = [], warnings = [];
  for (let { role, content } of prompt)
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default:
            throw Error(`Unsupported system message mode: ${systemMessageMode}`);
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a24, _b16, _c;
            switch (part.type) {
              case "text":
                return { type: "text", text: part.text };
              case "file":
                if (part.mediaType.startsWith("image/")) {
                  let mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,
                      detail: (_b16 = (_a24 = part.providerOptions) == null ? void 0 : _a24.openai) == null ? void 0 : _b16.imageDetail
                    }
                  };
                } else if (part.mediaType.startsWith("audio/")) {
                  if (part.data instanceof URL)
                    throw new UnsupportedFunctionalityError({
                      functionality: "audio file parts with URLs"
                    });
                  switch (part.mediaType) {
                    case "audio/wav":
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "wav"
                        }
                      };
                    case "audio/mp3":
                    case "audio/mpeg":
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "mp3"
                        }
                      };
                    default:
                      throw new UnsupportedFunctionalityError({
                        functionality: `audio content parts with media type ${part.mediaType}`
                      });
                  }
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL)
                    throw new UnsupportedFunctionalityError({
                      functionality: "PDF file parts with URLs"
                    });
                  return {
                    type: "file",
                    file: typeof part.data === "string" && part.data.startsWith("file-") ? { file_id: part.data } : {
                      filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    }
                  };
                } else
                  throw new UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
            }
          })
        });
        break;
      }
      case "assistant": {
        let text2 = "", toolCalls = [];
        for (let part of content)
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        messages.push({
          role: "assistant",
          content: text2,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (let toolResponse of content) {
          if (toolResponse.type === "tool-approval-response")
            continue;
          let output = toolResponse.output, contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_a21 = output.reason) != null ? _a21 : "Tool execution denied.";
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  return { messages, warnings };
}
function getResponseMetadata2({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created ? new Date(created * 1000) : void 0
  };
}
function mapOpenAIFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
var openaiChatResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  id: exports_external.string().nullish(),
  created: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  choices: exports_external.array(exports_external.object({
    message: exports_external.object({
      role: exports_external.literal("assistant").nullish(),
      content: exports_external.string().nullish(),
      tool_calls: exports_external.array(exports_external.object({
        id: exports_external.string().nullish(),
        type: exports_external.literal("function"),
        function: exports_external.object({
          name: exports_external.string(),
          arguments: exports_external.string()
        })
      })).nullish(),
      annotations: exports_external.array(exports_external.object({
        type: exports_external.literal("url_citation"),
        url_citation: exports_external.object({
          start_index: exports_external.number(),
          end_index: exports_external.number(),
          url: exports_external.string(),
          title: exports_external.string()
        })
      })).nullish()
    }),
    index: exports_external.number(),
    logprobs: exports_external.object({
      content: exports_external.array(exports_external.object({
        token: exports_external.string(),
        logprob: exports_external.number(),
        top_logprobs: exports_external.array(exports_external.object({
          token: exports_external.string(),
          logprob: exports_external.number()
        }))
      })).nullish()
    }).nullish(),
    finish_reason: exports_external.string().nullish()
  })),
  usage: exports_external.object({
    prompt_tokens: exports_external.number().nullish(),
    completion_tokens: exports_external.number().nullish(),
    total_tokens: exports_external.number().nullish(),
    prompt_tokens_details: exports_external.object({
      cached_tokens: exports_external.number().nullish()
    }).nullish(),
    completion_tokens_details: exports_external.object({
      reasoning_tokens: exports_external.number().nullish(),
      accepted_prediction_tokens: exports_external.number().nullish(),
      rejected_prediction_tokens: exports_external.number().nullish()
    }).nullish()
  }).nullish()
}))), openaiChatChunkSchema = lazySchema(() => zodSchema(exports_external.union([
  exports_external.object({
    id: exports_external.string().nullish(),
    created: exports_external.number().nullish(),
    model: exports_external.string().nullish(),
    choices: exports_external.array(exports_external.object({
      delta: exports_external.object({
        role: exports_external.enum(["assistant"]).nullish(),
        content: exports_external.string().nullish(),
        tool_calls: exports_external.array(exports_external.object({
          index: exports_external.number(),
          id: exports_external.string().nullish(),
          type: exports_external.literal("function").nullish(),
          function: exports_external.object({
            name: exports_external.string().nullish(),
            arguments: exports_external.string().nullish()
          })
        })).nullish(),
        annotations: exports_external.array(exports_external.object({
          type: exports_external.literal("url_citation"),
          url_citation: exports_external.object({
            start_index: exports_external.number(),
            end_index: exports_external.number(),
            url: exports_external.string(),
            title: exports_external.string()
          })
        })).nullish()
      }).nullish(),
      logprobs: exports_external.object({
        content: exports_external.array(exports_external.object({
          token: exports_external.string(),
          logprob: exports_external.number(),
          top_logprobs: exports_external.array(exports_external.object({
            token: exports_external.string(),
            logprob: exports_external.number()
          }))
        })).nullish()
      }).nullish(),
      finish_reason: exports_external.string().nullish(),
      index: exports_external.number()
    })),
    usage: exports_external.object({
      prompt_tokens: exports_external.number().nullish(),
      completion_tokens: exports_external.number().nullish(),
      total_tokens: exports_external.number().nullish(),
      prompt_tokens_details: exports_external.object({
        cached_tokens: exports_external.number().nullish()
      }).nullish(),
      completion_tokens_details: exports_external.object({
        reasoning_tokens: exports_external.number().nullish(),
        accepted_prediction_tokens: exports_external.number().nullish(),
        rejected_prediction_tokens: exports_external.number().nullish()
      }).nullish()
    }).nullish()
  }),
  openaiErrorDataSchema
]))), openaiChatLanguageModelOptions = lazySchema(() => zodSchema(exports_external.object({
  logitBias: exports_external.record(exports_external.coerce.number(), exports_external.number()).optional(),
  logprobs: exports_external.union([exports_external.boolean(), exports_external.number()]).optional(),
  parallelToolCalls: exports_external.boolean().optional(),
  user: exports_external.string().optional(),
  reasoningEffort: exports_external.enum(["none", "minimal", "low", "medium", "high", "xhigh"]).optional(),
  maxCompletionTokens: exports_external.number().optional(),
  store: exports_external.boolean().optional(),
  metadata: exports_external.record(exports_external.string().max(64), exports_external.string().max(512)).optional(),
  prediction: exports_external.record(exports_external.string(), exports_external.any()).optional(),
  serviceTier: exports_external.enum(["auto", "flex", "priority", "default"]).optional(),
  strictJsonSchema: exports_external.boolean().optional(),
  textVerbosity: exports_external.enum(["low", "medium", "high"]).optional(),
  promptCacheKey: exports_external.string().optional(),
  promptCacheRetention: exports_external.enum(["in_memory", "24h"]).optional(),
  safetyIdentifier: exports_external.string().optional(),
  systemMessageMode: exports_external.enum(["system", "developer", "remove"]).optional(),
  forceReasoning: exports_external.boolean().optional()
})));
function prepareChatTools({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  let toolWarnings = [];
  if (tools == null)
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  let openaiTools2 = [];
  for (let tool2 of tools)
    switch (tool2.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          function: {
            name: tool2.name,
            description: tool2.description,
            parameters: tool2.inputSchema,
            ...tool2.strict != null ? { strict: tool2.strict } : {}
          }
        });
        break;
      default:
        toolWarnings.push({
          type: "unsupported",
          feature: `tool type: ${tool2.type}`
        });
        break;
    }
  if (toolChoice == null)
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  let type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: {
          type: "function",
          function: {
            name: toolChoice.toolName
          }
        },
        toolWarnings
      };
    default:
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${type}`
      });
  }
}
var OpenAIChatLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    }, this.modelId = modelId, this.config = config2;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    tools,
    toolChoice,
    providerOptions
  }) {
    var _a21, _b16, _c, _d, _e;
    let warnings = [], openaiOptions = (_a21 = await parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openaiChatLanguageModelOptions
    })) != null ? _a21 : {}, modelCapabilities = getOpenAILanguageModelCapabilities(this.modelId), isReasoningModel = (_b16 = openaiOptions.forceReasoning) != null ? _b16 : modelCapabilities.isReasoningModel;
    if (topK != null)
      warnings.push({ type: "unsupported", feature: "topK" });
    let { messages, warnings: messageWarnings } = convertToOpenAIChatMessages({
      prompt,
      systemMessageMode: (_c = openaiOptions.systemMessageMode) != null ? _c : isReasoningModel ? "developer" : modelCapabilities.systemMessageMode
    });
    warnings.push(...messageWarnings);
    let strictJsonSchema = (_d = openaiOptions.strictJsonSchema) != null ? _d : !0, baseArgs = {
      model: this.modelId,
      logit_bias: openaiOptions.logitBias,
      logprobs: openaiOptions.logprobs === !0 || typeof openaiOptions.logprobs === "number" ? !0 : void 0,
      top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
      user: openaiOptions.user,
      parallel_tool_calls: openaiOptions.parallelToolCalls,
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
        type: "json_schema",
        json_schema: {
          schema: responseFormat.schema,
          strict: strictJsonSchema,
          name: (_e = responseFormat.name) != null ? _e : "response",
          description: responseFormat.description
        }
      } : { type: "json_object" } : void 0,
      stop: stopSequences,
      seed,
      verbosity: openaiOptions.textVerbosity,
      max_completion_tokens: openaiOptions.maxCompletionTokens,
      store: openaiOptions.store,
      metadata: openaiOptions.metadata,
      prediction: openaiOptions.prediction,
      reasoning_effort: openaiOptions.reasoningEffort,
      service_tier: openaiOptions.serviceTier,
      prompt_cache_key: openaiOptions.promptCacheKey,
      prompt_cache_retention: openaiOptions.promptCacheRetention,
      safety_identifier: openaiOptions.safetyIdentifier,
      messages
    };
    if (isReasoningModel) {
      if (openaiOptions.reasoningEffort !== "none" || !modelCapabilities.supportsNonReasoningParameters) {
        if (baseArgs.temperature != null)
          baseArgs.temperature = void 0, warnings.push({
            type: "unsupported",
            feature: "temperature",
            details: "temperature is not supported for reasoning models"
          });
        if (baseArgs.top_p != null)
          baseArgs.top_p = void 0, warnings.push({
            type: "unsupported",
            feature: "topP",
            details: "topP is not supported for reasoning models"
          });
        if (baseArgs.logprobs != null)
          baseArgs.logprobs = void 0, warnings.push({
            type: "other",
            message: "logprobs is not supported for reasoning models"
          });
      }
      if (baseArgs.frequency_penalty != null)
        baseArgs.frequency_penalty = void 0, warnings.push({
          type: "unsupported",
          feature: "frequencyPenalty",
          details: "frequencyPenalty is not supported for reasoning models"
        });
      if (baseArgs.presence_penalty != null)
        baseArgs.presence_penalty = void 0, warnings.push({
          type: "unsupported",
          feature: "presencePenalty",
          details: "presencePenalty is not supported for reasoning models"
        });
      if (baseArgs.logit_bias != null)
        baseArgs.logit_bias = void 0, warnings.push({
          type: "other",
          message: "logitBias is not supported for reasoning models"
        });
      if (baseArgs.top_logprobs != null)
        baseArgs.top_logprobs = void 0, warnings.push({
          type: "other",
          message: "topLogprobs is not supported for reasoning models"
        });
      if (baseArgs.max_tokens != null) {
        if (baseArgs.max_completion_tokens == null)
          baseArgs.max_completion_tokens = baseArgs.max_tokens;
        baseArgs.max_tokens = void 0;
      }
    } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
      if (baseArgs.temperature != null)
        baseArgs.temperature = void 0, warnings.push({
          type: "unsupported",
          feature: "temperature",
          details: "temperature is not supported for the search preview models and has been removed."
        });
    }
    if (openaiOptions.serviceTier === "flex" && !modelCapabilities.supportsFlexProcessing)
      warnings.push({
        type: "unsupported",
        feature: "serviceTier",
        details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
      }), baseArgs.service_tier = void 0;
    if (openaiOptions.serviceTier === "priority" && !modelCapabilities.supportsPriorityProcessing)
      warnings.push({
        type: "unsupported",
        feature: "serviceTier",
        details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
      }), baseArgs.service_tier = void 0;
    let {
      tools: openaiTools2,
      toolChoice: openaiToolChoice,
      toolWarnings
    } = prepareChatTools({
      tools,
      toolChoice
    });
    return {
      args: {
        ...baseArgs,
        tools: openaiTools2,
        tool_choice: openaiToolChoice
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  async doGenerate(options) {
    var _a21, _b16, _c, _d, _e, _f, _g;
    let { args: body, warnings } = await this.getArgs(options), {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(openaiChatResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), choice2 = response.choices[0], content = [], text2 = choice2.message.content;
    if (text2 != null && text2.length > 0)
      content.push({ type: "text", text: text2 });
    for (let toolCall of (_a21 = choice2.message.tool_calls) != null ? _a21 : [])
      content.push({
        type: "tool-call",
        toolCallId: (_b16 = toolCall.id) != null ? _b16 : generateId(),
        toolName: toolCall.function.name,
        input: toolCall.function.arguments
      });
    for (let annotation of (_c = choice2.message.annotations) != null ? _c : [])
      content.push({
        type: "source",
        sourceType: "url",
        id: generateId(),
        url: annotation.url_citation.url,
        title: annotation.url_citation.title
      });
    let completionTokenDetails = (_d = response.usage) == null ? void 0 : _d.completion_tokens_details, promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details, providerMetadata = { openai: {} };
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null)
      providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null)
      providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
    if (((_f = choice2.logprobs) == null ? void 0 : _f.content) != null)
      providerMetadata.openai.logprobs = choice2.logprobs.content;
    return {
      content,
      finishReason: {
        unified: mapOpenAIFinishReason(choice2.finish_reason),
        raw: (_g = choice2.finish_reason) != null ? _g : void 0
      },
      usage: convertOpenAIChatUsage(response.usage),
      request: { body },
      response: {
        ...getResponseMetadata2(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings,
      providerMetadata
    };
  }
  async doStream(options) {
    let { args, warnings } = await this.getArgs(options), body = {
      ...args,
      stream: !0,
      stream_options: {
        include_usage: !0
      }
    }, { responseHeaders, value: response } = await postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(openaiChatChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), toolCalls = [], finishReason = {
      unified: "other",
      raw: void 0
    }, usage = void 0, metadataExtracted = !1, isActiveText = !1, providerMetadata = { openai: {} };
    return {
      stream: response.pipeThrough(new TransformStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings });
        },
        transform(chunk, controller) {
          var _a21, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
          if (options.includeRawChunks)
            controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
          if (!chunk.success) {
            finishReason = { unified: "error", raw: void 0 }, controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          let value = chunk.value;
          if ("error" in value) {
            finishReason = { unified: "error", raw: void 0 }, controller.enqueue({ type: "error", error: value.error });
            return;
          }
          if (!metadataExtracted) {
            let metadata = getResponseMetadata2(value);
            if (Object.values(metadata).some(Boolean))
              metadataExtracted = !0, controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata2(value)
              });
          }
          if (value.usage != null) {
            if (usage = value.usage, ((_a21 = value.usage.completion_tokens_details) == null ? void 0 : _a21.accepted_prediction_tokens) != null)
              providerMetadata.openai.acceptedPredictionTokens = (_b16 = value.usage.completion_tokens_details) == null ? void 0 : _b16.accepted_prediction_tokens;
            if (((_c = value.usage.completion_tokens_details) == null ? void 0 : _c.rejected_prediction_tokens) != null)
              providerMetadata.openai.rejectedPredictionTokens = (_d = value.usage.completion_tokens_details) == null ? void 0 : _d.rejected_prediction_tokens;
          }
          let choice2 = value.choices[0];
          if ((choice2 == null ? void 0 : choice2.finish_reason) != null)
            finishReason = {
              unified: mapOpenAIFinishReason(choice2.finish_reason),
              raw: choice2.finish_reason
            };
          if (((_e = choice2 == null ? void 0 : choice2.logprobs) == null ? void 0 : _e.content) != null)
            providerMetadata.openai.logprobs = choice2.logprobs.content;
          if ((choice2 == null ? void 0 : choice2.delta) == null)
            return;
          let delta = choice2.delta;
          if (delta.content != null) {
            if (!isActiveText)
              controller.enqueue({ type: "text-start", id: "0" }), isActiveText = !0;
            controller.enqueue({
              type: "text-delta",
              id: "0",
              delta: delta.content
            });
          }
          if (delta.tool_calls != null)
            for (let toolCallDelta of delta.tool_calls) {
              let index = toolCallDelta.index;
              if (toolCalls[index] == null) {
                if (toolCallDelta.type !== "function")
                  throw new InvalidResponseDataError({
                    data: toolCallDelta,
                    message: "Expected 'function' type."
                  });
                if (toolCallDelta.id == null)
                  throw new InvalidResponseDataError({
                    data: toolCallDelta,
                    message: "Expected 'id' to be a string."
                  });
                if (((_f = toolCallDelta.function) == null ? void 0 : _f.name) == null)
                  throw new InvalidResponseDataError({
                    data: toolCallDelta,
                    message: "Expected 'function.name' to be a string."
                  });
                controller.enqueue({
                  type: "tool-input-start",
                  id: toolCallDelta.id,
                  toolName: toolCallDelta.function.name
                }), toolCalls[index] = {
                  id: toolCallDelta.id,
                  type: "function",
                  function: {
                    name: toolCallDelta.function.name,
                    arguments: (_g = toolCallDelta.function.arguments) != null ? _g : ""
                  },
                  hasFinished: !1
                };
                let toolCall2 = toolCalls[index];
                if (((_h = toolCall2.function) == null ? void 0 : _h.name) != null && ((_i = toolCall2.function) == null ? void 0 : _i.arguments) != null) {
                  if (toolCall2.function.arguments.length > 0)
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall2.id,
                      delta: toolCall2.function.arguments
                    });
                  if (isParsableJson(toolCall2.function.arguments))
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall2.id
                    }), controller.enqueue({
                      type: "tool-call",
                      toolCallId: (_j = toolCall2.id) != null ? _j : generateId(),
                      toolName: toolCall2.function.name,
                      input: toolCall2.function.arguments
                    }), toolCall2.hasFinished = !0;
                }
                continue;
              }
              let toolCall = toolCalls[index];
              if (toolCall.hasFinished)
                continue;
              if (((_k = toolCallDelta.function) == null ? void 0 : _k.arguments) != null)
                toolCall.function.arguments += (_m = (_l = toolCallDelta.function) == null ? void 0 : _l.arguments) != null ? _m : "";
              if (controller.enqueue({
                type: "tool-input-delta",
                id: toolCall.id,
                delta: (_n = toolCallDelta.function.arguments) != null ? _n : ""
              }), ((_o = toolCall.function) == null ? void 0 : _o.name) != null && ((_p = toolCall.function) == null ? void 0 : _p.arguments) != null && isParsableJson(toolCall.function.arguments))
                controller.enqueue({
                  type: "tool-input-end",
                  id: toolCall.id
                }), controller.enqueue({
                  type: "tool-call",
                  toolCallId: (_q = toolCall.id) != null ? _q : generateId(),
                  toolName: toolCall.function.name,
                  input: toolCall.function.arguments
                }), toolCall.hasFinished = !0;
            }
          if (delta.annotations != null)
            for (let annotation of delta.annotations)
              controller.enqueue({
                type: "source",
                sourceType: "url",
                id: generateId(),
                url: annotation.url_citation.url,
                title: annotation.url_citation.title
              });
        },
        flush(controller) {
          if (isActiveText)
            controller.enqueue({ type: "text-end", id: "0" });
          controller.enqueue({
            type: "finish",
            finishReason,
            usage: convertOpenAIChatUsage(usage),
            ...providerMetadata != null ? { providerMetadata } : {}
          });
        }
      })),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function convertOpenAICompletionUsage(usage) {
  var _a21, _b16, _c, _d;
  if (usage == null)
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  let promptTokens = (_a21 = usage.prompt_tokens) != null ? _a21 : 0, completionTokens = (_b16 = usage.completion_tokens) != null ? _b16 : 0;
  return {
    inputTokens: {
      total: (_c = usage.prompt_tokens) != null ? _c : void 0,
      noCache: promptTokens,
      cacheRead: void 0,
      cacheWrite: void 0
    },
    outputTokens: {
      total: (_d = usage.completion_tokens) != null ? _d : void 0,
      text: completionTokens,
      reasoning: void 0
    },
    raw: usage
  };
}
function convertToOpenAICompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text2 = "";
  if (prompt[0].role === "system")
    text2 += `${prompt[0].content}

`, prompt = prompt.slice(1);
  for (let { role, content } of prompt)
    switch (role) {
      case "system":
        throw new InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      case "user": {
        let userMessage = content.map((part) => {
          switch (part.type) {
            case "text":
              return part.text;
          }
        }).filter(Boolean).join("");
        text2 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        let assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text":
              return part.text;
            case "tool-call":
              throw new UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
          }
        }).join("");
        text2 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool":
        throw new UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  return text2 += `${assistant}:
`, {
    prompt: text2,
    stopSequences: [`
${user}:`]
  };
}
function getResponseMetadata22({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1000) : void 0
  };
}
function mapOpenAIFinishReason2(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
var openaiCompletionResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  id: exports_external.string().nullish(),
  created: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  choices: exports_external.array(exports_external.object({
    text: exports_external.string(),
    finish_reason: exports_external.string(),
    logprobs: exports_external.object({
      tokens: exports_external.array(exports_external.string()),
      token_logprobs: exports_external.array(exports_external.number()),
      top_logprobs: exports_external.array(exports_external.record(exports_external.string(), exports_external.number())).nullish()
    }).nullish()
  })),
  usage: exports_external.object({
    prompt_tokens: exports_external.number(),
    completion_tokens: exports_external.number(),
    total_tokens: exports_external.number()
  }).nullish()
}))), openaiCompletionChunkSchema = lazySchema(() => zodSchema(exports_external.union([
  exports_external.object({
    id: exports_external.string().nullish(),
    created: exports_external.number().nullish(),
    model: exports_external.string().nullish(),
    choices: exports_external.array(exports_external.object({
      text: exports_external.string(),
      finish_reason: exports_external.string().nullish(),
      index: exports_external.number(),
      logprobs: exports_external.object({
        tokens: exports_external.array(exports_external.string()),
        token_logprobs: exports_external.array(exports_external.number()),
        top_logprobs: exports_external.array(exports_external.record(exports_external.string(), exports_external.number())).nullish()
      }).nullish()
    })),
    usage: exports_external.object({
      prompt_tokens: exports_external.number(),
      completion_tokens: exports_external.number(),
      total_tokens: exports_external.number()
    }).nullish()
  }),
  openaiErrorDataSchema
]))), openaiCompletionProviderOptions = lazySchema(() => zodSchema(exports_external.object({
  echo: exports_external.boolean().optional(),
  logitBias: exports_external.record(exports_external.string(), exports_external.number()).optional(),
  suffix: exports_external.string().optional(),
  user: exports_external.string().optional(),
  logprobs: exports_external.union([exports_external.boolean(), exports_external.number()]).optional()
}))), OpenAICompletionLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.supportedUrls = {}, this.modelId = modelId, this.config = config2;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences: userStopSequences,
    responseFormat,
    tools,
    toolChoice,
    seed,
    providerOptions
  }) {
    let warnings = [], openaiOptions = {
      ...await parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiCompletionProviderOptions
      }),
      ...await parseProviderOptions({
        provider: this.providerOptionsName,
        providerOptions,
        schema: openaiCompletionProviderOptions
      })
    };
    if (topK != null)
      warnings.push({ type: "unsupported", feature: "topK" });
    if (tools == null ? void 0 : tools.length)
      warnings.push({ type: "unsupported", feature: "tools" });
    if (toolChoice != null)
      warnings.push({ type: "unsupported", feature: "toolChoice" });
    if (responseFormat != null && responseFormat.type !== "text")
      warnings.push({
        type: "unsupported",
        feature: "responseFormat",
        details: "JSON response format is not supported."
      });
    let { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt }), stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
    return {
      args: {
        model: this.modelId,
        echo: openaiOptions.echo,
        logit_bias: openaiOptions.logitBias,
        logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === !0 ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === !1 ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
        suffix: openaiOptions.suffix,
        user: openaiOptions.user,
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        seed,
        prompt: completionPrompt,
        stop: stop.length > 0 ? stop : void 0
      },
      warnings
    };
  }
  async doGenerate(options) {
    var _a21;
    let { args, warnings } = await this.getArgs(options), {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(openaiCompletionResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), choice2 = response.choices[0], providerMetadata = { openai: {} };
    if (choice2.logprobs != null)
      providerMetadata.openai.logprobs = choice2.logprobs;
    return {
      content: [{ type: "text", text: choice2.text }],
      usage: convertOpenAICompletionUsage(response.usage),
      finishReason: {
        unified: mapOpenAIFinishReason2(choice2.finish_reason),
        raw: (_a21 = choice2.finish_reason) != null ? _a21 : void 0
      },
      request: { body: args },
      response: {
        ...getResponseMetadata22(response),
        headers: responseHeaders,
        body: rawResponse
      },
      providerMetadata,
      warnings
    };
  }
  async doStream(options) {
    let { args, warnings } = await this.getArgs(options), body = {
      ...args,
      stream: !0,
      stream_options: {
        include_usage: !0
      }
    }, { responseHeaders, value: response } = await postJsonToApi({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(openaiCompletionChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), finishReason = {
      unified: "other",
      raw: void 0
    }, providerMetadata = { openai: {} }, usage = void 0, isFirstChunk = !0;
    return {
      stream: response.pipeThrough(new TransformStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings });
        },
        transform(chunk, controller) {
          if (options.includeRawChunks)
            controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
          if (!chunk.success) {
            finishReason = { unified: "error", raw: void 0 }, controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          let value = chunk.value;
          if ("error" in value) {
            finishReason = { unified: "error", raw: void 0 }, controller.enqueue({ type: "error", error: value.error });
            return;
          }
          if (isFirstChunk)
            isFirstChunk = !1, controller.enqueue({
              type: "response-metadata",
              ...getResponseMetadata22(value)
            }), controller.enqueue({ type: "text-start", id: "0" });
          if (value.usage != null)
            usage = value.usage;
          let choice2 = value.choices[0];
          if ((choice2 == null ? void 0 : choice2.finish_reason) != null)
            finishReason = {
              unified: mapOpenAIFinishReason2(choice2.finish_reason),
              raw: choice2.finish_reason
            };
          if ((choice2 == null ? void 0 : choice2.logprobs) != null)
            providerMetadata.openai.logprobs = choice2.logprobs;
          if ((choice2 == null ? void 0 : choice2.text) != null && choice2.text.length > 0)
            controller.enqueue({
              type: "text-delta",
              id: "0",
              delta: choice2.text
            });
        },
        flush(controller) {
          if (!isFirstChunk)
            controller.enqueue({ type: "text-end", id: "0" });
          controller.enqueue({
            type: "finish",
            finishReason,
            providerMetadata,
            usage: convertOpenAICompletionUsage(usage)
          });
        }
      })),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
}, openaiEmbeddingProviderOptions = lazySchema(() => zodSchema(exports_external.object({
  dimensions: exports_external.number().optional(),
  user: exports_external.string().optional()
}))), openaiTextEmbeddingResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  data: exports_external.array(exports_external.object({ embedding: exports_external.array(exports_external.number()) })),
  usage: exports_external.object({ prompt_tokens: exports_external.number() }).nullish()
}))), OpenAIEmbeddingModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.maxEmbeddingsPerCall = 2048, this.supportsParallelCalls = !0, this.modelId = modelId, this.config = config2;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a21;
    if (values.length > this.maxEmbeddingsPerCall)
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    let openaiOptions = (_a21 = await parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openaiEmbeddingProviderOptions
    })) != null ? _a21 : {}, {
      responseHeaders,
      value: response,
      rawValue
    } = await postJsonToApi({
      url: this.config.url({
        path: "/embeddings",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), headers),
      body: {
        model: this.modelId,
        input: values,
        encoding_format: "float",
        dimensions: openaiOptions.dimensions,
        user: openaiOptions.user
      },
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(openaiTextEmbeddingResponseSchema),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      warnings: [],
      embeddings: response.data.map((item) => item.embedding),
      usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
      response: { headers: responseHeaders, body: rawValue }
    };
  }
}, openaiImageResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  created: exports_external.number().nullish(),
  data: exports_external.array(exports_external.object({
    b64_json: exports_external.string(),
    revised_prompt: exports_external.string().nullish()
  })),
  background: exports_external.string().nullish(),
  output_format: exports_external.string().nullish(),
  size: exports_external.string().nullish(),
  quality: exports_external.string().nullish(),
  usage: exports_external.object({
    input_tokens: exports_external.number().nullish(),
    output_tokens: exports_external.number().nullish(),
    total_tokens: exports_external.number().nullish(),
    input_tokens_details: exports_external.object({
      image_tokens: exports_external.number().nullish(),
      text_tokens: exports_external.number().nullish()
    }).nullish()
  }).nullish()
}))), modelMaxImagesPerCall = {
  "dall-e-3": 1,
  "dall-e-2": 10,
  "gpt-image-1": 10,
  "gpt-image-1-mini": 10,
  "gpt-image-1.5": 10
}, defaultResponseFormatPrefixes = [
  "gpt-image-1-mini",
  "gpt-image-1.5",
  "gpt-image-1"
];
function hasDefaultResponseFormat(modelId) {
  return defaultResponseFormatPrefixes.some((prefix) => modelId.startsWith(prefix));
}
var OpenAIImageModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId, this.config = config2, this.specificationVersion = "v3";
  }
  get maxImagesPerCall() {
    var _a21;
    return (_a21 = modelMaxImagesPerCall[this.modelId]) != null ? _a21 : 1;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    files,
    mask,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a21, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    let warnings = [];
    if (aspectRatio != null)
      warnings.push({
        type: "unsupported",
        feature: "aspectRatio",
        details: "This model does not support aspect ratio. Use `size` instead."
      });
    if (seed != null)
      warnings.push({ type: "unsupported", feature: "seed" });
    let currentDate = (_c = (_b16 = (_a21 = this.config._internal) == null ? void 0 : _a21.currentDate) == null ? void 0 : _b16.call(_a21)) != null ? _c : /* @__PURE__ */ new Date;
    if (files != null) {
      let { value: response2, responseHeaders: responseHeaders2 } = await postFormDataToApi({
        url: this.config.url({
          path: "/images/edits",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), headers),
        formData: convertToFormData({
          model: this.modelId,
          prompt,
          image: await Promise.all(files.map((file2) => file2.type === "file" ? new Blob([
            file2.data instanceof Uint8Array ? new Blob([file2.data], {
              type: file2.mediaType
            }) : new Blob([convertBase64ToUint8Array(file2.data)], {
              type: file2.mediaType
            })
          ], { type: file2.mediaType }) : downloadBlob(file2.url))),
          mask: mask != null ? await fileToBlob(mask) : void 0,
          n,
          size,
          ...(_d = providerOptions.openai) != null ? _d : {}
        }),
        failedResponseHandler: openaiFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler(openaiImageResponseSchema),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response2.data.map((item) => item.b64_json),
        warnings,
        usage: response2.usage != null ? {
          inputTokens: (_e = response2.usage.input_tokens) != null ? _e : void 0,
          outputTokens: (_f = response2.usage.output_tokens) != null ? _f : void 0,
          totalTokens: (_g = response2.usage.total_tokens) != null ? _g : void 0
        } : void 0,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders2
        },
        providerMetadata: {
          openai: {
            images: response2.data.map((item) => {
              var _a24, _b23, _c2, _d2, _e2;
              return {
                ...item.revised_prompt ? { revisedPrompt: item.revised_prompt } : {},
                created: (_a24 = response2.created) != null ? _a24 : void 0,
                size: (_b23 = response2.size) != null ? _b23 : void 0,
                quality: (_c2 = response2.quality) != null ? _c2 : void 0,
                background: (_d2 = response2.background) != null ? _d2 : void 0,
                outputFormat: (_e2 = response2.output_format) != null ? _e2 : void 0
              };
            })
          }
        }
      };
    }
    let { value: response, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/images/generations",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), headers),
      body: {
        model: this.modelId,
        prompt,
        n,
        size,
        ...(_h = providerOptions.openai) != null ? _h : {},
        ...!hasDefaultResponseFormat(this.modelId) ? { response_format: "b64_json" } : {}
      },
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(openaiImageResponseSchema),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.data.map((item) => item.b64_json),
      warnings,
      usage: response.usage != null ? {
        inputTokens: (_i = response.usage.input_tokens) != null ? _i : void 0,
        outputTokens: (_j = response.usage.output_tokens) != null ? _j : void 0,
        totalTokens: (_k = response.usage.total_tokens) != null ? _k : void 0
      } : void 0,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      },
      providerMetadata: {
        openai: {
          images: response.data.map((item) => {
            var _a24, _b23, _c2, _d2, _e2;
            return {
              ...item.revised_prompt ? { revisedPrompt: item.revised_prompt } : {},
              created: (_a24 = response.created) != null ? _a24 : void 0,
              size: (_b23 = response.size) != null ? _b23 : void 0,
              quality: (_c2 = response.quality) != null ? _c2 : void 0,
              background: (_d2 = response.background) != null ? _d2 : void 0,
              outputFormat: (_e2 = response.output_format) != null ? _e2 : void 0
            };
          })
        }
      }
    };
  }
};
async function fileToBlob(file2) {
  if (!file2)
    return;
  if (file2.type === "url")
    return downloadBlob(file2.url);
  let data = file2.data instanceof Uint8Array ? file2.data : convertBase64ToUint8Array(file2.data);
  return new Blob([data], { type: file2.mediaType });
}
var applyPatchInputSchema = lazySchema(() => zodSchema(exports_external.object({
  callId: exports_external.string(),
  operation: exports_external.discriminatedUnion("type", [
    exports_external.object({
      type: exports_external.literal("create_file"),
      path: exports_external.string(),
      diff: exports_external.string()
    }),
    exports_external.object({
      type: exports_external.literal("delete_file"),
      path: exports_external.string()
    }),
    exports_external.object({
      type: exports_external.literal("update_file"),
      path: exports_external.string(),
      diff: exports_external.string()
    })
  ])
}))), applyPatchOutputSchema = lazySchema(() => zodSchema(exports_external.object({
  status: exports_external.enum(["completed", "failed"]),
  output: exports_external.string().optional()
}))), applyPatchArgsSchema = lazySchema(() => zodSchema(exports_external.object({}))), applyPatchToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "openai.apply_patch",
  inputSchema: applyPatchInputSchema,
  outputSchema: applyPatchOutputSchema
}), applyPatch = applyPatchToolFactory, codeInterpreterInputSchema = lazySchema(() => zodSchema(exports_external.object({
  code: exports_external.string().nullish(),
  containerId: exports_external.string()
}))), codeInterpreterOutputSchema = lazySchema(() => zodSchema(exports_external.object({
  outputs: exports_external.array(exports_external.discriminatedUnion("type", [
    exports_external.object({ type: exports_external.literal("logs"), logs: exports_external.string() }),
    exports_external.object({ type: exports_external.literal("image"), url: exports_external.string() })
  ])).nullish()
}))), codeInterpreterArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  container: exports_external.union([
    exports_external.string(),
    exports_external.object({
      fileIds: exports_external.array(exports_external.string()).optional()
    })
  ]).optional()
}))), codeInterpreterToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "openai.code_interpreter",
  inputSchema: codeInterpreterInputSchema,
  outputSchema: codeInterpreterOutputSchema
}), codeInterpreter = (args = {}) => {
  return codeInterpreterToolFactory(args);
}, comparisonFilterSchema = exports_external.object({
  key: exports_external.string(),
  type: exports_external.enum(["eq", "ne", "gt", "gte", "lt", "lte", "in", "nin"]),
  value: exports_external.union([exports_external.string(), exports_external.number(), exports_external.boolean(), exports_external.array(exports_external.string())])
}), compoundFilterSchema = exports_external.object({
  type: exports_external.enum(["and", "or"]),
  filters: exports_external.array(exports_external.union([comparisonFilterSchema, exports_external.lazy(() => compoundFilterSchema)]))
}), fileSearchArgsSchema2 = lazySchema(() => zodSchema(exports_external.object({
  vectorStoreIds: exports_external.array(exports_external.string()),
  maxNumResults: exports_external.number().optional(),
  ranking: exports_external.object({
    ranker: exports_external.string().optional(),
    scoreThreshold: exports_external.number().optional()
  }).optional(),
  filters: exports_external.union([comparisonFilterSchema, compoundFilterSchema]).optional()
}))), fileSearchOutputSchema = lazySchema(() => zodSchema(exports_external.object({
  queries: exports_external.array(exports_external.string()),
  results: exports_external.array(exports_external.object({
    attributes: exports_external.record(exports_external.string(), exports_external.unknown()),
    fileId: exports_external.string(),
    filename: exports_external.string(),
    score: exports_external.number(),
    text: exports_external.string()
  })).nullable()
}))), fileSearch2 = createProviderToolFactoryWithOutputSchema({
  id: "openai.file_search",
  inputSchema: exports_external.object({}),
  outputSchema: fileSearchOutputSchema
}), imageGenerationArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  background: exports_external.enum(["auto", "opaque", "transparent"]).optional(),
  inputFidelity: exports_external.enum(["low", "high"]).optional(),
  inputImageMask: exports_external.object({
    fileId: exports_external.string().optional(),
    imageUrl: exports_external.string().optional()
  }).optional(),
  model: exports_external.string().optional(),
  moderation: exports_external.enum(["auto"]).optional(),
  outputCompression: exports_external.number().int().min(0).max(100).optional(),
  outputFormat: exports_external.enum(["png", "jpeg", "webp"]).optional(),
  partialImages: exports_external.number().int().min(0).max(3).optional(),
  quality: exports_external.enum(["auto", "low", "medium", "high"]).optional(),
  size: exports_external.enum(["1024x1024", "1024x1536", "1536x1024", "auto"]).optional()
}).strict())), imageGenerationInputSchema = lazySchema(() => zodSchema(exports_external.object({}))), imageGenerationOutputSchema = lazySchema(() => zodSchema(exports_external.object({ result: exports_external.string() }))), imageGenerationToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "openai.image_generation",
  inputSchema: imageGenerationInputSchema,
  outputSchema: imageGenerationOutputSchema
}), imageGeneration = (args = {}) => {
  return imageGenerationToolFactory(args);
}, localShellInputSchema = lazySchema(() => zodSchema(exports_external.object({
  action: exports_external.object({
    type: exports_external.literal("exec"),
    command: exports_external.array(exports_external.string()),
    timeoutMs: exports_external.number().optional(),
    user: exports_external.string().optional(),
    workingDirectory: exports_external.string().optional(),
    env: exports_external.record(exports_external.string(), exports_external.string()).optional()
  })
}))), localShellOutputSchema = lazySchema(() => zodSchema(exports_external.object({ output: exports_external.string() }))), localShell = createProviderToolFactoryWithOutputSchema({
  id: "openai.local_shell",
  inputSchema: localShellInputSchema,
  outputSchema: localShellOutputSchema
}), shellInputSchema = lazySchema(() => zodSchema(exports_external.object({
  action: exports_external.object({
    commands: exports_external.array(exports_external.string()),
    timeoutMs: exports_external.number().optional(),
    maxOutputLength: exports_external.number().optional()
  })
}))), shellOutputSchema = lazySchema(() => zodSchema(exports_external.object({
  output: exports_external.array(exports_external.object({
    stdout: exports_external.string(),
    stderr: exports_external.string(),
    outcome: exports_external.discriminatedUnion("type", [
      exports_external.object({ type: exports_external.literal("timeout") }),
      exports_external.object({ type: exports_external.literal("exit"), exitCode: exports_external.number() })
    ])
  }))
}))), shell = createProviderToolFactoryWithOutputSchema({
  id: "openai.shell",
  inputSchema: shellInputSchema,
  outputSchema: shellOutputSchema
}), webSearchArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  externalWebAccess: exports_external.boolean().optional(),
  filters: exports_external.object({ allowedDomains: exports_external.array(exports_external.string()).optional() }).optional(),
  searchContextSize: exports_external.enum(["low", "medium", "high"]).optional(),
  userLocation: exports_external.object({
    type: exports_external.literal("approximate"),
    country: exports_external.string().optional(),
    city: exports_external.string().optional(),
    region: exports_external.string().optional(),
    timezone: exports_external.string().optional()
  }).optional()
}))), webSearchInputSchema = lazySchema(() => zodSchema(exports_external.object({}))), webSearchOutputSchema = lazySchema(() => zodSchema(exports_external.object({
  action: exports_external.discriminatedUnion("type", [
    exports_external.object({
      type: exports_external.literal("search"),
      query: exports_external.string().optional()
    }),
    exports_external.object({
      type: exports_external.literal("openPage"),
      url: exports_external.string().nullish()
    }),
    exports_external.object({
      type: exports_external.literal("findInPage"),
      url: exports_external.string().nullish(),
      pattern: exports_external.string().nullish()
    })
  ]),
  sources: exports_external.array(exports_external.discriminatedUnion("type", [
    exports_external.object({ type: exports_external.literal("url"), url: exports_external.string() }),
    exports_external.object({ type: exports_external.literal("api"), name: exports_external.string() })
  ])).optional()
}))), webSearchToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "openai.web_search",
  inputSchema: webSearchInputSchema,
  outputSchema: webSearchOutputSchema
}), webSearch = (args = {}) => webSearchToolFactory(args), webSearchPreviewArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  searchContextSize: exports_external.enum(["low", "medium", "high"]).optional(),
  userLocation: exports_external.object({
    type: exports_external.literal("approximate"),
    country: exports_external.string().optional(),
    city: exports_external.string().optional(),
    region: exports_external.string().optional(),
    timezone: exports_external.string().optional()
  }).optional()
}))), webSearchPreviewInputSchema = lazySchema(() => zodSchema(exports_external.object({}))), webSearchPreviewOutputSchema = lazySchema(() => zodSchema(exports_external.object({
  action: exports_external.discriminatedUnion("type", [
    exports_external.object({
      type: exports_external.literal("search"),
      query: exports_external.string().optional()
    }),
    exports_external.object({
      type: exports_external.literal("openPage"),
      url: exports_external.string().nullish()
    }),
    exports_external.object({
      type: exports_external.literal("findInPage"),
      url: exports_external.string().nullish(),
      pattern: exports_external.string().nullish()
    })
  ])
}))), webSearchPreview = createProviderToolFactoryWithOutputSchema({
  id: "openai.web_search_preview",
  inputSchema: webSearchPreviewInputSchema,
  outputSchema: webSearchPreviewOutputSchema
}), jsonValueSchema2 = exports_external.lazy(() => exports_external.union([
  exports_external.string(),
  exports_external.number(),
  exports_external.boolean(),
  exports_external.null(),
  exports_external.array(jsonValueSchema2),
  exports_external.record(exports_external.string(), jsonValueSchema2)
])), mcpArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  serverLabel: exports_external.string(),
  allowedTools: exports_external.union([
    exports_external.array(exports_external.string()),
    exports_external.object({
      readOnly: exports_external.boolean().optional(),
      toolNames: exports_external.array(exports_external.string()).optional()
    })
  ]).optional(),
  authorization: exports_external.string().optional(),
  connectorId: exports_external.string().optional(),
  headers: exports_external.record(exports_external.string(), exports_external.string()).optional(),
  requireApproval: exports_external.union([
    exports_external.enum(["always", "never"]),
    exports_external.object({
      never: exports_external.object({
        toolNames: exports_external.array(exports_external.string()).optional()
      }).optional()
    })
  ]).optional(),
  serverDescription: exports_external.string().optional(),
  serverUrl: exports_external.string().optional()
}).refine((v) => v.serverUrl != null || v.connectorId != null, "One of serverUrl or connectorId must be provided."))), mcpInputSchema = lazySchema(() => zodSchema(exports_external.object({}))), mcpOutputSchema = lazySchema(() => zodSchema(exports_external.object({
  type: exports_external.literal("call"),
  serverLabel: exports_external.string(),
  name: exports_external.string(),
  arguments: exports_external.string(),
  output: exports_external.string().nullish(),
  error: exports_external.union([exports_external.string(), jsonValueSchema2]).optional()
}))), mcpToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "openai.mcp",
  inputSchema: mcpInputSchema,
  outputSchema: mcpOutputSchema
}), mcp = (args) => mcpToolFactory(args), openaiTools = {
  applyPatch,
  codeInterpreter,
  fileSearch: fileSearch2,
  imageGeneration,
  localShell,
  shell,
  webSearchPreview,
  webSearch,
  mcp
};
function convertOpenAIResponsesUsage(usage) {
  var _a21, _b16, _c, _d;
  if (usage == null)
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  let { input_tokens: inputTokens, output_tokens: outputTokens } = usage, cachedTokens = (_b16 = (_a21 = usage.input_tokens_details) == null ? void 0 : _a21.cached_tokens) != null ? _b16 : 0, reasoningTokens = (_d = (_c = usage.output_tokens_details) == null ? void 0 : _c.reasoning_tokens) != null ? _d : 0;
  return {
    inputTokens: {
      total: inputTokens,
      noCache: inputTokens - cachedTokens,
      cacheRead: cachedTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: outputTokens,
      text: outputTokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function isFileId(data, prefixes) {
  if (!prefixes)
    return !1;
  return prefixes.some((prefix) => data.startsWith(prefix));
}
async function convertToOpenAIResponsesInput({
  prompt,
  toolNameMapping,
  systemMessageMode,
  providerOptionsName,
  fileIdPrefixes,
  store,
  hasConversation = !1,
  hasLocalShellTool = !1,
  hasShellTool = !1,
  hasApplyPatchTool = !1
}) {
  var _a21, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  let input = [], warnings = [], processedApprovalIds = /* @__PURE__ */ new Set;
  for (let { role, content } of prompt)
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            input.push({ role: "system", content });
            break;
          }
          case "developer": {
            input.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default:
            throw Error(`Unsupported system message mode: ${systemMessageMode}`);
        }
        break;
      }
      case "user": {
        input.push({
          role: "user",
          content: content.map((part, index) => {
            var _a24, _b23, _c2;
            switch (part.type) {
              case "text":
                return { type: "input_text", text: part.text };
              case "file":
                if (part.mediaType.startsWith("image/")) {
                  let mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "input_image",
                    ...part.data instanceof URL ? { image_url: part.data.toString() } : typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`
                    },
                    detail: (_b23 = (_a24 = part.providerOptions) == null ? void 0 : _a24[providerOptionsName]) == null ? void 0 : _b23.imageDetail
                  };
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL)
                    return {
                      type: "input_file",
                      file_url: part.data.toString()
                    };
                  return {
                    type: "input_file",
                    ...typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    }
                  };
                } else
                  throw new UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
            }
          })
        });
        break;
      }
      case "assistant": {
        let reasoningMessages = {};
        for (let part of content)
          switch (part.type) {
            case "text": {
              let id = (_b16 = (_a21 = part.providerOptions) == null ? void 0 : _a21[providerOptionsName]) == null ? void 0 : _b16.itemId;
              if (hasConversation && id != null)
                break;
              if (store && id != null) {
                input.push({ type: "item_reference", id });
                break;
              }
              input.push({
                role: "assistant",
                content: [{ type: "output_text", text: part.text }],
                id
              });
              break;
            }
            case "tool-call": {
              let id = (_g = (_d = (_c = part.providerOptions) == null ? void 0 : _c[providerOptionsName]) == null ? void 0 : _d.itemId) != null ? _g : (_f = (_e = part.providerMetadata) == null ? void 0 : _e[providerOptionsName]) == null ? void 0 : _f.itemId;
              if (hasConversation && id != null)
                break;
              if (part.providerExecuted) {
                if (store && id != null)
                  input.push({ type: "item_reference", id });
                break;
              }
              if (store && id != null) {
                input.push({ type: "item_reference", id });
                break;
              }
              let resolvedToolName = toolNameMapping.toProviderToolName(part.toolName);
              if (hasLocalShellTool && resolvedToolName === "local_shell") {
                let parsedInput = await validateTypes({
                  value: part.input,
                  schema: localShellInputSchema
                });
                input.push({
                  type: "local_shell_call",
                  call_id: part.toolCallId,
                  id,
                  action: {
                    type: "exec",
                    command: parsedInput.action.command,
                    timeout_ms: parsedInput.action.timeoutMs,
                    user: parsedInput.action.user,
                    working_directory: parsedInput.action.workingDirectory,
                    env: parsedInput.action.env
                  }
                });
                break;
              }
              if (hasShellTool && resolvedToolName === "shell") {
                let parsedInput = await validateTypes({
                  value: part.input,
                  schema: shellInputSchema
                });
                input.push({
                  type: "shell_call",
                  call_id: part.toolCallId,
                  id,
                  status: "completed",
                  action: {
                    commands: parsedInput.action.commands,
                    timeout_ms: parsedInput.action.timeoutMs,
                    max_output_length: parsedInput.action.maxOutputLength
                  }
                });
                break;
              }
              if (hasApplyPatchTool && resolvedToolName === "apply_patch") {
                let parsedInput = await validateTypes({
                  value: part.input,
                  schema: applyPatchInputSchema
                });
                input.push({
                  type: "apply_patch_call",
                  call_id: parsedInput.callId,
                  id,
                  status: "completed",
                  operation: parsedInput.operation
                });
                break;
              }
              input.push({
                type: "function_call",
                call_id: part.toolCallId,
                name: resolvedToolName,
                arguments: JSON.stringify(part.input),
                id
              });
              break;
            }
            case "tool-result": {
              if (part.output.type === "execution-denied" || part.output.type === "json" && typeof part.output.value === "object" && part.output.value != null && "type" in part.output.value && part.output.value.type === "execution-denied")
                break;
              if (hasConversation)
                break;
              if (store) {
                let itemId = (_j = (_i = (_h = part.providerMetadata) == null ? void 0 : _h[providerOptionsName]) == null ? void 0 : _i.itemId) != null ? _j : part.toolCallId;
                input.push({ type: "item_reference", id: itemId });
              } else
                warnings.push({
                  type: "other",
                  message: `Results for OpenAI tool ${part.toolName} are not sent to the API when store is false`
                });
              break;
            }
            case "reasoning": {
              let providerOptions = await parseProviderOptions({
                provider: providerOptionsName,
                providerOptions: part.providerOptions,
                schema: openaiResponsesReasoningProviderOptionsSchema
              }), reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
              if (hasConversation && reasoningId != null)
                break;
              if (reasoningId != null) {
                let reasoningMessage = reasoningMessages[reasoningId];
                if (store) {
                  if (reasoningMessage === void 0)
                    input.push({ type: "item_reference", id: reasoningId }), reasoningMessages[reasoningId] = {
                      type: "reasoning",
                      id: reasoningId,
                      summary: []
                    };
                } else {
                  let summaryParts = [];
                  if (part.text.length > 0)
                    summaryParts.push({
                      type: "summary_text",
                      text: part.text
                    });
                  else if (reasoningMessage !== void 0)
                    warnings.push({
                      type: "other",
                      message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                    });
                  if (reasoningMessage === void 0)
                    reasoningMessages[reasoningId] = {
                      type: "reasoning",
                      id: reasoningId,
                      encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                      summary: summaryParts
                    }, input.push(reasoningMessages[reasoningId]);
                  else if (reasoningMessage.summary.push(...summaryParts), (providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent) != null)
                    reasoningMessage.encrypted_content = providerOptions.reasoningEncryptedContent;
                }
              } else
                warnings.push({
                  type: "other",
                  message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                });
              break;
            }
          }
        break;
      }
      case "tool": {
        for (let part of content) {
          if (part.type === "tool-approval-response") {
            let approvalResponse = part;
            if (processedApprovalIds.has(approvalResponse.approvalId))
              continue;
            if (processedApprovalIds.add(approvalResponse.approvalId), store)
              input.push({
                type: "item_reference",
                id: approvalResponse.approvalId
              });
            input.push({
              type: "mcp_approval_response",
              approval_request_id: approvalResponse.approvalId,
              approve: approvalResponse.approved
            });
            continue;
          }
          let output = part.output;
          if (output.type === "execution-denied") {
            if ((_l = (_k = output.providerOptions) == null ? void 0 : _k.openai) == null ? void 0 : _l.approvalId)
              continue;
          }
          let resolvedToolName = toolNameMapping.toProviderToolName(part.toolName);
          if (hasLocalShellTool && resolvedToolName === "local_shell" && output.type === "json") {
            let parsedOutput = await validateTypes({
              value: output.value,
              schema: localShellOutputSchema
            });
            input.push({
              type: "local_shell_call_output",
              call_id: part.toolCallId,
              output: parsedOutput.output
            });
            continue;
          }
          if (hasShellTool && resolvedToolName === "shell" && output.type === "json") {
            let parsedOutput = await validateTypes({
              value: output.value,
              schema: shellOutputSchema
            });
            input.push({
              type: "shell_call_output",
              call_id: part.toolCallId,
              output: parsedOutput.output.map((item) => ({
                stdout: item.stdout,
                stderr: item.stderr,
                outcome: item.outcome.type === "timeout" ? { type: "timeout" } : {
                  type: "exit",
                  exit_code: item.outcome.exitCode
                }
              }))
            });
            continue;
          }
          if (hasApplyPatchTool && part.toolName === "apply_patch" && output.type === "json") {
            let parsedOutput = await validateTypes({
              value: output.value,
              schema: applyPatchOutputSchema
            });
            input.push({
              type: "apply_patch_call_output",
              call_id: part.toolCallId,
              status: parsedOutput.status,
              output: parsedOutput.output
            });
            continue;
          }
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_m = output.reason) != null ? _m : "Tool execution denied.";
              break;
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
            case "content":
              contentValue = output.value.map((item) => {
                var _a24;
                switch (item.type) {
                  case "text":
                    return { type: "input_text", text: item.text };
                  case "image-data":
                    return {
                      type: "input_image",
                      image_url: `data:${item.mediaType};base64,${item.data}`
                    };
                  case "image-url":
                    return {
                      type: "input_image",
                      image_url: item.url
                    };
                  case "file-data":
                    return {
                      type: "input_file",
                      filename: (_a24 = item.filename) != null ? _a24 : "data",
                      file_data: `data:${item.mediaType};base64,${item.data}`
                    };
                  default: {
                    warnings.push({
                      type: "other",
                      message: `unsupported tool content part type: ${item.type}`
                    });
                    return;
                  }
                }
              }).filter(isNonNullable);
              break;
          }
          input.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: contentValue
          });
        }
        break;
      }
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  return { input, warnings };
}
var openaiResponsesReasoningProviderOptionsSchema = exports_external.object({
  itemId: exports_external.string().nullish(),
  reasoningEncryptedContent: exports_external.string().nullish()
});
function mapOpenAIResponseFinishReason({
  finishReason,
  hasFunctionCall
}) {
  switch (finishReason) {
    case void 0:
    case null:
      return hasFunctionCall ? "tool-calls" : "stop";
    case "max_output_tokens":
      return "length";
    case "content_filter":
      return "content-filter";
    default:
      return hasFunctionCall ? "tool-calls" : "other";
  }
}
var openaiResponsesChunkSchema = lazySchema(() => zodSchema(exports_external.union([
  exports_external.object({
    type: exports_external.literal("response.output_text.delta"),
    item_id: exports_external.string(),
    delta: exports_external.string(),
    logprobs: exports_external.array(exports_external.object({
      token: exports_external.string(),
      logprob: exports_external.number(),
      top_logprobs: exports_external.array(exports_external.object({
        token: exports_external.string(),
        logprob: exports_external.number()
      }))
    })).nullish()
  }),
  exports_external.object({
    type: exports_external.enum(["response.completed", "response.incomplete"]),
    response: exports_external.object({
      incomplete_details: exports_external.object({ reason: exports_external.string() }).nullish(),
      usage: exports_external.object({
        input_tokens: exports_external.number(),
        input_tokens_details: exports_external.object({ cached_tokens: exports_external.number().nullish() }).nullish(),
        output_tokens: exports_external.number(),
        output_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish() }).nullish()
      }),
      service_tier: exports_external.string().nullish()
    })
  }),
  exports_external.object({
    type: exports_external.literal("response.created"),
    response: exports_external.object({
      id: exports_external.string(),
      created_at: exports_external.number(),
      model: exports_external.string(),
      service_tier: exports_external.string().nullish()
    })
  }),
  exports_external.object({
    type: exports_external.literal("response.output_item.added"),
    output_index: exports_external.number(),
    item: exports_external.discriminatedUnion("type", [
      exports_external.object({
        type: exports_external.literal("message"),
        id: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("reasoning"),
        id: exports_external.string(),
        encrypted_content: exports_external.string().nullish()
      }),
      exports_external.object({
        type: exports_external.literal("function_call"),
        id: exports_external.string(),
        call_id: exports_external.string(),
        name: exports_external.string(),
        arguments: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("web_search_call"),
        id: exports_external.string(),
        status: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("computer_call"),
        id: exports_external.string(),
        status: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("file_search_call"),
        id: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("image_generation_call"),
        id: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("code_interpreter_call"),
        id: exports_external.string(),
        container_id: exports_external.string(),
        code: exports_external.string().nullable(),
        outputs: exports_external.array(exports_external.discriminatedUnion("type", [
          exports_external.object({ type: exports_external.literal("logs"), logs: exports_external.string() }),
          exports_external.object({ type: exports_external.literal("image"), url: exports_external.string() })
        ])).nullable(),
        status: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("mcp_call"),
        id: exports_external.string(),
        status: exports_external.string(),
        approval_request_id: exports_external.string().nullish()
      }),
      exports_external.object({
        type: exports_external.literal("mcp_list_tools"),
        id: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("mcp_approval_request"),
        id: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("apply_patch_call"),
        id: exports_external.string(),
        call_id: exports_external.string(),
        status: exports_external.enum(["in_progress", "completed"]),
        operation: exports_external.discriminatedUnion("type", [
          exports_external.object({
            type: exports_external.literal("create_file"),
            path: exports_external.string(),
            diff: exports_external.string()
          }),
          exports_external.object({
            type: exports_external.literal("delete_file"),
            path: exports_external.string()
          }),
          exports_external.object({
            type: exports_external.literal("update_file"),
            path: exports_external.string(),
            diff: exports_external.string()
          })
        ])
      }),
      exports_external.object({
        type: exports_external.literal("shell_call"),
        id: exports_external.string(),
        call_id: exports_external.string(),
        status: exports_external.enum(["in_progress", "completed", "incomplete"]),
        action: exports_external.object({
          commands: exports_external.array(exports_external.string())
        })
      })
    ])
  }),
  exports_external.object({
    type: exports_external.literal("response.output_item.done"),
    output_index: exports_external.number(),
    item: exports_external.discriminatedUnion("type", [
      exports_external.object({
        type: exports_external.literal("message"),
        id: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("reasoning"),
        id: exports_external.string(),
        encrypted_content: exports_external.string().nullish()
      }),
      exports_external.object({
        type: exports_external.literal("function_call"),
        id: exports_external.string(),
        call_id: exports_external.string(),
        name: exports_external.string(),
        arguments: exports_external.string(),
        status: exports_external.literal("completed")
      }),
      exports_external.object({
        type: exports_external.literal("code_interpreter_call"),
        id: exports_external.string(),
        code: exports_external.string().nullable(),
        container_id: exports_external.string(),
        outputs: exports_external.array(exports_external.discriminatedUnion("type", [
          exports_external.object({ type: exports_external.literal("logs"), logs: exports_external.string() }),
          exports_external.object({ type: exports_external.literal("image"), url: exports_external.string() })
        ])).nullable()
      }),
      exports_external.object({
        type: exports_external.literal("image_generation_call"),
        id: exports_external.string(),
        result: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("web_search_call"),
        id: exports_external.string(),
        status: exports_external.string(),
        action: exports_external.discriminatedUnion("type", [
          exports_external.object({
            type: exports_external.literal("search"),
            query: exports_external.string().nullish(),
            sources: exports_external.array(exports_external.discriminatedUnion("type", [
              exports_external.object({ type: exports_external.literal("url"), url: exports_external.string() }),
              exports_external.object({ type: exports_external.literal("api"), name: exports_external.string() })
            ])).nullish()
          }),
          exports_external.object({
            type: exports_external.literal("open_page"),
            url: exports_external.string().nullish()
          }),
          exports_external.object({
            type: exports_external.literal("find_in_page"),
            url: exports_external.string().nullish(),
            pattern: exports_external.string().nullish()
          })
        ])
      }),
      exports_external.object({
        type: exports_external.literal("file_search_call"),
        id: exports_external.string(),
        queries: exports_external.array(exports_external.string()),
        results: exports_external.array(exports_external.object({
          attributes: exports_external.record(exports_external.string(), exports_external.union([exports_external.string(), exports_external.number(), exports_external.boolean()])),
          file_id: exports_external.string(),
          filename: exports_external.string(),
          score: exports_external.number(),
          text: exports_external.string()
        })).nullish()
      }),
      exports_external.object({
        type: exports_external.literal("local_shell_call"),
        id: exports_external.string(),
        call_id: exports_external.string(),
        action: exports_external.object({
          type: exports_external.literal("exec"),
          command: exports_external.array(exports_external.string()),
          timeout_ms: exports_external.number().optional(),
          user: exports_external.string().optional(),
          working_directory: exports_external.string().optional(),
          env: exports_external.record(exports_external.string(), exports_external.string()).optional()
        })
      }),
      exports_external.object({
        type: exports_external.literal("computer_call"),
        id: exports_external.string(),
        status: exports_external.literal("completed")
      }),
      exports_external.object({
        type: exports_external.literal("mcp_call"),
        id: exports_external.string(),
        status: exports_external.string(),
        arguments: exports_external.string(),
        name: exports_external.string(),
        server_label: exports_external.string(),
        output: exports_external.string().nullish(),
        error: exports_external.union([
          exports_external.string(),
          exports_external.object({
            type: exports_external.string().optional(),
            code: exports_external.union([exports_external.number(), exports_external.string()]).optional(),
            message: exports_external.string().optional()
          }).loose()
        ]).nullish(),
        approval_request_id: exports_external.string().nullish()
      }),
      exports_external.object({
        type: exports_external.literal("mcp_list_tools"),
        id: exports_external.string(),
        server_label: exports_external.string(),
        tools: exports_external.array(exports_external.object({
          name: exports_external.string(),
          description: exports_external.string().optional(),
          input_schema: exports_external.any(),
          annotations: exports_external.record(exports_external.string(), exports_external.unknown()).optional()
        })),
        error: exports_external.union([
          exports_external.string(),
          exports_external.object({
            type: exports_external.string().optional(),
            code: exports_external.union([exports_external.number(), exports_external.string()]).optional(),
            message: exports_external.string().optional()
          }).loose()
        ]).optional()
      }),
      exports_external.object({
        type: exports_external.literal("mcp_approval_request"),
        id: exports_external.string(),
        server_label: exports_external.string(),
        name: exports_external.string(),
        arguments: exports_external.string(),
        approval_request_id: exports_external.string().optional()
      }),
      exports_external.object({
        type: exports_external.literal("apply_patch_call"),
        id: exports_external.string(),
        call_id: exports_external.string(),
        status: exports_external.enum(["in_progress", "completed"]),
        operation: exports_external.discriminatedUnion("type", [
          exports_external.object({
            type: exports_external.literal("create_file"),
            path: exports_external.string(),
            diff: exports_external.string()
          }),
          exports_external.object({
            type: exports_external.literal("delete_file"),
            path: exports_external.string()
          }),
          exports_external.object({
            type: exports_external.literal("update_file"),
            path: exports_external.string(),
            diff: exports_external.string()
          })
        ])
      }),
      exports_external.object({
        type: exports_external.literal("shell_call"),
        id: exports_external.string(),
        call_id: exports_external.string(),
        status: exports_external.enum(["in_progress", "completed", "incomplete"]),
        action: exports_external.object({
          commands: exports_external.array(exports_external.string())
        })
      })
    ])
  }),
  exports_external.object({
    type: exports_external.literal("response.function_call_arguments.delta"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    delta: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.image_generation_call.partial_image"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    partial_image_b64: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_interpreter_call_code.delta"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    delta: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_interpreter_call_code.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    code: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.output_text.annotation.added"),
    annotation: exports_external.discriminatedUnion("type", [
      exports_external.object({
        type: exports_external.literal("url_citation"),
        start_index: exports_external.number(),
        end_index: exports_external.number(),
        url: exports_external.string(),
        title: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("file_citation"),
        file_id: exports_external.string(),
        filename: exports_external.string(),
        index: exports_external.number()
      }),
      exports_external.object({
        type: exports_external.literal("container_file_citation"),
        container_id: exports_external.string(),
        file_id: exports_external.string(),
        filename: exports_external.string(),
        start_index: exports_external.number(),
        end_index: exports_external.number()
      }),
      exports_external.object({
        type: exports_external.literal("file_path"),
        file_id: exports_external.string(),
        index: exports_external.number()
      })
    ])
  }),
  exports_external.object({
    type: exports_external.literal("response.reasoning_summary_part.added"),
    item_id: exports_external.string(),
    summary_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.reasoning_summary_text.delta"),
    item_id: exports_external.string(),
    summary_index: exports_external.number(),
    delta: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.reasoning_summary_part.done"),
    item_id: exports_external.string(),
    summary_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.apply_patch_call_operation_diff.delta"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    delta: exports_external.string(),
    obfuscation: exports_external.string().nullish()
  }),
  exports_external.object({
    type: exports_external.literal("response.apply_patch_call_operation_diff.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    diff: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("error"),
    sequence_number: exports_external.number(),
    error: exports_external.object({
      type: exports_external.string(),
      code: exports_external.string(),
      message: exports_external.string(),
      param: exports_external.string().nullish()
    })
  }),
  exports_external.object({ type: exports_external.string() }).loose().transform((value) => ({
    type: "unknown_chunk",
    message: value.type
  }))
]))), openaiResponsesResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  id: exports_external.string().optional(),
  created_at: exports_external.number().optional(),
  error: exports_external.object({
    message: exports_external.string(),
    type: exports_external.string(),
    param: exports_external.string().nullish(),
    code: exports_external.string()
  }).nullish(),
  model: exports_external.string().optional(),
  output: exports_external.array(exports_external.discriminatedUnion("type", [
    exports_external.object({
      type: exports_external.literal("message"),
      role: exports_external.literal("assistant"),
      id: exports_external.string(),
      content: exports_external.array(exports_external.object({
        type: exports_external.literal("output_text"),
        text: exports_external.string(),
        logprobs: exports_external.array(exports_external.object({
          token: exports_external.string(),
          logprob: exports_external.number(),
          top_logprobs: exports_external.array(exports_external.object({
            token: exports_external.string(),
            logprob: exports_external.number()
          }))
        })).nullish(),
        annotations: exports_external.array(exports_external.discriminatedUnion("type", [
          exports_external.object({
            type: exports_external.literal("url_citation"),
            start_index: exports_external.number(),
            end_index: exports_external.number(),
            url: exports_external.string(),
            title: exports_external.string()
          }),
          exports_external.object({
            type: exports_external.literal("file_citation"),
            file_id: exports_external.string(),
            filename: exports_external.string(),
            index: exports_external.number()
          }),
          exports_external.object({
            type: exports_external.literal("container_file_citation"),
            container_id: exports_external.string(),
            file_id: exports_external.string(),
            filename: exports_external.string(),
            start_index: exports_external.number(),
            end_index: exports_external.number()
          }),
          exports_external.object({
            type: exports_external.literal("file_path"),
            file_id: exports_external.string(),
            index: exports_external.number()
          })
        ]))
      }))
    }),
    exports_external.object({
      type: exports_external.literal("web_search_call"),
      id: exports_external.string(),
      status: exports_external.string(),
      action: exports_external.discriminatedUnion("type", [
        exports_external.object({
          type: exports_external.literal("search"),
          query: exports_external.string().nullish(),
          sources: exports_external.array(exports_external.discriminatedUnion("type", [
            exports_external.object({ type: exports_external.literal("url"), url: exports_external.string() }),
            exports_external.object({ type: exports_external.literal("api"), name: exports_external.string() })
          ])).nullish()
        }),
        exports_external.object({
          type: exports_external.literal("open_page"),
          url: exports_external.string().nullish()
        }),
        exports_external.object({
          type: exports_external.literal("find_in_page"),
          url: exports_external.string().nullish(),
          pattern: exports_external.string().nullish()
        })
      ])
    }),
    exports_external.object({
      type: exports_external.literal("file_search_call"),
      id: exports_external.string(),
      queries: exports_external.array(exports_external.string()),
      results: exports_external.array(exports_external.object({
        attributes: exports_external.record(exports_external.string(), exports_external.union([exports_external.string(), exports_external.number(), exports_external.boolean()])),
        file_id: exports_external.string(),
        filename: exports_external.string(),
        score: exports_external.number(),
        text: exports_external.string()
      })).nullish()
    }),
    exports_external.object({
      type: exports_external.literal("code_interpreter_call"),
      id: exports_external.string(),
      code: exports_external.string().nullable(),
      container_id: exports_external.string(),
      outputs: exports_external.array(exports_external.discriminatedUnion("type", [
        exports_external.object({ type: exports_external.literal("logs"), logs: exports_external.string() }),
        exports_external.object({ type: exports_external.literal("image"), url: exports_external.string() })
      ])).nullable()
    }),
    exports_external.object({
      type: exports_external.literal("image_generation_call"),
      id: exports_external.string(),
      result: exports_external.string()
    }),
    exports_external.object({
      type: exports_external.literal("local_shell_call"),
      id: exports_external.string(),
      call_id: exports_external.string(),
      action: exports_external.object({
        type: exports_external.literal("exec"),
        command: exports_external.array(exports_external.string()),
        timeout_ms: exports_external.number().optional(),
        user: exports_external.string().optional(),
        working_directory: exports_external.string().optional(),
        env: exports_external.record(exports_external.string(), exports_external.string()).optional()
      })
    }),
    exports_external.object({
      type: exports_external.literal("function_call"),
      call_id: exports_external.string(),
      name: exports_external.string(),
      arguments: exports_external.string(),
      id: exports_external.string()
    }),
    exports_external.object({
      type: exports_external.literal("computer_call"),
      id: exports_external.string(),
      status: exports_external.string().optional()
    }),
    exports_external.object({
      type: exports_external.literal("reasoning"),
      id: exports_external.string(),
      encrypted_content: exports_external.string().nullish(),
      summary: exports_external.array(exports_external.object({
        type: exports_external.literal("summary_text"),
        text: exports_external.string()
      }))
    }),
    exports_external.object({
      type: exports_external.literal("mcp_call"),
      id: exports_external.string(),
      status: exports_external.string(),
      arguments: exports_external.string(),
      name: exports_external.string(),
      server_label: exports_external.string(),
      output: exports_external.string().nullish(),
      error: exports_external.union([
        exports_external.string(),
        exports_external.object({
          type: exports_external.string().optional(),
          code: exports_external.union([exports_external.number(), exports_external.string()]).optional(),
          message: exports_external.string().optional()
        }).loose()
      ]).nullish(),
      approval_request_id: exports_external.string().nullish()
    }),
    exports_external.object({
      type: exports_external.literal("mcp_list_tools"),
      id: exports_external.string(),
      server_label: exports_external.string(),
      tools: exports_external.array(exports_external.object({
        name: exports_external.string(),
        description: exports_external.string().optional(),
        input_schema: exports_external.any(),
        annotations: exports_external.record(exports_external.string(), exports_external.unknown()).optional()
      })),
      error: exports_external.union([
        exports_external.string(),
        exports_external.object({
          type: exports_external.string().optional(),
          code: exports_external.union([exports_external.number(), exports_external.string()]).optional(),
          message: exports_external.string().optional()
        }).loose()
      ]).optional()
    }),
    exports_external.object({
      type: exports_external.literal("mcp_approval_request"),
      id: exports_external.string(),
      server_label: exports_external.string(),
      name: exports_external.string(),
      arguments: exports_external.string(),
      approval_request_id: exports_external.string().optional()
    }),
    exports_external.object({
      type: exports_external.literal("apply_patch_call"),
      id: exports_external.string(),
      call_id: exports_external.string(),
      status: exports_external.enum(["in_progress", "completed"]),
      operation: exports_external.discriminatedUnion("type", [
        exports_external.object({
          type: exports_external.literal("create_file"),
          path: exports_external.string(),
          diff: exports_external.string()
        }),
        exports_external.object({
          type: exports_external.literal("delete_file"),
          path: exports_external.string()
        }),
        exports_external.object({
          type: exports_external.literal("update_file"),
          path: exports_external.string(),
          diff: exports_external.string()
        })
      ])
    }),
    exports_external.object({
      type: exports_external.literal("shell_call"),
      id: exports_external.string(),
      call_id: exports_external.string(),
      status: exports_external.enum(["in_progress", "completed", "incomplete"]),
      action: exports_external.object({
        commands: exports_external.array(exports_external.string())
      })
    })
  ])).optional(),
  service_tier: exports_external.string().nullish(),
  incomplete_details: exports_external.object({ reason: exports_external.string() }).nullish(),
  usage: exports_external.object({
    input_tokens: exports_external.number(),
    input_tokens_details: exports_external.object({ cached_tokens: exports_external.number().nullish() }).nullish(),
    output_tokens: exports_external.number(),
    output_tokens_details: exports_external.object({ reasoning_tokens: exports_external.number().nullish() }).nullish()
  }).optional()
}))), TOP_LOGPROBS_MAX = 20, openaiResponsesReasoningModelIds = [
  "o1",
  "o1-2024-12-17",
  "o3",
  "o3-2025-04-16",
  "o3-deep-research",
  "o3-deep-research-2025-06-26",
  "o3-mini",
  "o3-mini-2025-01-31",
  "o4-mini",
  "o4-mini-2025-04-16",
  "o4-mini-deep-research",
  "o4-mini-deep-research-2025-06-26",
  "codex-mini-latest",
  "computer-use-preview",
  "gpt-5",
  "gpt-5-2025-08-07",
  "gpt-5-codex",
  "gpt-5-mini",
  "gpt-5-mini-2025-08-07",
  "gpt-5-nano",
  "gpt-5-nano-2025-08-07",
  "gpt-5-pro",
  "gpt-5-pro-2025-10-06",
  "gpt-5.1",
  "gpt-5.1-chat-latest",
  "gpt-5.1-codex-mini",
  "gpt-5.1-codex",
  "gpt-5.1-codex-max",
  "gpt-5.2",
  "gpt-5.2-chat-latest",
  "gpt-5.2-pro"
], openaiResponsesModelIds = [
  "gpt-4.1",
  "gpt-4.1-2025-04-14",
  "gpt-4.1-mini",
  "gpt-4.1-mini-2025-04-14",
  "gpt-4.1-nano",
  "gpt-4.1-nano-2025-04-14",
  "gpt-4o",
  "gpt-4o-2024-05-13",
  "gpt-4o-2024-08-06",
  "gpt-4o-2024-11-20",
  "gpt-4o-audio-preview",
  "gpt-4o-audio-preview-2024-10-01",
  "gpt-4o-audio-preview-2024-12-17",
  "gpt-4o-search-preview",
  "gpt-4o-search-preview-2025-03-11",
  "gpt-4o-mini-search-preview",
  "gpt-4o-mini-search-preview-2025-03-11",
  "gpt-4o-mini",
  "gpt-4o-mini-2024-07-18",
  "gpt-4-turbo",
  "gpt-4-turbo-2024-04-09",
  "gpt-4-turbo-preview",
  "gpt-4-0125-preview",
  "gpt-4-1106-preview",
  "gpt-4",
  "gpt-4-0613",
  "gpt-4.5-preview",
  "gpt-4.5-preview-2025-02-27",
  "gpt-3.5-turbo-0125",
  "gpt-3.5-turbo",
  "gpt-3.5-turbo-1106",
  "chatgpt-4o-latest",
  "gpt-5-chat-latest",
  ...openaiResponsesReasoningModelIds
], openaiResponsesProviderOptionsSchema = lazySchema(() => zodSchema(exports_external.object({
  conversation: exports_external.string().nullish(),
  include: exports_external.array(exports_external.enum([
    "reasoning.encrypted_content",
    "file_search_call.results",
    "message.output_text.logprobs"
  ])).nullish(),
  instructions: exports_external.string().nullish(),
  logprobs: exports_external.union([exports_external.boolean(), exports_external.number().min(1).max(TOP_LOGPROBS_MAX)]).optional(),
  maxToolCalls: exports_external.number().nullish(),
  metadata: exports_external.any().nullish(),
  parallelToolCalls: exports_external.boolean().nullish(),
  previousResponseId: exports_external.string().nullish(),
  promptCacheKey: exports_external.string().nullish(),
  promptCacheRetention: exports_external.enum(["in_memory", "24h"]).nullish(),
  reasoningEffort: exports_external.string().nullish(),
  reasoningSummary: exports_external.string().nullish(),
  safetyIdentifier: exports_external.string().nullish(),
  serviceTier: exports_external.enum(["auto", "flex", "priority", "default"]).nullish(),
  store: exports_external.boolean().nullish(),
  strictJsonSchema: exports_external.boolean().nullish(),
  textVerbosity: exports_external.enum(["low", "medium", "high"]).nullish(),
  truncation: exports_external.enum(["auto", "disabled"]).nullish(),
  user: exports_external.string().nullish(),
  systemMessageMode: exports_external.enum(["system", "developer", "remove"]).optional(),
  forceReasoning: exports_external.boolean().optional()
})));
async function prepareResponsesTools({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  let toolWarnings = [];
  if (tools == null)
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  let openaiTools2 = [];
  for (let tool2 of tools)
    switch (tool2.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          name: tool2.name,
          description: tool2.description,
          parameters: tool2.inputSchema,
          ...tool2.strict != null ? { strict: tool2.strict } : {}
        });
        break;
      case "provider": {
        switch (tool2.id) {
          case "openai.file_search": {
            let args = await validateTypes({
              value: tool2.args,
              schema: fileSearchArgsSchema2
            });
            openaiTools2.push({
              type: "file_search",
              vector_store_ids: args.vectorStoreIds,
              max_num_results: args.maxNumResults,
              ranking_options: args.ranking ? {
                ranker: args.ranking.ranker,
                score_threshold: args.ranking.scoreThreshold
              } : void 0,
              filters: args.filters
            });
            break;
          }
          case "openai.local_shell": {
            openaiTools2.push({
              type: "local_shell"
            });
            break;
          }
          case "openai.shell": {
            openaiTools2.push({
              type: "shell"
            });
            break;
          }
          case "openai.apply_patch": {
            openaiTools2.push({
              type: "apply_patch"
            });
            break;
          }
          case "openai.web_search_preview": {
            let args = await validateTypes({
              value: tool2.args,
              schema: webSearchPreviewArgsSchema
            });
            openaiTools2.push({
              type: "web_search_preview",
              search_context_size: args.searchContextSize,
              user_location: args.userLocation
            });
            break;
          }
          case "openai.web_search": {
            let args = await validateTypes({
              value: tool2.args,
              schema: webSearchArgsSchema
            });
            openaiTools2.push({
              type: "web_search",
              filters: args.filters != null ? { allowed_domains: args.filters.allowedDomains } : void 0,
              external_web_access: args.externalWebAccess,
              search_context_size: args.searchContextSize,
              user_location: args.userLocation
            });
            break;
          }
          case "openai.code_interpreter": {
            let args = await validateTypes({
              value: tool2.args,
              schema: codeInterpreterArgsSchema
            });
            openaiTools2.push({
              type: "code_interpreter",
              container: args.container == null ? { type: "auto", file_ids: void 0 } : typeof args.container === "string" ? args.container : { type: "auto", file_ids: args.container.fileIds }
            });
            break;
          }
          case "openai.image_generation": {
            let args = await validateTypes({
              value: tool2.args,
              schema: imageGenerationArgsSchema
            });
            openaiTools2.push({
              type: "image_generation",
              background: args.background,
              input_fidelity: args.inputFidelity,
              input_image_mask: args.inputImageMask ? {
                file_id: args.inputImageMask.fileId,
                image_url: args.inputImageMask.imageUrl
              } : void 0,
              model: args.model,
              moderation: args.moderation,
              partial_images: args.partialImages,
              quality: args.quality,
              output_compression: args.outputCompression,
              output_format: args.outputFormat,
              size: args.size
            });
            break;
          }
          case "openai.mcp": {
            let args = await validateTypes({
              value: tool2.args,
              schema: mcpArgsSchema
            }), mapApprovalFilter = (filter2) => ({
              tool_names: filter2.toolNames
            }), requireApproval = args.requireApproval, requireApprovalParam = requireApproval == null ? void 0 : typeof requireApproval === "string" ? requireApproval : requireApproval.never != null ? { never: mapApprovalFilter(requireApproval.never) } : void 0;
            openaiTools2.push({
              type: "mcp",
              server_label: args.serverLabel,
              allowed_tools: Array.isArray(args.allowedTools) ? args.allowedTools : args.allowedTools ? {
                read_only: args.allowedTools.readOnly,
                tool_names: args.allowedTools.toolNames
              } : void 0,
              authorization: args.authorization,
              connector_id: args.connectorId,
              headers: args.headers,
              require_approval: requireApprovalParam != null ? requireApprovalParam : "never",
              server_description: args.serverDescription,
              server_url: args.serverUrl
            });
            break;
          }
        }
        break;
      }
      default:
        toolWarnings.push({
          type: "unsupported",
          feature: `function tool ${tool2}`
        });
        break;
    }
  if (toolChoice == null)
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  let type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "image_generation" || toolChoice.toolName === "web_search_preview" || toolChoice.toolName === "web_search" || toolChoice.toolName === "mcp" || toolChoice.toolName === "apply_patch" ? { type: toolChoice.toolName } : { type: "function", name: toolChoice.toolName },
        toolWarnings
      };
    default:
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${type}`
      });
  }
}
function extractApprovalRequestIdToToolCallIdMapping(prompt) {
  var _a21, _b16;
  let mapping = {};
  for (let message of prompt) {
    if (message.role !== "assistant")
      continue;
    for (let part of message.content) {
      if (part.type !== "tool-call")
        continue;
      let approvalRequestId = (_b16 = (_a21 = part.providerOptions) == null ? void 0 : _a21.openai) == null ? void 0 : _b16.approvalRequestId;
      if (approvalRequestId != null)
        mapping[approvalRequestId] = part.toolCallId;
    }
  }
  return mapping;
}
var OpenAIResponsesLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/],
      "application/pdf": [/^https?:\/\/.*$/]
    }, this.modelId = modelId, this.config = config2;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    maxOutputTokens,
    temperature,
    stopSequences,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    seed,
    prompt,
    providerOptions,
    tools,
    toolChoice,
    responseFormat
  }) {
    var _a21, _b16, _c, _d, _e, _f;
    let warnings = [], modelCapabilities = getOpenAILanguageModelCapabilities(this.modelId);
    if (topK != null)
      warnings.push({ type: "unsupported", feature: "topK" });
    if (seed != null)
      warnings.push({ type: "unsupported", feature: "seed" });
    if (presencePenalty != null)
      warnings.push({ type: "unsupported", feature: "presencePenalty" });
    if (frequencyPenalty != null)
      warnings.push({ type: "unsupported", feature: "frequencyPenalty" });
    if (stopSequences != null)
      warnings.push({ type: "unsupported", feature: "stopSequences" });
    let providerOptionsName = this.config.provider.includes("azure") ? "azure" : "openai", openaiOptions = await parseProviderOptions({
      provider: providerOptionsName,
      providerOptions,
      schema: openaiResponsesProviderOptionsSchema
    });
    if (openaiOptions == null && providerOptionsName !== "openai")
      openaiOptions = await parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiResponsesProviderOptionsSchema
      });
    let isReasoningModel = (_a21 = openaiOptions == null ? void 0 : openaiOptions.forceReasoning) != null ? _a21 : modelCapabilities.isReasoningModel;
    if ((openaiOptions == null ? void 0 : openaiOptions.conversation) && (openaiOptions == null ? void 0 : openaiOptions.previousResponseId))
      warnings.push({
        type: "unsupported",
        feature: "conversation",
        details: "conversation and previousResponseId cannot be used together"
      });
    let toolNameMapping = createToolNameMapping({
      tools,
      providerToolNames: {
        "openai.code_interpreter": "code_interpreter",
        "openai.file_search": "file_search",
        "openai.image_generation": "image_generation",
        "openai.local_shell": "local_shell",
        "openai.shell": "shell",
        "openai.web_search": "web_search",
        "openai.web_search_preview": "web_search_preview",
        "openai.mcp": "mcp",
        "openai.apply_patch": "apply_patch"
      }
    }), { input, warnings: inputWarnings } = await convertToOpenAIResponsesInput({
      prompt,
      toolNameMapping,
      systemMessageMode: (_b16 = openaiOptions == null ? void 0 : openaiOptions.systemMessageMode) != null ? _b16 : isReasoningModel ? "developer" : modelCapabilities.systemMessageMode,
      providerOptionsName,
      fileIdPrefixes: this.config.fileIdPrefixes,
      store: (_c = openaiOptions == null ? void 0 : openaiOptions.store) != null ? _c : !0,
      hasConversation: (openaiOptions == null ? void 0 : openaiOptions.conversation) != null,
      hasLocalShellTool: hasOpenAITool("openai.local_shell"),
      hasShellTool: hasOpenAITool("openai.shell"),
      hasApplyPatchTool: hasOpenAITool("openai.apply_patch")
    });
    warnings.push(...inputWarnings);
    let strictJsonSchema = (_d = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _d : !0, include = openaiOptions == null ? void 0 : openaiOptions.include;
    function addInclude(key) {
      if (include == null)
        include = [key];
      else if (!include.includes(key))
        include = [...include, key];
    }
    function hasOpenAITool(id) {
      return (tools == null ? void 0 : tools.find((tool2) => tool2.type === "provider" && tool2.id === id)) != null;
    }
    let topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === !0 ? TOP_LOGPROBS_MAX : void 0;
    if (topLogprobs)
      addInclude("message.output_text.logprobs");
    let webSearchToolName = (_e = tools == null ? void 0 : tools.find((tool2) => tool2.type === "provider" && (tool2.id === "openai.web_search" || tool2.id === "openai.web_search_preview"))) == null ? void 0 : _e.name;
    if (webSearchToolName)
      addInclude("web_search_call.action.sources");
    if (hasOpenAITool("openai.code_interpreter"))
      addInclude("code_interpreter_call.outputs");
    let store = openaiOptions == null ? void 0 : openaiOptions.store;
    if (store === !1 && isReasoningModel)
      addInclude("reasoning.encrypted_content");
    let baseArgs = {
      model: this.modelId,
      input,
      temperature,
      top_p: topP,
      max_output_tokens: maxOutputTokens,
      ...((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
        text: {
          ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
            format: responseFormat.schema != null ? {
              type: "json_schema",
              strict: strictJsonSchema,
              name: (_f = responseFormat.name) != null ? _f : "response",
              description: responseFormat.description,
              schema: responseFormat.schema
            } : { type: "json_object" }
          },
          ...(openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
            verbosity: openaiOptions.textVerbosity
          }
        }
      },
      conversation: openaiOptions == null ? void 0 : openaiOptions.conversation,
      max_tool_calls: openaiOptions == null ? void 0 : openaiOptions.maxToolCalls,
      metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
      parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
      previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
      store,
      user: openaiOptions == null ? void 0 : openaiOptions.user,
      instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
      service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
      include,
      prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
      prompt_cache_retention: openaiOptions == null ? void 0 : openaiOptions.promptCacheRetention,
      safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
      top_logprobs: topLogprobs,
      truncation: openaiOptions == null ? void 0 : openaiOptions.truncation,
      ...isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
        reasoning: {
          ...(openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
            effort: openaiOptions.reasoningEffort
          },
          ...(openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
            summary: openaiOptions.reasoningSummary
          }
        }
      }
    };
    if (isReasoningModel) {
      if (!((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) === "none" && modelCapabilities.supportsNonReasoningParameters)) {
        if (baseArgs.temperature != null)
          baseArgs.temperature = void 0, warnings.push({
            type: "unsupported",
            feature: "temperature",
            details: "temperature is not supported for reasoning models"
          });
        if (baseArgs.top_p != null)
          baseArgs.top_p = void 0, warnings.push({
            type: "unsupported",
            feature: "topP",
            details: "topP is not supported for reasoning models"
          });
      }
    } else {
      if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null)
        warnings.push({
          type: "unsupported",
          feature: "reasoningEffort",
          details: "reasoningEffort is not supported for non-reasoning models"
        });
      if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null)
        warnings.push({
          type: "unsupported",
          feature: "reasoningSummary",
          details: "reasoningSummary is not supported for non-reasoning models"
        });
    }
    if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelCapabilities.supportsFlexProcessing)
      warnings.push({
        type: "unsupported",
        feature: "serviceTier",
        details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
      }), delete baseArgs.service_tier;
    if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelCapabilities.supportsPriorityProcessing)
      warnings.push({
        type: "unsupported",
        feature: "serviceTier",
        details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
      }), delete baseArgs.service_tier;
    let {
      tools: openaiTools2,
      toolChoice: openaiToolChoice,
      toolWarnings
    } = await prepareResponsesTools({
      tools,
      toolChoice
    });
    return {
      webSearchToolName,
      args: {
        ...baseArgs,
        tools: openaiTools2,
        tool_choice: openaiToolChoice
      },
      warnings: [...warnings, ...toolWarnings],
      store,
      toolNameMapping,
      providerOptionsName
    };
  }
  async doGenerate(options) {
    var _a21, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    let {
      args: body,
      warnings,
      webSearchToolName,
      toolNameMapping,
      providerOptionsName
    } = await this.getArgs(options), url2 = this.config.url({
      path: "/responses",
      modelId: this.modelId
    }), approvalRequestIdToDummyToolCallIdFromPrompt = extractApprovalRequestIdToToolCallIdMapping(options.prompt), {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: url2,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(openaiResponsesResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if (response.error)
      throw new APICallError({
        message: response.error.message,
        url: url2,
        requestBodyValues: body,
        statusCode: 400,
        responseHeaders,
        responseBody: rawResponse,
        isRetryable: !1
      });
    let content = [], logprobs = [], hasFunctionCall = !1;
    for (let part of response.output)
      switch (part.type) {
        case "reasoning": {
          if (part.summary.length === 0)
            part.summary.push({ type: "summary_text", text: "" });
          for (let summary of part.summary)
            content.push({
              type: "reasoning",
              text: summary.text,
              providerMetadata: {
                [providerOptionsName]: {
                  itemId: part.id,
                  reasoningEncryptedContent: (_a21 = part.encrypted_content) != null ? _a21 : null
                }
              }
            });
          break;
        }
        case "image_generation_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName("image_generation"),
            input: "{}",
            providerExecuted: !0
          }), content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName("image_generation"),
            result: {
              result: part.result
            }
          });
          break;
        }
        case "local_shell_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.call_id,
            toolName: toolNameMapping.toCustomToolName("local_shell"),
            input: JSON.stringify({
              action: part.action
            }),
            providerMetadata: {
              [providerOptionsName]: {
                itemId: part.id
              }
            }
          });
          break;
        }
        case "shell_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.call_id,
            toolName: toolNameMapping.toCustomToolName("shell"),
            input: JSON.stringify({
              action: {
                commands: part.action.commands
              }
            }),
            providerMetadata: {
              [providerOptionsName]: {
                itemId: part.id
              }
            }
          });
          break;
        }
        case "message": {
          for (let contentPart of part.content) {
            if (((_c = (_b16 = options.providerOptions) == null ? void 0 : _b16[providerOptionsName]) == null ? void 0 : _c.logprobs) && contentPart.logprobs)
              logprobs.push(contentPart.logprobs);
            let providerMetadata2 = {
              itemId: part.id,
              ...contentPart.annotations.length > 0 && {
                annotations: contentPart.annotations
              }
            };
            content.push({
              type: "text",
              text: contentPart.text,
              providerMetadata: {
                [providerOptionsName]: providerMetadata2
              }
            });
            for (let annotation of contentPart.annotations)
              if (annotation.type === "url_citation")
                content.push({
                  type: "source",
                  sourceType: "url",
                  id: (_f = (_e = (_d = this.config).generateId) == null ? void 0 : _e.call(_d)) != null ? _f : generateId(),
                  url: annotation.url,
                  title: annotation.title
                });
              else if (annotation.type === "file_citation")
                content.push({
                  type: "source",
                  sourceType: "document",
                  id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId(),
                  mediaType: "text/plain",
                  title: annotation.filename,
                  filename: annotation.filename,
                  providerMetadata: {
                    [providerOptionsName]: {
                      type: annotation.type,
                      fileId: annotation.file_id,
                      index: annotation.index
                    }
                  }
                });
              else if (annotation.type === "container_file_citation")
                content.push({
                  type: "source",
                  sourceType: "document",
                  id: (_l = (_k = (_j = this.config).generateId) == null ? void 0 : _k.call(_j)) != null ? _l : generateId(),
                  mediaType: "text/plain",
                  title: annotation.filename,
                  filename: annotation.filename,
                  providerMetadata: {
                    [providerOptionsName]: {
                      type: annotation.type,
                      fileId: annotation.file_id,
                      containerId: annotation.container_id
                    }
                  }
                });
              else if (annotation.type === "file_path")
                content.push({
                  type: "source",
                  sourceType: "document",
                  id: (_o = (_n = (_m = this.config).generateId) == null ? void 0 : _n.call(_m)) != null ? _o : generateId(),
                  mediaType: "application/octet-stream",
                  title: annotation.file_id,
                  filename: annotation.file_id,
                  providerMetadata: {
                    [providerOptionsName]: {
                      type: annotation.type,
                      fileId: annotation.file_id,
                      index: annotation.index
                    }
                  }
                });
          }
          break;
        }
        case "function_call": {
          hasFunctionCall = !0, content.push({
            type: "tool-call",
            toolCallId: part.call_id,
            toolName: part.name,
            input: part.arguments,
            providerMetadata: {
              [providerOptionsName]: {
                itemId: part.id
              }
            }
          });
          break;
        }
        case "web_search_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName(webSearchToolName != null ? webSearchToolName : "web_search"),
            input: JSON.stringify({}),
            providerExecuted: !0
          }), content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName(webSearchToolName != null ? webSearchToolName : "web_search"),
            result: mapWebSearchOutput(part.action)
          });
          break;
        }
        case "mcp_call": {
          let toolCallId = part.approval_request_id != null ? (_p = approvalRequestIdToDummyToolCallIdFromPrompt[part.approval_request_id]) != null ? _p : part.id : part.id, toolName = `mcp.${part.name}`;
          content.push({
            type: "tool-call",
            toolCallId,
            toolName,
            input: part.arguments,
            providerExecuted: !0,
            dynamic: !0
          }), content.push({
            type: "tool-result",
            toolCallId,
            toolName,
            result: {
              type: "call",
              serverLabel: part.server_label,
              name: part.name,
              arguments: part.arguments,
              ...part.output != null ? { output: part.output } : {},
              ...part.error != null ? { error: part.error } : {}
            },
            providerMetadata: {
              [providerOptionsName]: {
                itemId: part.id
              }
            }
          });
          break;
        }
        case "mcp_list_tools":
          break;
        case "mcp_approval_request": {
          let approvalRequestId = (_q = part.approval_request_id) != null ? _q : part.id, dummyToolCallId = (_t = (_s = (_r = this.config).generateId) == null ? void 0 : _s.call(_r)) != null ? _t : generateId(), toolName = `mcp.${part.name}`;
          content.push({
            type: "tool-call",
            toolCallId: dummyToolCallId,
            toolName,
            input: part.arguments,
            providerExecuted: !0,
            dynamic: !0
          }), content.push({
            type: "tool-approval-request",
            approvalId: approvalRequestId,
            toolCallId: dummyToolCallId
          });
          break;
        }
        case "computer_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName("computer_use"),
            input: "",
            providerExecuted: !0
          }), content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName("computer_use"),
            result: {
              type: "computer_use_tool_result",
              status: part.status || "completed"
            }
          });
          break;
        }
        case "file_search_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName("file_search"),
            input: "{}",
            providerExecuted: !0
          }), content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName("file_search"),
            result: {
              queries: part.queries,
              results: (_v = (_u = part.results) == null ? void 0 : _u.map((result) => ({
                attributes: result.attributes,
                fileId: result.file_id,
                filename: result.filename,
                score: result.score,
                text: result.text
              }))) != null ? _v : null
            }
          });
          break;
        }
        case "code_interpreter_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName("code_interpreter"),
            input: JSON.stringify({
              code: part.code,
              containerId: part.container_id
            }),
            providerExecuted: !0
          }), content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: toolNameMapping.toCustomToolName("code_interpreter"),
            result: {
              outputs: part.outputs
            }
          });
          break;
        }
        case "apply_patch_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.call_id,
            toolName: toolNameMapping.toCustomToolName("apply_patch"),
            input: JSON.stringify({
              callId: part.call_id,
              operation: part.operation
            }),
            providerMetadata: {
              [providerOptionsName]: {
                itemId: part.id
              }
            }
          });
          break;
        }
      }
    let providerMetadata = {
      [providerOptionsName]: {
        responseId: response.id,
        ...logprobs.length > 0 ? { logprobs } : {},
        ...typeof response.service_tier === "string" ? { serviceTier: response.service_tier } : {}
      }
    }, usage = response.usage;
    return {
      content,
      finishReason: {
        unified: mapOpenAIResponseFinishReason({
          finishReason: (_w = response.incomplete_details) == null ? void 0 : _w.reason,
          hasFunctionCall
        }),
        raw: (_y = (_x = response.incomplete_details) == null ? void 0 : _x.reason) != null ? _y : void 0
      },
      usage: convertOpenAIResponsesUsage(usage),
      request: { body },
      response: {
        id: response.id,
        timestamp: new Date(response.created_at * 1000),
        modelId: response.model,
        headers: responseHeaders,
        body: rawResponse
      },
      providerMetadata,
      warnings
    };
  }
  async doStream(options) {
    let {
      args: body,
      warnings,
      webSearchToolName,
      toolNameMapping,
      store,
      providerOptionsName
    } = await this.getArgs(options), { responseHeaders, value: response } = await postJsonToApi({
      url: this.config.url({
        path: "/responses",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: {
        ...body,
        stream: !0
      },
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(openaiResponsesChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), self2 = this, approvalRequestIdToDummyToolCallIdFromPrompt = extractApprovalRequestIdToToolCallIdMapping(options.prompt), approvalRequestIdToDummyToolCallIdFromStream = /* @__PURE__ */ new Map, finishReason = {
      unified: "other",
      raw: void 0
    }, usage = void 0, logprobs = [], responseId = null, ongoingToolCalls = {}, ongoingAnnotations = [], hasFunctionCall = !1, activeReasoning = {}, serviceTier;
    return {
      stream: response.pipeThrough(new TransformStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings });
        },
        transform(chunk, controller) {
          var _a21, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D;
          if (options.includeRawChunks)
            controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
          if (!chunk.success) {
            finishReason = { unified: "error", raw: void 0 }, controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          let value = chunk.value;
          if (isResponseOutputItemAddedChunk(value)) {
            if (value.item.type === "function_call")
              ongoingToolCalls[value.output_index] = {
                toolName: value.item.name,
                toolCallId: value.item.call_id
              }, controller.enqueue({
                type: "tool-input-start",
                id: value.item.call_id,
                toolName: value.item.name
              });
            else if (value.item.type === "web_search_call")
              ongoingToolCalls[value.output_index] = {
                toolName: toolNameMapping.toCustomToolName(webSearchToolName != null ? webSearchToolName : "web_search"),
                toolCallId: value.item.id
              }, controller.enqueue({
                type: "tool-input-start",
                id: value.item.id,
                toolName: toolNameMapping.toCustomToolName(webSearchToolName != null ? webSearchToolName : "web_search"),
                providerExecuted: !0
              }), controller.enqueue({
                type: "tool-input-end",
                id: value.item.id
              }), controller.enqueue({
                type: "tool-call",
                toolCallId: value.item.id,
                toolName: toolNameMapping.toCustomToolName(webSearchToolName != null ? webSearchToolName : "web_search"),
                input: JSON.stringify({}),
                providerExecuted: !0
              });
            else if (value.item.type === "computer_call")
              ongoingToolCalls[value.output_index] = {
                toolName: toolNameMapping.toCustomToolName("computer_use"),
                toolCallId: value.item.id
              }, controller.enqueue({
                type: "tool-input-start",
                id: value.item.id,
                toolName: toolNameMapping.toCustomToolName("computer_use"),
                providerExecuted: !0
              });
            else if (value.item.type === "code_interpreter_call")
              ongoingToolCalls[value.output_index] = {
                toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                toolCallId: value.item.id,
                codeInterpreter: {
                  containerId: value.item.container_id
                }
              }, controller.enqueue({
                type: "tool-input-start",
                id: value.item.id,
                toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                providerExecuted: !0
              }), controller.enqueue({
                type: "tool-input-delta",
                id: value.item.id,
                delta: `{"containerId":"${value.item.container_id}","code":"`
              });
            else if (value.item.type === "file_search_call")
              controller.enqueue({
                type: "tool-call",
                toolCallId: value.item.id,
                toolName: toolNameMapping.toCustomToolName("file_search"),
                input: "{}",
                providerExecuted: !0
              });
            else if (value.item.type === "image_generation_call")
              controller.enqueue({
                type: "tool-call",
                toolCallId: value.item.id,
                toolName: toolNameMapping.toCustomToolName("image_generation"),
                input: "{}",
                providerExecuted: !0
              });
            else if (value.item.type === "mcp_call" || value.item.type === "mcp_list_tools" || value.item.type === "mcp_approval_request")
              ;
            else if (value.item.type === "apply_patch_call") {
              let { call_id: callId, operation } = value.item;
              if (ongoingToolCalls[value.output_index] = {
                toolName: toolNameMapping.toCustomToolName("apply_patch"),
                toolCallId: callId,
                applyPatch: {
                  hasDiff: operation.type === "delete_file",
                  endEmitted: operation.type === "delete_file"
                }
              }, controller.enqueue({
                type: "tool-input-start",
                id: callId,
                toolName: toolNameMapping.toCustomToolName("apply_patch")
              }), operation.type === "delete_file") {
                let inputString = JSON.stringify({
                  callId,
                  operation
                });
                controller.enqueue({
                  type: "tool-input-delta",
                  id: callId,
                  delta: inputString
                }), controller.enqueue({
                  type: "tool-input-end",
                  id: callId
                });
              } else
                controller.enqueue({
                  type: "tool-input-delta",
                  id: callId,
                  delta: `{"callId":"${escapeJSONDelta(callId)}","operation":{"type":"${escapeJSONDelta(operation.type)}","path":"${escapeJSONDelta(operation.path)}","diff":"`
                });
            } else if (value.item.type === "shell_call")
              ongoingToolCalls[value.output_index] = {
                toolName: toolNameMapping.toCustomToolName("shell"),
                toolCallId: value.item.call_id
              };
            else if (value.item.type === "message")
              ongoingAnnotations.splice(0, ongoingAnnotations.length), controller.enqueue({
                type: "text-start",
                id: value.item.id,
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: value.item.id
                  }
                }
              });
            else if (isResponseOutputItemAddedChunk(value) && value.item.type === "reasoning")
              activeReasoning[value.item.id] = {
                encryptedContent: value.item.encrypted_content,
                summaryParts: { 0: "active" }
              }, controller.enqueue({
                type: "reasoning-start",
                id: `${value.item.id}:0`,
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: value.item.id,
                    reasoningEncryptedContent: (_a21 = value.item.encrypted_content) != null ? _a21 : null
                  }
                }
              });
          } else if (isResponseOutputItemDoneChunk(value)) {
            if (value.item.type === "message")
              controller.enqueue({
                type: "text-end",
                id: value.item.id,
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: value.item.id,
                    ...ongoingAnnotations.length > 0 && {
                      annotations: ongoingAnnotations
                    }
                  }
                }
              });
            else if (value.item.type === "function_call")
              ongoingToolCalls[value.output_index] = void 0, hasFunctionCall = !0, controller.enqueue({
                type: "tool-input-end",
                id: value.item.call_id
              }), controller.enqueue({
                type: "tool-call",
                toolCallId: value.item.call_id,
                toolName: value.item.name,
                input: value.item.arguments,
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: value.item.id
                  }
                }
              });
            else if (value.item.type === "web_search_call")
              ongoingToolCalls[value.output_index] = void 0, controller.enqueue({
                type: "tool-result",
                toolCallId: value.item.id,
                toolName: toolNameMapping.toCustomToolName(webSearchToolName != null ? webSearchToolName : "web_search"),
                result: mapWebSearchOutput(value.item.action)
              });
            else if (value.item.type === "computer_call")
              ongoingToolCalls[value.output_index] = void 0, controller.enqueue({
                type: "tool-input-end",
                id: value.item.id
              }), controller.enqueue({
                type: "tool-call",
                toolCallId: value.item.id,
                toolName: toolNameMapping.toCustomToolName("computer_use"),
                input: "",
                providerExecuted: !0
              }), controller.enqueue({
                type: "tool-result",
                toolCallId: value.item.id,
                toolName: toolNameMapping.toCustomToolName("computer_use"),
                result: {
                  type: "computer_use_tool_result",
                  status: value.item.status || "completed"
                }
              });
            else if (value.item.type === "file_search_call")
              ongoingToolCalls[value.output_index] = void 0, controller.enqueue({
                type: "tool-result",
                toolCallId: value.item.id,
                toolName: toolNameMapping.toCustomToolName("file_search"),
                result: {
                  queries: value.item.queries,
                  results: (_c = (_b16 = value.item.results) == null ? void 0 : _b16.map((result) => ({
                    attributes: result.attributes,
                    fileId: result.file_id,
                    filename: result.filename,
                    score: result.score,
                    text: result.text
                  }))) != null ? _c : null
                }
              });
            else if (value.item.type === "code_interpreter_call")
              ongoingToolCalls[value.output_index] = void 0, controller.enqueue({
                type: "tool-result",
                toolCallId: value.item.id,
                toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                result: {
                  outputs: value.item.outputs
                }
              });
            else if (value.item.type === "image_generation_call")
              controller.enqueue({
                type: "tool-result",
                toolCallId: value.item.id,
                toolName: toolNameMapping.toCustomToolName("image_generation"),
                result: {
                  result: value.item.result
                }
              });
            else if (value.item.type === "mcp_call") {
              ongoingToolCalls[value.output_index] = void 0;
              let approvalRequestId = (_d = value.item.approval_request_id) != null ? _d : void 0, aliasedToolCallId = approvalRequestId != null ? (_f = (_e = approvalRequestIdToDummyToolCallIdFromStream.get(approvalRequestId)) != null ? _e : approvalRequestIdToDummyToolCallIdFromPrompt[approvalRequestId]) != null ? _f : value.item.id : value.item.id, toolName = `mcp.${value.item.name}`;
              controller.enqueue({
                type: "tool-call",
                toolCallId: aliasedToolCallId,
                toolName,
                input: value.item.arguments,
                providerExecuted: !0,
                dynamic: !0
              }), controller.enqueue({
                type: "tool-result",
                toolCallId: aliasedToolCallId,
                toolName,
                result: {
                  type: "call",
                  serverLabel: value.item.server_label,
                  name: value.item.name,
                  arguments: value.item.arguments,
                  ...value.item.output != null ? { output: value.item.output } : {},
                  ...value.item.error != null ? { error: value.item.error } : {}
                },
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: value.item.id
                  }
                }
              });
            } else if (value.item.type === "mcp_list_tools")
              ongoingToolCalls[value.output_index] = void 0;
            else if (value.item.type === "apply_patch_call") {
              let toolCall = ongoingToolCalls[value.output_index];
              if ((toolCall == null ? void 0 : toolCall.applyPatch) && !toolCall.applyPatch.endEmitted && value.item.operation.type !== "delete_file") {
                if (!toolCall.applyPatch.hasDiff)
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.toolCallId,
                    delta: escapeJSONDelta(value.item.operation.diff)
                  });
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.toolCallId,
                  delta: '"}}'
                }), controller.enqueue({
                  type: "tool-input-end",
                  id: toolCall.toolCallId
                }), toolCall.applyPatch.endEmitted = !0;
              }
              if (toolCall && value.item.status === "completed")
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: toolCall.toolCallId,
                  toolName: toolNameMapping.toCustomToolName("apply_patch"),
                  input: JSON.stringify({
                    callId: value.item.call_id,
                    operation: value.item.operation
                  }),
                  providerMetadata: {
                    [providerOptionsName]: {
                      itemId: value.item.id
                    }
                  }
                });
              ongoingToolCalls[value.output_index] = void 0;
            } else if (value.item.type === "mcp_approval_request") {
              ongoingToolCalls[value.output_index] = void 0;
              let dummyToolCallId = (_i = (_h = (_g = self2.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId(), approvalRequestId = (_j = value.item.approval_request_id) != null ? _j : value.item.id;
              approvalRequestIdToDummyToolCallIdFromStream.set(approvalRequestId, dummyToolCallId);
              let toolName = `mcp.${value.item.name}`;
              controller.enqueue({
                type: "tool-call",
                toolCallId: dummyToolCallId,
                toolName,
                input: value.item.arguments,
                providerExecuted: !0,
                dynamic: !0
              }), controller.enqueue({
                type: "tool-approval-request",
                approvalId: approvalRequestId,
                toolCallId: dummyToolCallId
              });
            } else if (value.item.type === "local_shell_call")
              ongoingToolCalls[value.output_index] = void 0, controller.enqueue({
                type: "tool-call",
                toolCallId: value.item.call_id,
                toolName: toolNameMapping.toCustomToolName("local_shell"),
                input: JSON.stringify({
                  action: {
                    type: "exec",
                    command: value.item.action.command,
                    timeoutMs: value.item.action.timeout_ms,
                    user: value.item.action.user,
                    workingDirectory: value.item.action.working_directory,
                    env: value.item.action.env
                  }
                }),
                providerMetadata: {
                  [providerOptionsName]: { itemId: value.item.id }
                }
              });
            else if (value.item.type === "shell_call")
              ongoingToolCalls[value.output_index] = void 0, controller.enqueue({
                type: "tool-call",
                toolCallId: value.item.call_id,
                toolName: toolNameMapping.toCustomToolName("shell"),
                input: JSON.stringify({
                  action: {
                    commands: value.item.action.commands
                  }
                }),
                providerMetadata: {
                  [providerOptionsName]: { itemId: value.item.id }
                }
              });
            else if (value.item.type === "reasoning") {
              let activeReasoningPart = activeReasoning[value.item.id], summaryPartIndices = Object.entries(activeReasoningPart.summaryParts).filter(([_, status]) => status === "active" || status === "can-conclude").map(([summaryIndex]) => summaryIndex);
              for (let summaryIndex of summaryPartIndices)
                controller.enqueue({
                  type: "reasoning-end",
                  id: `${value.item.id}:${summaryIndex}`,
                  providerMetadata: {
                    [providerOptionsName]: {
                      itemId: value.item.id,
                      reasoningEncryptedContent: (_k = value.item.encrypted_content) != null ? _k : null
                    }
                  }
                });
              delete activeReasoning[value.item.id];
            }
          } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {
            let toolCall = ongoingToolCalls[value.output_index];
            if (toolCall != null)
              controller.enqueue({
                type: "tool-input-delta",
                id: toolCall.toolCallId,
                delta: value.delta
              });
          } else if (isResponseApplyPatchCallOperationDiffDeltaChunk(value)) {
            let toolCall = ongoingToolCalls[value.output_index];
            if (toolCall == null ? void 0 : toolCall.applyPatch)
              controller.enqueue({
                type: "tool-input-delta",
                id: toolCall.toolCallId,
                delta: escapeJSONDelta(value.delta)
              }), toolCall.applyPatch.hasDiff = !0;
          } else if (isResponseApplyPatchCallOperationDiffDoneChunk(value)) {
            let toolCall = ongoingToolCalls[value.output_index];
            if ((toolCall == null ? void 0 : toolCall.applyPatch) && !toolCall.applyPatch.endEmitted) {
              if (!toolCall.applyPatch.hasDiff)
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.toolCallId,
                  delta: escapeJSONDelta(value.diff)
                }), toolCall.applyPatch.hasDiff = !0;
              controller.enqueue({
                type: "tool-input-delta",
                id: toolCall.toolCallId,
                delta: '"}}'
              }), controller.enqueue({
                type: "tool-input-end",
                id: toolCall.toolCallId
              }), toolCall.applyPatch.endEmitted = !0;
            }
          } else if (isResponseImageGenerationCallPartialImageChunk(value))
            controller.enqueue({
              type: "tool-result",
              toolCallId: value.item_id,
              toolName: toolNameMapping.toCustomToolName("image_generation"),
              result: {
                result: value.partial_image_b64
              },
              preliminary: !0
            });
          else if (isResponseCodeInterpreterCallCodeDeltaChunk(value)) {
            let toolCall = ongoingToolCalls[value.output_index];
            if (toolCall != null)
              controller.enqueue({
                type: "tool-input-delta",
                id: toolCall.toolCallId,
                delta: escapeJSONDelta(value.delta)
              });
          } else if (isResponseCodeInterpreterCallCodeDoneChunk(value)) {
            let toolCall = ongoingToolCalls[value.output_index];
            if (toolCall != null)
              controller.enqueue({
                type: "tool-input-delta",
                id: toolCall.toolCallId,
                delta: '"}'
              }), controller.enqueue({
                type: "tool-input-end",
                id: toolCall.toolCallId
              }), controller.enqueue({
                type: "tool-call",
                toolCallId: toolCall.toolCallId,
                toolName: toolNameMapping.toCustomToolName("code_interpreter"),
                input: JSON.stringify({
                  code: value.code,
                  containerId: toolCall.codeInterpreter.containerId
                }),
                providerExecuted: !0
              });
          } else if (isResponseCreatedChunk(value))
            responseId = value.response.id, controller.enqueue({
              type: "response-metadata",
              id: value.response.id,
              timestamp: new Date(value.response.created_at * 1000),
              modelId: value.response.model
            });
          else if (isTextDeltaChunk(value)) {
            if (controller.enqueue({
              type: "text-delta",
              id: value.item_id,
              delta: value.delta
            }), ((_m = (_l = options.providerOptions) == null ? void 0 : _l[providerOptionsName]) == null ? void 0 : _m.logprobs) && value.logprobs)
              logprobs.push(value.logprobs);
          } else if (value.type === "response.reasoning_summary_part.added") {
            if (value.summary_index > 0) {
              let activeReasoningPart = activeReasoning[value.item_id];
              activeReasoningPart.summaryParts[value.summary_index] = "active";
              for (let summaryIndex of Object.keys(activeReasoningPart.summaryParts))
                if (activeReasoningPart.summaryParts[summaryIndex] === "can-conclude")
                  controller.enqueue({
                    type: "reasoning-end",
                    id: `${value.item_id}:${summaryIndex}`,
                    providerMetadata: {
                      [providerOptionsName]: {
                        itemId: value.item_id
                      }
                    }
                  }), activeReasoningPart.summaryParts[summaryIndex] = "concluded";
              controller.enqueue({
                type: "reasoning-start",
                id: `${value.item_id}:${value.summary_index}`,
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: value.item_id,
                    reasoningEncryptedContent: (_o = (_n = activeReasoning[value.item_id]) == null ? void 0 : _n.encryptedContent) != null ? _o : null
                  }
                }
              });
            }
          } else if (value.type === "response.reasoning_summary_text.delta")
            controller.enqueue({
              type: "reasoning-delta",
              id: `${value.item_id}:${value.summary_index}`,
              delta: value.delta,
              providerMetadata: {
                [providerOptionsName]: {
                  itemId: value.item_id
                }
              }
            });
          else if (value.type === "response.reasoning_summary_part.done")
            if (store)
              controller.enqueue({
                type: "reasoning-end",
                id: `${value.item_id}:${value.summary_index}`,
                providerMetadata: {
                  [providerOptionsName]: {
                    itemId: value.item_id
                  }
                }
              }), activeReasoning[value.item_id].summaryParts[value.summary_index] = "concluded";
            else
              activeReasoning[value.item_id].summaryParts[value.summary_index] = "can-conclude";
          else if (isResponseFinishedChunk(value)) {
            if (finishReason = {
              unified: mapOpenAIResponseFinishReason({
                finishReason: (_p = value.response.incomplete_details) == null ? void 0 : _p.reason,
                hasFunctionCall
              }),
              raw: (_r = (_q = value.response.incomplete_details) == null ? void 0 : _q.reason) != null ? _r : void 0
            }, usage = value.response.usage, typeof value.response.service_tier === "string")
              serviceTier = value.response.service_tier;
          } else if (isResponseAnnotationAddedChunk(value)) {
            if (ongoingAnnotations.push(value.annotation), value.annotation.type === "url_citation")
              controller.enqueue({
                type: "source",
                sourceType: "url",
                id: (_u = (_t = (_s = self2.config).generateId) == null ? void 0 : _t.call(_s)) != null ? _u : generateId(),
                url: value.annotation.url,
                title: value.annotation.title
              });
            else if (value.annotation.type === "file_citation")
              controller.enqueue({
                type: "source",
                sourceType: "document",
                id: (_x = (_w = (_v = self2.config).generateId) == null ? void 0 : _w.call(_v)) != null ? _x : generateId(),
                mediaType: "text/plain",
                title: value.annotation.filename,
                filename: value.annotation.filename,
                providerMetadata: {
                  [providerOptionsName]: {
                    type: value.annotation.type,
                    fileId: value.annotation.file_id,
                    index: value.annotation.index
                  }
                }
              });
            else if (value.annotation.type === "container_file_citation")
              controller.enqueue({
                type: "source",
                sourceType: "document",
                id: (_A = (_z = (_y = self2.config).generateId) == null ? void 0 : _z.call(_y)) != null ? _A : generateId(),
                mediaType: "text/plain",
                title: value.annotation.filename,
                filename: value.annotation.filename,
                providerMetadata: {
                  [providerOptionsName]: {
                    type: value.annotation.type,
                    fileId: value.annotation.file_id,
                    containerId: value.annotation.container_id
                  }
                }
              });
            else if (value.annotation.type === "file_path")
              controller.enqueue({
                type: "source",
                sourceType: "document",
                id: (_D = (_C = (_B = self2.config).generateId) == null ? void 0 : _C.call(_B)) != null ? _D : generateId(),
                mediaType: "application/octet-stream",
                title: value.annotation.file_id,
                filename: value.annotation.file_id,
                providerMetadata: {
                  [providerOptionsName]: {
                    type: value.annotation.type,
                    fileId: value.annotation.file_id,
                    index: value.annotation.index
                  }
                }
              });
          } else if (isErrorChunk(value))
            controller.enqueue({ type: "error", error: value });
        },
        flush(controller) {
          let providerMetadata = {
            [providerOptionsName]: {
              responseId,
              ...logprobs.length > 0 ? { logprobs } : {},
              ...serviceTier !== void 0 ? { serviceTier } : {}
            }
          };
          controller.enqueue({
            type: "finish",
            finishReason,
            usage: convertOpenAIResponsesUsage(usage),
            providerMetadata
          });
        }
      })),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function isTextDeltaChunk(chunk) {
  return chunk.type === "response.output_text.delta";
}
function isResponseOutputItemDoneChunk(chunk) {
  return chunk.type === "response.output_item.done";
}
function isResponseFinishedChunk(chunk) {
  return chunk.type === "response.completed" || chunk.type === "response.incomplete";
}
function isResponseCreatedChunk(chunk) {
  return chunk.type === "response.created";
}
function isResponseFunctionCallArgumentsDeltaChunk(chunk) {
  return chunk.type === "response.function_call_arguments.delta";
}
function isResponseImageGenerationCallPartialImageChunk(chunk) {
  return chunk.type === "response.image_generation_call.partial_image";
}
function isResponseCodeInterpreterCallCodeDeltaChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.delta";
}
function isResponseCodeInterpreterCallCodeDoneChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.done";
}
function isResponseApplyPatchCallOperationDiffDeltaChunk(chunk) {
  return chunk.type === "response.apply_patch_call_operation_diff.delta";
}
function isResponseApplyPatchCallOperationDiffDoneChunk(chunk) {
  return chunk.type === "response.apply_patch_call_operation_diff.done";
}
function isResponseOutputItemAddedChunk(chunk) {
  return chunk.type === "response.output_item.added";
}
function isResponseAnnotationAddedChunk(chunk) {
  return chunk.type === "response.output_text.annotation.added";
}
function isErrorChunk(chunk) {
  return chunk.type === "error";
}
function mapWebSearchOutput(action) {
  var _a21;
  switch (action.type) {
    case "search":
      return {
        action: { type: "search", query: (_a21 = action.query) != null ? _a21 : void 0 },
        ...action.sources != null && { sources: action.sources }
      };
    case "open_page":
      return { action: { type: "openPage", url: action.url } };
    case "find_in_page":
      return {
        action: {
          type: "findInPage",
          url: action.url,
          pattern: action.pattern
        }
      };
  }
}
function escapeJSONDelta(delta) {
  return JSON.stringify(delta).slice(1, -1);
}
var openaiSpeechProviderOptionsSchema = lazySchema(() => zodSchema(exports_external.object({
  instructions: exports_external.string().nullish(),
  speed: exports_external.number().min(0.25).max(4).default(1).nullish()
}))), OpenAISpeechModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId, this.config = config2, this.specificationVersion = "v3";
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    text: text2,
    voice = "alloy",
    outputFormat = "mp3",
    speed,
    instructions,
    language,
    providerOptions
  }) {
    let warnings = [], openAIOptions = await parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openaiSpeechProviderOptionsSchema
    }), requestBody = {
      model: this.modelId,
      input: text2,
      voice,
      response_format: "mp3",
      speed,
      instructions
    };
    if (outputFormat)
      if (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(outputFormat))
        requestBody.response_format = outputFormat;
      else
        warnings.push({
          type: "unsupported",
          feature: "outputFormat",
          details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
        });
    if (openAIOptions) {
      let speechModelOptions = {};
      for (let key in speechModelOptions) {
        let value = speechModelOptions[key];
        if (value !== void 0)
          requestBody[key] = value;
      }
    }
    if (language)
      warnings.push({
        type: "unsupported",
        feature: "language",
        details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
      });
    return {
      requestBody,
      warnings
    };
  }
  async doGenerate(options) {
    var _a21, _b16, _c;
    let currentDate = (_c = (_b16 = (_a21 = this.config._internal) == null ? void 0 : _a21.currentDate) == null ? void 0 : _b16.call(_a21)) != null ? _c : /* @__PURE__ */ new Date, { requestBody, warnings } = await this.getArgs(options), {
      value: audio,
      responseHeaders,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: this.config.url({
        path: "/audio/speech",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: requestBody,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createBinaryResponseHandler(),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    return {
      audio,
      warnings,
      request: {
        body: JSON.stringify(requestBody)
      },
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders,
        body: rawResponse
      }
    };
  }
}, openaiTranscriptionResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  text: exports_external.string(),
  language: exports_external.string().nullish(),
  duration: exports_external.number().nullish(),
  words: exports_external.array(exports_external.object({
    word: exports_external.string(),
    start: exports_external.number(),
    end: exports_external.number()
  })).nullish(),
  segments: exports_external.array(exports_external.object({
    id: exports_external.number(),
    seek: exports_external.number(),
    start: exports_external.number(),
    end: exports_external.number(),
    text: exports_external.string(),
    tokens: exports_external.array(exports_external.number()),
    temperature: exports_external.number(),
    avg_logprob: exports_external.number(),
    compression_ratio: exports_external.number(),
    no_speech_prob: exports_external.number()
  })).nullish()
}))), openAITranscriptionProviderOptions = lazySchema(() => zodSchema(exports_external.object({
  include: exports_external.array(exports_external.string()).optional(),
  language: exports_external.string().optional(),
  prompt: exports_external.string().optional(),
  temperature: exports_external.number().min(0).max(1).default(0).optional(),
  timestampGranularities: exports_external.array(exports_external.enum(["word", "segment"])).default(["segment"]).optional()
}))), languageMap = {
  afrikaans: "af",
  arabic: "ar",
  armenian: "hy",
  azerbaijani: "az",
  belarusian: "be",
  bosnian: "bs",
  bulgarian: "bg",
  catalan: "ca",
  chinese: "zh",
  croatian: "hr",
  czech: "cs",
  danish: "da",
  dutch: "nl",
  english: "en",
  estonian: "et",
  finnish: "fi",
  french: "fr",
  galician: "gl",
  german: "de",
  greek: "el",
  hebrew: "he",
  hindi: "hi",
  hungarian: "hu",
  icelandic: "is",
  indonesian: "id",
  italian: "it",
  japanese: "ja",
  kannada: "kn",
  kazakh: "kk",
  korean: "ko",
  latvian: "lv",
  lithuanian: "lt",
  macedonian: "mk",
  malay: "ms",
  marathi: "mr",
  maori: "mi",
  nepali: "ne",
  norwegian: "no",
  persian: "fa",
  polish: "pl",
  portuguese: "pt",
  romanian: "ro",
  russian: "ru",
  serbian: "sr",
  slovak: "sk",
  slovenian: "sl",
  spanish: "es",
  swahili: "sw",
  swedish: "sv",
  tagalog: "tl",
  tamil: "ta",
  thai: "th",
  turkish: "tr",
  ukrainian: "uk",
  urdu: "ur",
  vietnamese: "vi",
  welsh: "cy"
}, OpenAITranscriptionModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId, this.config = config2, this.specificationVersion = "v3";
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    audio,
    mediaType,
    providerOptions
  }) {
    let warnings = [], openAIOptions = await parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openAITranscriptionProviderOptions
    }), formData = new FormData, blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array(audio)]);
    formData.append("model", this.modelId);
    let fileExtension = mediaTypeToExtension(mediaType);
    if (formData.append("file", new File([blob], "audio", { type: mediaType }), `audio.${fileExtension}`), openAIOptions) {
      let transcriptionModelOptions = {
        include: openAIOptions.include,
        language: openAIOptions.language,
        prompt: openAIOptions.prompt,
        response_format: [
          "gpt-4o-transcribe",
          "gpt-4o-mini-transcribe"
        ].includes(this.modelId) ? "json" : "verbose_json",
        temperature: openAIOptions.temperature,
        timestamp_granularities: openAIOptions.timestampGranularities
      };
      for (let [key, value] of Object.entries(transcriptionModelOptions))
        if (value != null)
          if (Array.isArray(value))
            for (let item of value)
              formData.append(`${key}[]`, String(item));
          else
            formData.append(key, String(value));
    }
    return {
      formData,
      warnings
    };
  }
  async doGenerate(options) {
    var _a21, _b16, _c, _d, _e, _f, _g, _h;
    let currentDate = (_c = (_b16 = (_a21 = this.config._internal) == null ? void 0 : _a21.currentDate) == null ? void 0 : _b16.call(_a21)) != null ? _c : /* @__PURE__ */ new Date, { formData, warnings } = await this.getArgs(options), {
      value: response,
      responseHeaders,
      rawValue: rawResponse
    } = await postFormDataToApi({
      url: this.config.url({
        path: "/audio/transcriptions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      formData,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(openaiTranscriptionResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;
    return {
      text: response.text,
      segments: (_g = (_f = (_d = response.segments) == null ? void 0 : _d.map((segment) => ({
        text: segment.text,
        startSecond: segment.start,
        endSecond: segment.end
      }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word) => ({
        text: word.word,
        startSecond: word.start,
        endSecond: word.end
      }))) != null ? _g : [],
      language,
      durationInSeconds: (_h = response.duration) != null ? _h : void 0,
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders,
        body: rawResponse
      }
    };
  }
}, VERSION7 = "3.0.25";
function createOpenAI(options = {}) {
  var _a21, _b16;
  let baseURL = (_a21 = withoutTrailingSlash(loadOptionalSetting({
    settingValue: options.baseURL,
    environmentVariableName: "OPENAI_BASE_URL"
  }))) != null ? _a21 : "https://api.openai.com/v1", providerName = (_b16 = options.name) != null ? _b16 : "openai", getHeaders = () => withUserAgentSuffix({
    Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "OPENAI_API_KEY",
      description: "OpenAI"
    })}`,
    "OpenAI-Organization": options.organization,
    "OpenAI-Project": options.project,
    ...options.headers
  }, `ai-sdk/openai/${VERSION7}`), createChatModel = (modelId) => new OpenAIChatLanguageModel(modelId, {
    provider: `${providerName}.chat`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  }), createCompletionModel = (modelId) => new OpenAICompletionLanguageModel(modelId, {
    provider: `${providerName}.completion`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  }), createEmbeddingModel = (modelId) => new OpenAIEmbeddingModel(modelId, {
    provider: `${providerName}.embedding`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  }), createImageModel = (modelId) => new OpenAIImageModel(modelId, {
    provider: `${providerName}.image`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  }), createTranscriptionModel = (modelId) => new OpenAITranscriptionModel(modelId, {
    provider: `${providerName}.transcription`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  }), createSpeechModel = (modelId) => new OpenAISpeechModel(modelId, {
    provider: `${providerName}.speech`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  }), createLanguageModel = (modelId) => {
    if (new.target)
      throw Error("The OpenAI model function cannot be called with the new keyword.");
    return createResponsesModel(modelId);
  }, createResponsesModel = (modelId) => {
    return new OpenAIResponsesLanguageModel(modelId, {
      provider: `${providerName}.responses`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch,
      fileIdPrefixes: ["file-"]
    });
  }, provider = function(modelId) {
    return createLanguageModel(modelId);
  };
  return provider.specificationVersion = "v3", provider.languageModel = createLanguageModel, provider.chat = createChatModel, provider.completion = createCompletionModel, provider.responses = createResponsesModel, provider.embedding = createEmbeddingModel, provider.embeddingModel = createEmbeddingModel, provider.textEmbedding = createEmbeddingModel, provider.textEmbeddingModel = createEmbeddingModel, provider.image = createImageModel, provider.imageModel = createImageModel, provider.transcription = createTranscriptionModel, provider.transcriptionModel = createTranscriptionModel, provider.speech = createSpeechModel, provider.speechModel = createSpeechModel, provider.tools = openaiTools, provider;
}
var openai = createOpenAI();
// node_modules/@ai-sdk/anthropic/dist/index.mjs
var VERSION8 = "3.0.35", anthropicErrorDataSchema = lazySchema(() => zodSchema(exports_external.object({
  type: exports_external.literal("error"),
  error: exports_external.object({
    type: exports_external.string(),
    message: exports_external.string()
  })
}))), anthropicFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: anthropicErrorDataSchema,
  errorToMessage: (data) => data.error.message
}), anthropicMessagesResponseSchema = lazySchema(() => zodSchema(exports_external.object({
  type: exports_external.literal("message"),
  id: exports_external.string().nullish(),
  model: exports_external.string().nullish(),
  content: exports_external.array(exports_external.discriminatedUnion("type", [
    exports_external.object({
      type: exports_external.literal("text"),
      text: exports_external.string(),
      citations: exports_external.array(exports_external.discriminatedUnion("type", [
        exports_external.object({
          type: exports_external.literal("web_search_result_location"),
          cited_text: exports_external.string(),
          url: exports_external.string(),
          title: exports_external.string(),
          encrypted_index: exports_external.string()
        }),
        exports_external.object({
          type: exports_external.literal("page_location"),
          cited_text: exports_external.string(),
          document_index: exports_external.number(),
          document_title: exports_external.string().nullable(),
          start_page_number: exports_external.number(),
          end_page_number: exports_external.number()
        }),
        exports_external.object({
          type: exports_external.literal("char_location"),
          cited_text: exports_external.string(),
          document_index: exports_external.number(),
          document_title: exports_external.string().nullable(),
          start_char_index: exports_external.number(),
          end_char_index: exports_external.number()
        })
      ])).optional()
    }),
    exports_external.object({
      type: exports_external.literal("thinking"),
      thinking: exports_external.string(),
      signature: exports_external.string()
    }),
    exports_external.object({
      type: exports_external.literal("redacted_thinking"),
      data: exports_external.string()
    }),
    exports_external.object({
      type: exports_external.literal("tool_use"),
      id: exports_external.string(),
      name: exports_external.string(),
      input: exports_external.unknown(),
      caller: exports_external.union([
        exports_external.object({
          type: exports_external.literal("code_execution_20250825"),
          tool_id: exports_external.string()
        }),
        exports_external.object({
          type: exports_external.literal("direct")
        })
      ]).optional()
    }),
    exports_external.object({
      type: exports_external.literal("server_tool_use"),
      id: exports_external.string(),
      name: exports_external.string(),
      input: exports_external.record(exports_external.string(), exports_external.unknown()).nullish()
    }),
    exports_external.object({
      type: exports_external.literal("mcp_tool_use"),
      id: exports_external.string(),
      name: exports_external.string(),
      input: exports_external.unknown(),
      server_name: exports_external.string()
    }),
    exports_external.object({
      type: exports_external.literal("mcp_tool_result"),
      tool_use_id: exports_external.string(),
      is_error: exports_external.boolean(),
      content: exports_external.array(exports_external.union([
        exports_external.string(),
        exports_external.object({ type: exports_external.literal("text"), text: exports_external.string() })
      ]))
    }),
    exports_external.object({
      type: exports_external.literal("web_fetch_tool_result"),
      tool_use_id: exports_external.string(),
      content: exports_external.union([
        exports_external.object({
          type: exports_external.literal("web_fetch_result"),
          url: exports_external.string(),
          retrieved_at: exports_external.string(),
          content: exports_external.object({
            type: exports_external.literal("document"),
            title: exports_external.string().nullable(),
            citations: exports_external.object({ enabled: exports_external.boolean() }).optional(),
            source: exports_external.union([
              exports_external.object({
                type: exports_external.literal("base64"),
                media_type: exports_external.literal("application/pdf"),
                data: exports_external.string()
              }),
              exports_external.object({
                type: exports_external.literal("text"),
                media_type: exports_external.literal("text/plain"),
                data: exports_external.string()
              })
            ])
          })
        }),
        exports_external.object({
          type: exports_external.literal("web_fetch_tool_result_error"),
          error_code: exports_external.string()
        })
      ])
    }),
    exports_external.object({
      type: exports_external.literal("web_search_tool_result"),
      tool_use_id: exports_external.string(),
      content: exports_external.union([
        exports_external.array(exports_external.object({
          type: exports_external.literal("web_search_result"),
          url: exports_external.string(),
          title: exports_external.string(),
          encrypted_content: exports_external.string(),
          page_age: exports_external.string().nullish()
        })),
        exports_external.object({
          type: exports_external.literal("web_search_tool_result_error"),
          error_code: exports_external.string()
        })
      ])
    }),
    exports_external.object({
      type: exports_external.literal("code_execution_tool_result"),
      tool_use_id: exports_external.string(),
      content: exports_external.union([
        exports_external.object({
          type: exports_external.literal("code_execution_result"),
          stdout: exports_external.string(),
          stderr: exports_external.string(),
          return_code: exports_external.number(),
          content: exports_external.array(exports_external.object({
            type: exports_external.literal("code_execution_output"),
            file_id: exports_external.string()
          })).optional().default([])
        }),
        exports_external.object({
          type: exports_external.literal("code_execution_tool_result_error"),
          error_code: exports_external.string()
        })
      ])
    }),
    exports_external.object({
      type: exports_external.literal("bash_code_execution_tool_result"),
      tool_use_id: exports_external.string(),
      content: exports_external.discriminatedUnion("type", [
        exports_external.object({
          type: exports_external.literal("bash_code_execution_result"),
          content: exports_external.array(exports_external.object({
            type: exports_external.literal("bash_code_execution_output"),
            file_id: exports_external.string()
          })),
          stdout: exports_external.string(),
          stderr: exports_external.string(),
          return_code: exports_external.number()
        }),
        exports_external.object({
          type: exports_external.literal("bash_code_execution_tool_result_error"),
          error_code: exports_external.string()
        })
      ])
    }),
    exports_external.object({
      type: exports_external.literal("text_editor_code_execution_tool_result"),
      tool_use_id: exports_external.string(),
      content: exports_external.discriminatedUnion("type", [
        exports_external.object({
          type: exports_external.literal("text_editor_code_execution_tool_result_error"),
          error_code: exports_external.string()
        }),
        exports_external.object({
          type: exports_external.literal("text_editor_code_execution_view_result"),
          content: exports_external.string(),
          file_type: exports_external.string(),
          num_lines: exports_external.number().nullable(),
          start_line: exports_external.number().nullable(),
          total_lines: exports_external.number().nullable()
        }),
        exports_external.object({
          type: exports_external.literal("text_editor_code_execution_create_result"),
          is_file_update: exports_external.boolean()
        }),
        exports_external.object({
          type: exports_external.literal("text_editor_code_execution_str_replace_result"),
          lines: exports_external.array(exports_external.string()).nullable(),
          new_lines: exports_external.number().nullable(),
          new_start: exports_external.number().nullable(),
          old_lines: exports_external.number().nullable(),
          old_start: exports_external.number().nullable()
        })
      ])
    }),
    exports_external.object({
      type: exports_external.literal("tool_search_tool_result"),
      tool_use_id: exports_external.string(),
      content: exports_external.union([
        exports_external.object({
          type: exports_external.literal("tool_search_tool_search_result"),
          tool_references: exports_external.array(exports_external.object({
            type: exports_external.literal("tool_reference"),
            tool_name: exports_external.string()
          }))
        }),
        exports_external.object({
          type: exports_external.literal("tool_search_tool_result_error"),
          error_code: exports_external.string()
        })
      ])
    })
  ])),
  stop_reason: exports_external.string().nullish(),
  stop_sequence: exports_external.string().nullish(),
  usage: exports_external.looseObject({
    input_tokens: exports_external.number(),
    output_tokens: exports_external.number(),
    cache_creation_input_tokens: exports_external.number().nullish(),
    cache_read_input_tokens: exports_external.number().nullish()
  }),
  container: exports_external.object({
    expires_at: exports_external.string(),
    id: exports_external.string(),
    skills: exports_external.array(exports_external.object({
      type: exports_external.union([exports_external.literal("anthropic"), exports_external.literal("custom")]),
      skill_id: exports_external.string(),
      version: exports_external.string()
    })).nullish()
  }).nullish(),
  context_management: exports_external.object({
    applied_edits: exports_external.array(exports_external.union([
      exports_external.object({
        type: exports_external.literal("clear_tool_uses_20250919"),
        cleared_tool_uses: exports_external.number(),
        cleared_input_tokens: exports_external.number()
      }),
      exports_external.object({
        type: exports_external.literal("clear_thinking_20251015"),
        cleared_thinking_turns: exports_external.number(),
        cleared_input_tokens: exports_external.number()
      })
    ]))
  }).nullish()
}))), anthropicMessagesChunkSchema = lazySchema(() => zodSchema(exports_external.discriminatedUnion("type", [
  exports_external.object({
    type: exports_external.literal("message_start"),
    message: exports_external.object({
      id: exports_external.string().nullish(),
      model: exports_external.string().nullish(),
      role: exports_external.string().nullish(),
      usage: exports_external.looseObject({
        input_tokens: exports_external.number(),
        cache_creation_input_tokens: exports_external.number().nullish(),
        cache_read_input_tokens: exports_external.number().nullish()
      }),
      content: exports_external.array(exports_external.discriminatedUnion("type", [
        exports_external.object({
          type: exports_external.literal("tool_use"),
          id: exports_external.string(),
          name: exports_external.string(),
          input: exports_external.unknown(),
          caller: exports_external.union([
            exports_external.object({
              type: exports_external.literal("code_execution_20250825"),
              tool_id: exports_external.string()
            }),
            exports_external.object({
              type: exports_external.literal("direct")
            })
          ]).optional()
        })
      ])).nullish(),
      stop_reason: exports_external.string().nullish(),
      container: exports_external.object({
        expires_at: exports_external.string(),
        id: exports_external.string()
      }).nullish()
    })
  }),
  exports_external.object({
    type: exports_external.literal("content_block_start"),
    index: exports_external.number(),
    content_block: exports_external.discriminatedUnion("type", [
      exports_external.object({
        type: exports_external.literal("text"),
        text: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("thinking"),
        thinking: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("tool_use"),
        id: exports_external.string(),
        name: exports_external.string(),
        input: exports_external.record(exports_external.string(), exports_external.unknown()).optional(),
        caller: exports_external.union([
          exports_external.object({
            type: exports_external.literal("code_execution_20250825"),
            tool_id: exports_external.string()
          }),
          exports_external.object({
            type: exports_external.literal("direct")
          })
        ]).optional()
      }),
      exports_external.object({
        type: exports_external.literal("redacted_thinking"),
        data: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("server_tool_use"),
        id: exports_external.string(),
        name: exports_external.string(),
        input: exports_external.record(exports_external.string(), exports_external.unknown()).nullish()
      }),
      exports_external.object({
        type: exports_external.literal("mcp_tool_use"),
        id: exports_external.string(),
        name: exports_external.string(),
        input: exports_external.unknown(),
        server_name: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("mcp_tool_result"),
        tool_use_id: exports_external.string(),
        is_error: exports_external.boolean(),
        content: exports_external.array(exports_external.union([
          exports_external.string(),
          exports_external.object({ type: exports_external.literal("text"), text: exports_external.string() })
        ]))
      }),
      exports_external.object({
        type: exports_external.literal("web_fetch_tool_result"),
        tool_use_id: exports_external.string(),
        content: exports_external.union([
          exports_external.object({
            type: exports_external.literal("web_fetch_result"),
            url: exports_external.string(),
            retrieved_at: exports_external.string(),
            content: exports_external.object({
              type: exports_external.literal("document"),
              title: exports_external.string().nullable(),
              citations: exports_external.object({ enabled: exports_external.boolean() }).optional(),
              source: exports_external.union([
                exports_external.object({
                  type: exports_external.literal("base64"),
                  media_type: exports_external.literal("application/pdf"),
                  data: exports_external.string()
                }),
                exports_external.object({
                  type: exports_external.literal("text"),
                  media_type: exports_external.literal("text/plain"),
                  data: exports_external.string()
                })
              ])
            })
          }),
          exports_external.object({
            type: exports_external.literal("web_fetch_tool_result_error"),
            error_code: exports_external.string()
          })
        ])
      }),
      exports_external.object({
        type: exports_external.literal("web_search_tool_result"),
        tool_use_id: exports_external.string(),
        content: exports_external.union([
          exports_external.array(exports_external.object({
            type: exports_external.literal("web_search_result"),
            url: exports_external.string(),
            title: exports_external.string(),
            encrypted_content: exports_external.string(),
            page_age: exports_external.string().nullish()
          })),
          exports_external.object({
            type: exports_external.literal("web_search_tool_result_error"),
            error_code: exports_external.string()
          })
        ])
      }),
      exports_external.object({
        type: exports_external.literal("code_execution_tool_result"),
        tool_use_id: exports_external.string(),
        content: exports_external.union([
          exports_external.object({
            type: exports_external.literal("code_execution_result"),
            stdout: exports_external.string(),
            stderr: exports_external.string(),
            return_code: exports_external.number(),
            content: exports_external.array(exports_external.object({
              type: exports_external.literal("code_execution_output"),
              file_id: exports_external.string()
            })).optional().default([])
          }),
          exports_external.object({
            type: exports_external.literal("code_execution_tool_result_error"),
            error_code: exports_external.string()
          })
        ])
      }),
      exports_external.object({
        type: exports_external.literal("bash_code_execution_tool_result"),
        tool_use_id: exports_external.string(),
        content: exports_external.discriminatedUnion("type", [
          exports_external.object({
            type: exports_external.literal("bash_code_execution_result"),
            content: exports_external.array(exports_external.object({
              type: exports_external.literal("bash_code_execution_output"),
              file_id: exports_external.string()
            })),
            stdout: exports_external.string(),
            stderr: exports_external.string(),
            return_code: exports_external.number()
          }),
          exports_external.object({
            type: exports_external.literal("bash_code_execution_tool_result_error"),
            error_code: exports_external.string()
          })
        ])
      }),
      exports_external.object({
        type: exports_external.literal("text_editor_code_execution_tool_result"),
        tool_use_id: exports_external.string(),
        content: exports_external.discriminatedUnion("type", [
          exports_external.object({
            type: exports_external.literal("text_editor_code_execution_tool_result_error"),
            error_code: exports_external.string()
          }),
          exports_external.object({
            type: exports_external.literal("text_editor_code_execution_view_result"),
            content: exports_external.string(),
            file_type: exports_external.string(),
            num_lines: exports_external.number().nullable(),
            start_line: exports_external.number().nullable(),
            total_lines: exports_external.number().nullable()
          }),
          exports_external.object({
            type: exports_external.literal("text_editor_code_execution_create_result"),
            is_file_update: exports_external.boolean()
          }),
          exports_external.object({
            type: exports_external.literal("text_editor_code_execution_str_replace_result"),
            lines: exports_external.array(exports_external.string()).nullable(),
            new_lines: exports_external.number().nullable(),
            new_start: exports_external.number().nullable(),
            old_lines: exports_external.number().nullable(),
            old_start: exports_external.number().nullable()
          })
        ])
      }),
      exports_external.object({
        type: exports_external.literal("tool_search_tool_result"),
        tool_use_id: exports_external.string(),
        content: exports_external.union([
          exports_external.object({
            type: exports_external.literal("tool_search_tool_search_result"),
            tool_references: exports_external.array(exports_external.object({
              type: exports_external.literal("tool_reference"),
              tool_name: exports_external.string()
            }))
          }),
          exports_external.object({
            type: exports_external.literal("tool_search_tool_result_error"),
            error_code: exports_external.string()
          })
        ])
      })
    ])
  }),
  exports_external.object({
    type: exports_external.literal("content_block_delta"),
    index: exports_external.number(),
    delta: exports_external.discriminatedUnion("type", [
      exports_external.object({
        type: exports_external.literal("input_json_delta"),
        partial_json: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("text_delta"),
        text: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("thinking_delta"),
        thinking: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("signature_delta"),
        signature: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("citations_delta"),
        citation: exports_external.discriminatedUnion("type", [
          exports_external.object({
            type: exports_external.literal("web_search_result_location"),
            cited_text: exports_external.string(),
            url: exports_external.string(),
            title: exports_external.string(),
            encrypted_index: exports_external.string()
          }),
          exports_external.object({
            type: exports_external.literal("page_location"),
            cited_text: exports_external.string(),
            document_index: exports_external.number(),
            document_title: exports_external.string().nullable(),
            start_page_number: exports_external.number(),
            end_page_number: exports_external.number()
          }),
          exports_external.object({
            type: exports_external.literal("char_location"),
            cited_text: exports_external.string(),
            document_index: exports_external.number(),
            document_title: exports_external.string().nullable(),
            start_char_index: exports_external.number(),
            end_char_index: exports_external.number()
          })
        ])
      })
    ])
  }),
  exports_external.object({
    type: exports_external.literal("content_block_stop"),
    index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("error"),
    error: exports_external.object({
      type: exports_external.string(),
      message: exports_external.string()
    })
  }),
  exports_external.object({
    type: exports_external.literal("message_delta"),
    delta: exports_external.object({
      stop_reason: exports_external.string().nullish(),
      stop_sequence: exports_external.string().nullish(),
      container: exports_external.object({
        expires_at: exports_external.string(),
        id: exports_external.string(),
        skills: exports_external.array(exports_external.object({
          type: exports_external.union([
            exports_external.literal("anthropic"),
            exports_external.literal("custom")
          ]),
          skill_id: exports_external.string(),
          version: exports_external.string()
        })).nullish()
      }).nullish()
    }),
    usage: exports_external.looseObject({
      input_tokens: exports_external.number().nullish(),
      output_tokens: exports_external.number(),
      cache_creation_input_tokens: exports_external.number().nullish(),
      cache_read_input_tokens: exports_external.number().nullish()
    }),
    context_management: exports_external.object({
      applied_edits: exports_external.array(exports_external.union([
        exports_external.object({
          type: exports_external.literal("clear_tool_uses_20250919"),
          cleared_tool_uses: exports_external.number(),
          cleared_input_tokens: exports_external.number()
        }),
        exports_external.object({
          type: exports_external.literal("clear_thinking_20251015"),
          cleared_thinking_turns: exports_external.number(),
          cleared_input_tokens: exports_external.number()
        })
      ]))
    }).nullish()
  }),
  exports_external.object({
    type: exports_external.literal("message_stop")
  }),
  exports_external.object({
    type: exports_external.literal("ping")
  })
]))), anthropicReasoningMetadataSchema = lazySchema(() => zodSchema(exports_external.object({
  signature: exports_external.string().optional(),
  redactedData: exports_external.string().optional()
}))), anthropicFilePartProviderOptions = exports_external.object({
  citations: exports_external.object({
    enabled: exports_external.boolean()
  }).optional(),
  title: exports_external.string().optional(),
  context: exports_external.string().optional()
}), anthropicProviderOptions = exports_external.object({
  sendReasoning: exports_external.boolean().optional(),
  structuredOutputMode: exports_external.enum(["outputFormat", "jsonTool", "auto"]).optional(),
  thinking: exports_external.object({
    type: exports_external.union([exports_external.literal("enabled"), exports_external.literal("disabled")]),
    budgetTokens: exports_external.number().optional()
  }).optional(),
  disableParallelToolUse: exports_external.boolean().optional(),
  cacheControl: exports_external.object({
    type: exports_external.literal("ephemeral"),
    ttl: exports_external.union([exports_external.literal("5m"), exports_external.literal("1h")]).optional()
  }).optional(),
  mcpServers: exports_external.array(exports_external.object({
    type: exports_external.literal("url"),
    name: exports_external.string(),
    url: exports_external.string(),
    authorizationToken: exports_external.string().nullish(),
    toolConfiguration: exports_external.object({
      enabled: exports_external.boolean().nullish(),
      allowedTools: exports_external.array(exports_external.string()).nullish()
    }).nullish()
  })).optional(),
  container: exports_external.object({
    id: exports_external.string().optional(),
    skills: exports_external.array(exports_external.object({
      type: exports_external.union([exports_external.literal("anthropic"), exports_external.literal("custom")]),
      skillId: exports_external.string(),
      version: exports_external.string().optional()
    })).optional()
  }).optional(),
  toolStreaming: exports_external.boolean().optional(),
  effort: exports_external.enum(["low", "medium", "high"]).optional(),
  contextManagement: exports_external.object({
    edits: exports_external.array(exports_external.discriminatedUnion("type", [
      exports_external.object({
        type: exports_external.literal("clear_tool_uses_20250919"),
        trigger: exports_external.discriminatedUnion("type", [
          exports_external.object({
            type: exports_external.literal("input_tokens"),
            value: exports_external.number()
          }),
          exports_external.object({
            type: exports_external.literal("tool_uses"),
            value: exports_external.number()
          })
        ]).optional(),
        keep: exports_external.object({
          type: exports_external.literal("tool_uses"),
          value: exports_external.number()
        }).optional(),
        clearAtLeast: exports_external.object({
          type: exports_external.literal("input_tokens"),
          value: exports_external.number()
        }).optional(),
        clearToolInputs: exports_external.boolean().optional(),
        excludeTools: exports_external.array(exports_external.string()).optional()
      }),
      exports_external.object({
        type: exports_external.literal("clear_thinking_20251015"),
        keep: exports_external.union([
          exports_external.literal("all"),
          exports_external.object({
            type: exports_external.literal("thinking_turns"),
            value: exports_external.number()
          })
        ]).optional()
      })
    ]))
  }).optional()
}), MAX_CACHE_BREAKPOINTS = 4;
function getCacheControl(providerMetadata) {
  var _a21;
  let anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  return (_a21 = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a21 : anthropic2 == null ? void 0 : anthropic2.cache_control;
}
var CacheControlValidator = class {
  constructor() {
    this.breakpointCount = 0, this.warnings = [];
  }
  getCacheControl(providerMetadata, context2) {
    let cacheControlValue = getCacheControl(providerMetadata);
    if (!cacheControlValue)
      return;
    if (!context2.canCache) {
      this.warnings.push({
        type: "unsupported",
        feature: "cache_control on non-cacheable context",
        details: `cache_control cannot be set on ${context2.type}. It will be ignored.`
      });
      return;
    }
    if (this.breakpointCount++, this.breakpointCount > MAX_CACHE_BREAKPOINTS) {
      this.warnings.push({
        type: "unsupported",
        feature: "cacheControl breakpoint limit",
        details: `Maximum ${MAX_CACHE_BREAKPOINTS} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
      });
      return;
    }
    return cacheControlValue;
  }
  getWarnings() {
    return this.warnings;
  }
}, textEditor_20250728ArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  maxCharacters: exports_external.number().optional()
}))), textEditor_20250728InputSchema = lazySchema(() => zodSchema(exports_external.object({
  command: exports_external.enum(["view", "create", "str_replace", "insert"]),
  path: exports_external.string(),
  file_text: exports_external.string().optional(),
  insert_line: exports_external.number().int().optional(),
  new_str: exports_external.string().optional(),
  insert_text: exports_external.string().optional(),
  old_str: exports_external.string().optional(),
  view_range: exports_external.array(exports_external.number().int()).optional()
}))), factory = createProviderToolFactory({
  id: "anthropic.text_editor_20250728",
  inputSchema: textEditor_20250728InputSchema
}), textEditor_20250728 = (args = {}) => {
  return factory(args);
}, webSearch_20250305ArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  maxUses: exports_external.number().optional(),
  allowedDomains: exports_external.array(exports_external.string()).optional(),
  blockedDomains: exports_external.array(exports_external.string()).optional(),
  userLocation: exports_external.object({
    type: exports_external.literal("approximate"),
    city: exports_external.string().optional(),
    region: exports_external.string().optional(),
    country: exports_external.string().optional(),
    timezone: exports_external.string().optional()
  }).optional()
}))), webSearch_20250305OutputSchema = lazySchema(() => zodSchema(exports_external.array(exports_external.object({
  url: exports_external.string(),
  title: exports_external.string().nullable(),
  pageAge: exports_external.string().nullable(),
  encryptedContent: exports_external.string(),
  type: exports_external.literal("web_search_result")
})))), webSearch_20250305InputSchema = lazySchema(() => zodSchema(exports_external.object({
  query: exports_external.string()
}))), factory2 = createProviderToolFactoryWithOutputSchema({
  id: "anthropic.web_search_20250305",
  inputSchema: webSearch_20250305InputSchema,
  outputSchema: webSearch_20250305OutputSchema,
  supportsDeferredResults: !0
}), webSearch_20250305 = (args = {}) => {
  return factory2(args);
}, webFetch_20250910ArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  maxUses: exports_external.number().optional(),
  allowedDomains: exports_external.array(exports_external.string()).optional(),
  blockedDomains: exports_external.array(exports_external.string()).optional(),
  citations: exports_external.object({ enabled: exports_external.boolean() }).optional(),
  maxContentTokens: exports_external.number().optional()
}))), webFetch_20250910OutputSchema = lazySchema(() => zodSchema(exports_external.object({
  type: exports_external.literal("web_fetch_result"),
  url: exports_external.string(),
  content: exports_external.object({
    type: exports_external.literal("document"),
    title: exports_external.string().nullable(),
    citations: exports_external.object({ enabled: exports_external.boolean() }).optional(),
    source: exports_external.union([
      exports_external.object({
        type: exports_external.literal("base64"),
        mediaType: exports_external.literal("application/pdf"),
        data: exports_external.string()
      }),
      exports_external.object({
        type: exports_external.literal("text"),
        mediaType: exports_external.literal("text/plain"),
        data: exports_external.string()
      })
    ])
  }),
  retrievedAt: exports_external.string().nullable()
}))), webFetch_20250910InputSchema = lazySchema(() => zodSchema(exports_external.object({
  url: exports_external.string()
}))), factory3 = createProviderToolFactoryWithOutputSchema({
  id: "anthropic.web_fetch_20250910",
  inputSchema: webFetch_20250910InputSchema,
  outputSchema: webFetch_20250910OutputSchema,
  supportsDeferredResults: !0
}), webFetch_20250910 = (args = {}) => {
  return factory3(args);
};
async function prepareTools3({
  tools,
  toolChoice,
  disableParallelToolUse,
  cacheControlValidator,
  supportsStructuredOutput
}) {
  var _a21;
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  let toolWarnings = [], betas = /* @__PURE__ */ new Set, validator = cacheControlValidator || new CacheControlValidator;
  if (tools == null)
    return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
  let anthropicTools2 = [];
  for (let tool2 of tools)
    switch (tool2.type) {
      case "function": {
        let cacheControl = validator.getCacheControl(tool2.providerOptions, {
          type: "tool definition",
          canCache: !0
        }), anthropicOptions = (_a21 = tool2.providerOptions) == null ? void 0 : _a21.anthropic, deferLoading = anthropicOptions == null ? void 0 : anthropicOptions.deferLoading, allowedCallers = anthropicOptions == null ? void 0 : anthropicOptions.allowedCallers;
        if (anthropicTools2.push({
          name: tool2.name,
          description: tool2.description,
          input_schema: tool2.inputSchema,
          cache_control: cacheControl,
          ...supportsStructuredOutput === !0 && tool2.strict != null ? { strict: tool2.strict } : {},
          ...deferLoading != null ? { defer_loading: deferLoading } : {},
          ...allowedCallers != null ? { allowed_callers: allowedCallers } : {},
          ...tool2.inputExamples != null ? {
            input_examples: tool2.inputExamples.map((example) => example.input)
          } : {}
        }), supportsStructuredOutput === !0)
          betas.add("structured-outputs-2025-11-13");
        if (tool2.inputExamples != null || allowedCallers != null)
          betas.add("advanced-tool-use-2025-11-20");
        break;
      }
      case "provider": {
        switch (tool2.id) {
          case "anthropic.code_execution_20250522": {
            betas.add("code-execution-2025-05-22"), anthropicTools2.push({
              type: "code_execution_20250522",
              name: "code_execution",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.code_execution_20250825": {
            betas.add("code-execution-2025-08-25"), anthropicTools2.push({
              type: "code_execution_20250825",
              name: "code_execution"
            });
            break;
          }
          case "anthropic.computer_20250124": {
            betas.add("computer-use-2025-01-24"), anthropicTools2.push({
              name: "computer",
              type: "computer_20250124",
              display_width_px: tool2.args.displayWidthPx,
              display_height_px: tool2.args.displayHeightPx,
              display_number: tool2.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20251124": {
            betas.add("computer-use-2025-11-24"), anthropicTools2.push({
              name: "computer",
              type: "computer_20251124",
              display_width_px: tool2.args.displayWidthPx,
              display_height_px: tool2.args.displayHeightPx,
              display_number: tool2.args.displayNumber,
              enable_zoom: tool2.args.enableZoom,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20241022": {
            betas.add("computer-use-2024-10-22"), anthropicTools2.push({
              name: "computer",
              type: "computer_20241022",
              display_width_px: tool2.args.displayWidthPx,
              display_height_px: tool2.args.displayHeightPx,
              display_number: tool2.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250124": {
            betas.add("computer-use-2025-01-24"), anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20241022": {
            betas.add("computer-use-2024-10-22"), anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250429": {
            betas.add("computer-use-2025-01-24"), anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250429",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250728": {
            let args = await validateTypes({
              value: tool2.args,
              schema: textEditor_20250728ArgsSchema
            });
            anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250728",
              max_characters: args.maxCharacters,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20250124": {
            betas.add("computer-use-2025-01-24"), anthropicTools2.push({
              name: "bash",
              type: "bash_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20241022": {
            betas.add("computer-use-2024-10-22"), anthropicTools2.push({
              name: "bash",
              type: "bash_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.memory_20250818": {
            betas.add("context-management-2025-06-27"), anthropicTools2.push({
              name: "memory",
              type: "memory_20250818"
            });
            break;
          }
          case "anthropic.web_fetch_20250910": {
            betas.add("web-fetch-2025-09-10");
            let args = await validateTypes({
              value: tool2.args,
              schema: webFetch_20250910ArgsSchema
            });
            anthropicTools2.push({
              type: "web_fetch_20250910",
              name: "web_fetch",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              citations: args.citations,
              max_content_tokens: args.maxContentTokens,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.web_search_20250305": {
            let args = await validateTypes({
              value: tool2.args,
              schema: webSearch_20250305ArgsSchema
            });
            anthropicTools2.push({
              type: "web_search_20250305",
              name: "web_search",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              user_location: args.userLocation,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.tool_search_regex_20251119": {
            betas.add("advanced-tool-use-2025-11-20"), anthropicTools2.push({
              type: "tool_search_tool_regex_20251119",
              name: "tool_search_tool_regex"
            });
            break;
          }
          case "anthropic.tool_search_bm25_20251119": {
            betas.add("advanced-tool-use-2025-11-20"), anthropicTools2.push({
              type: "tool_search_tool_bm25_20251119",
              name: "tool_search_tool_bm25"
            });
            break;
          }
          default: {
            toolWarnings.push({
              type: "unsupported",
              feature: `provider-defined tool ${tool2.id}`
            });
            break;
          }
        }
        break;
      }
      default: {
        toolWarnings.push({
          type: "unsupported",
          feature: `tool ${tool2}`
        });
        break;
      }
    }
  if (toolChoice == null)
    return {
      tools: anthropicTools2,
      toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
      toolWarnings,
      betas
    };
  let type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "auto",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "required":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "any",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "none":
      return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
    case "tool":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "tool",
          name: toolChoice.toolName,
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    default:
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${type}`
      });
  }
}
function convertAnthropicMessagesUsage(usage) {
  var _a21, _b16;
  let { input_tokens: inputTokens, output_tokens: outputTokens } = usage, cacheCreationTokens = (_a21 = usage.cache_creation_input_tokens) != null ? _a21 : 0, cacheReadTokens = (_b16 = usage.cache_read_input_tokens) != null ? _b16 : 0;
  return {
    inputTokens: {
      total: inputTokens + cacheCreationTokens + cacheReadTokens,
      noCache: inputTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: cacheCreationTokens
    },
    outputTokens: {
      total: outputTokens,
      text: void 0,
      reasoning: void 0
    },
    raw: usage
  };
}
var codeExecution_20250522OutputSchema = lazySchema(() => zodSchema(exports_external.object({
  type: exports_external.literal("code_execution_result"),
  stdout: exports_external.string(),
  stderr: exports_external.string(),
  return_code: exports_external.number(),
  content: exports_external.array(exports_external.object({
    type: exports_external.literal("code_execution_output"),
    file_id: exports_external.string()
  })).optional().default([])
}))), codeExecution_20250522InputSchema = lazySchema(() => zodSchema(exports_external.object({
  code: exports_external.string()
}))), factory4 = createProviderToolFactoryWithOutputSchema({
  id: "anthropic.code_execution_20250522",
  inputSchema: codeExecution_20250522InputSchema,
  outputSchema: codeExecution_20250522OutputSchema
}), codeExecution_20250522 = (args = {}) => {
  return factory4(args);
}, codeExecution_20250825OutputSchema = lazySchema(() => zodSchema(exports_external.discriminatedUnion("type", [
  exports_external.object({
    type: exports_external.literal("code_execution_result"),
    stdout: exports_external.string(),
    stderr: exports_external.string(),
    return_code: exports_external.number(),
    content: exports_external.array(exports_external.object({
      type: exports_external.literal("code_execution_output"),
      file_id: exports_external.string()
    })).optional().default([])
  }),
  exports_external.object({
    type: exports_external.literal("bash_code_execution_result"),
    content: exports_external.array(exports_external.object({
      type: exports_external.literal("bash_code_execution_output"),
      file_id: exports_external.string()
    })),
    stdout: exports_external.string(),
    stderr: exports_external.string(),
    return_code: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("bash_code_execution_tool_result_error"),
    error_code: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("text_editor_code_execution_tool_result_error"),
    error_code: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("text_editor_code_execution_view_result"),
    content: exports_external.string(),
    file_type: exports_external.string(),
    num_lines: exports_external.number().nullable(),
    start_line: exports_external.number().nullable(),
    total_lines: exports_external.number().nullable()
  }),
  exports_external.object({
    type: exports_external.literal("text_editor_code_execution_create_result"),
    is_file_update: exports_external.boolean()
  }),
  exports_external.object({
    type: exports_external.literal("text_editor_code_execution_str_replace_result"),
    lines: exports_external.array(exports_external.string()).nullable(),
    new_lines: exports_external.number().nullable(),
    new_start: exports_external.number().nullable(),
    old_lines: exports_external.number().nullable(),
    old_start: exports_external.number().nullable()
  })
]))), codeExecution_20250825InputSchema = lazySchema(() => zodSchema(exports_external.discriminatedUnion("type", [
  exports_external.object({
    type: exports_external.literal("programmatic-tool-call"),
    code: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("bash_code_execution"),
    command: exports_external.string()
  }),
  exports_external.discriminatedUnion("command", [
    exports_external.object({
      type: exports_external.literal("text_editor_code_execution"),
      command: exports_external.literal("view"),
      path: exports_external.string()
    }),
    exports_external.object({
      type: exports_external.literal("text_editor_code_execution"),
      command: exports_external.literal("create"),
      path: exports_external.string(),
      file_text: exports_external.string().nullish()
    }),
    exports_external.object({
      type: exports_external.literal("text_editor_code_execution"),
      command: exports_external.literal("str_replace"),
      path: exports_external.string(),
      old_str: exports_external.string(),
      new_str: exports_external.string()
    })
  ])
]))), factory5 = createProviderToolFactoryWithOutputSchema({
  id: "anthropic.code_execution_20250825",
  inputSchema: codeExecution_20250825InputSchema,
  outputSchema: codeExecution_20250825OutputSchema,
  supportsDeferredResults: !0
}), codeExecution_20250825 = (args = {}) => {
  return factory5(args);
}, toolSearchRegex_20251119OutputSchema = lazySchema(() => zodSchema(exports_external.array(exports_external.object({
  type: exports_external.literal("tool_reference"),
  toolName: exports_external.string()
})))), toolSearchRegex_20251119InputSchema = lazySchema(() => zodSchema(exports_external.object({
  pattern: exports_external.string(),
  limit: exports_external.number().optional()
}))), factory6 = createProviderToolFactoryWithOutputSchema({
  id: "anthropic.tool_search_regex_20251119",
  inputSchema: toolSearchRegex_20251119InputSchema,
  outputSchema: toolSearchRegex_20251119OutputSchema,
  supportsDeferredResults: !0
}), toolSearchRegex_20251119 = (args = {}) => {
  return factory6(args);
};
function convertToString(data) {
  if (typeof data === "string")
    return Buffer.from(data, "base64").toString("utf-8");
  if (data instanceof Uint8Array)
    return (/* @__PURE__ */ new TextDecoder()).decode(data);
  if (data instanceof URL)
    throw new UnsupportedFunctionalityError({
      functionality: "URL-based text documents are not supported for citations"
    });
  throw new UnsupportedFunctionalityError({
    functionality: `unsupported data type for text documents: ${typeof data}`
  });
}
function isUrlData(data) {
  return data instanceof URL || isUrlString(data);
}
function isUrlString(data) {
  return typeof data === "string" && /^https?:\/\//i.test(data);
}
function getUrlString(data) {
  return data instanceof URL ? data.toString() : data;
}
async function convertToAnthropicMessagesPrompt({
  prompt,
  sendReasoning,
  warnings,
  cacheControlValidator,
  toolNameMapping
}) {
  var _a21, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  let betas = /* @__PURE__ */ new Set, blocks = groupIntoBlocks(prompt), validator = cacheControlValidator || new CacheControlValidator, system = void 0, messages = [];
  async function shouldEnableCitations(providerMetadata) {
    var _a24, _b23;
    let anthropicOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return (_b23 = (_a24 = anthropicOptions == null ? void 0 : anthropicOptions.citations) == null ? void 0 : _a24.enabled) != null ? _b23 : !1;
  }
  async function getDocumentMetadata(providerMetadata) {
    let anthropicOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return {
      title: anthropicOptions == null ? void 0 : anthropicOptions.title,
      context: anthropicOptions == null ? void 0 : anthropicOptions.context
    };
  }
  for (let i = 0;i < blocks.length; i++) {
    let block = blocks[i], isLastBlock = i === blocks.length - 1, type = block.type;
    switch (type) {
      case "system": {
        if (system != null)
          throw new UnsupportedFunctionalityError({
            functionality: "Multiple system messages that are separated by user/assistant messages"
          });
        system = block.messages.map(({ content, providerOptions }) => ({
          type: "text",
          text: content,
          cache_control: validator.getCacheControl(providerOptions, {
            type: "system message",
            canCache: !0
          })
        }));
        break;
      }
      case "user": {
        let anthropicContent = [];
        for (let message of block.messages) {
          let { role, content } = message;
          switch (role) {
            case "user": {
              for (let j = 0;j < content.length; j++) {
                let part = content[j], isLastPart = j === content.length - 1, cacheControl = (_a21 = validator.getCacheControl(part.providerOptions, {
                  type: "user message part",
                  canCache: !0
                })) != null ? _a21 : isLastPart ? validator.getCacheControl(message.providerOptions, {
                  type: "user message",
                  canCache: !0
                }) : void 0;
                switch (part.type) {
                  case "text": {
                    anthropicContent.push({
                      type: "text",
                      text: part.text,
                      cache_control: cacheControl
                    });
                    break;
                  }
                  case "file": {
                    if (part.mediaType.startsWith("image/"))
                      anthropicContent.push({
                        type: "image",
                        source: isUrlData(part.data) ? {
                          type: "url",
                          url: getUrlString(part.data)
                        } : {
                          type: "base64",
                          media_type: part.mediaType === "image/*" ? "image/jpeg" : part.mediaType,
                          data: convertToBase64(part.data)
                        },
                        cache_control: cacheControl
                      });
                    else if (part.mediaType === "application/pdf") {
                      betas.add("pdfs-2024-09-25");
                      let enableCitations = await shouldEnableCitations(part.providerOptions), metadata = await getDocumentMetadata(part.providerOptions);
                      anthropicContent.push({
                        type: "document",
                        source: isUrlData(part.data) ? {
                          type: "url",
                          url: getUrlString(part.data)
                        } : {
                          type: "base64",
                          media_type: "application/pdf",
                          data: convertToBase64(part.data)
                        },
                        title: (_b16 = metadata.title) != null ? _b16 : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: !0 }
                        },
                        cache_control: cacheControl
                      });
                    } else if (part.mediaType === "text/plain") {
                      let enableCitations = await shouldEnableCitations(part.providerOptions), metadata = await getDocumentMetadata(part.providerOptions);
                      anthropicContent.push({
                        type: "document",
                        source: isUrlData(part.data) ? {
                          type: "url",
                          url: getUrlString(part.data)
                        } : {
                          type: "text",
                          media_type: "text/plain",
                          data: convertToString(part.data)
                        },
                        title: (_c = metadata.title) != null ? _c : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: !0 }
                        },
                        cache_control: cacheControl
                      });
                    } else
                      throw new UnsupportedFunctionalityError({
                        functionality: `media type: ${part.mediaType}`
                      });
                    break;
                  }
                }
              }
              break;
            }
            case "tool": {
              for (let i2 = 0;i2 < content.length; i2++) {
                let part = content[i2];
                if (part.type === "tool-approval-response")
                  continue;
                let isLastPart = i2 === content.length - 1, cacheControl = (_d = validator.getCacheControl(part.providerOptions, {
                  type: "tool result part",
                  canCache: !0
                })) != null ? _d : isLastPart ? validator.getCacheControl(message.providerOptions, {
                  type: "tool result message",
                  canCache: !0
                }) : void 0, output = part.output, contentValue;
                switch (output.type) {
                  case "content":
                    contentValue = output.value.map((contentPart) => {
                      switch (contentPart.type) {
                        case "text":
                          return {
                            type: "text",
                            text: contentPart.text
                          };
                        case "image-data":
                          return {
                            type: "image",
                            source: {
                              type: "base64",
                              media_type: contentPart.mediaType,
                              data: contentPart.data
                            }
                          };
                        case "image-url":
                          return {
                            type: "image",
                            source: {
                              type: "url",
                              url: contentPart.url
                            }
                          };
                        case "file-url":
                          return {
                            type: "document",
                            source: {
                              type: "url",
                              url: contentPart.url
                            }
                          };
                        case "file-data": {
                          if (contentPart.mediaType === "application/pdf")
                            return betas.add("pdfs-2024-09-25"), {
                              type: "document",
                              source: {
                                type: "base64",
                                media_type: contentPart.mediaType,
                                data: contentPart.data
                              }
                            };
                          warnings.push({
                            type: "other",
                            message: `unsupported tool content part type: ${contentPart.type} with media type: ${contentPart.mediaType}`
                          });
                          return;
                        }
                        default: {
                          warnings.push({
                            type: "other",
                            message: `unsupported tool content part type: ${contentPart.type}`
                          });
                          return;
                        }
                      }
                    }).filter(isNonNullable);
                    break;
                  case "text":
                  case "error-text":
                    contentValue = output.value;
                    break;
                  case "execution-denied":
                    contentValue = (_e = output.reason) != null ? _e : "Tool execution denied.";
                    break;
                  case "json":
                  case "error-json":
                  default:
                    contentValue = JSON.stringify(output.value);
                    break;
                }
                anthropicContent.push({
                  type: "tool_result",
                  tool_use_id: part.toolCallId,
                  content: contentValue,
                  is_error: output.type === "error-text" || output.type === "error-json" ? !0 : void 0,
                  cache_control: cacheControl
                });
              }
              break;
            }
            default:
              throw Error(`Unsupported role: ${role}`);
          }
        }
        messages.push({ role: "user", content: anthropicContent });
        break;
      }
      case "assistant": {
        let anthropicContent = [], mcpToolUseIds = /* @__PURE__ */ new Set;
        for (let j = 0;j < block.messages.length; j++) {
          let message = block.messages[j], isLastMessage = j === block.messages.length - 1, { content } = message;
          for (let k = 0;k < content.length; k++) {
            let part = content[k], isLastContentPart = k === content.length - 1, cacheControl = (_f = validator.getCacheControl(part.providerOptions, {
              type: "assistant message part",
              canCache: !0
            })) != null ? _f : isLastContentPart ? validator.getCacheControl(message.providerOptions, {
              type: "assistant message",
              canCache: !0
            }) : void 0;
            switch (part.type) {
              case "text": {
                anthropicContent.push({
                  type: "text",
                  text: isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text,
                  cache_control: cacheControl
                });
                break;
              }
              case "reasoning": {
                if (sendReasoning) {
                  let reasoningMetadata = await parseProviderOptions({
                    provider: "anthropic",
                    providerOptions: part.providerOptions,
                    schema: anthropicReasoningMetadataSchema
                  });
                  if (reasoningMetadata != null)
                    if (reasoningMetadata.signature != null)
                      validator.getCacheControl(part.providerOptions, {
                        type: "thinking block",
                        canCache: !1
                      }), anthropicContent.push({
                        type: "thinking",
                        thinking: part.text,
                        signature: reasoningMetadata.signature
                      });
                    else if (reasoningMetadata.redactedData != null)
                      validator.getCacheControl(part.providerOptions, {
                        type: "redacted thinking block",
                        canCache: !1
                      }), anthropicContent.push({
                        type: "redacted_thinking",
                        data: reasoningMetadata.redactedData
                      });
                    else
                      warnings.push({
                        type: "other",
                        message: "unsupported reasoning metadata"
                      });
                  else
                    warnings.push({
                      type: "other",
                      message: "unsupported reasoning metadata"
                    });
                } else
                  warnings.push({
                    type: "other",
                    message: "sending reasoning content is disabled for this model"
                  });
                break;
              }
              case "tool-call": {
                if (part.providerExecuted) {
                  let providerToolName = toolNameMapping.toProviderToolName(part.toolName);
                  if (((_h = (_g = part.providerOptions) == null ? void 0 : _g.anthropic) == null ? void 0 : _h.type) === "mcp-tool-use") {
                    mcpToolUseIds.add(part.toolCallId);
                    let serverName = (_j = (_i = part.providerOptions) == null ? void 0 : _i.anthropic) == null ? void 0 : _j.serverName;
                    if (serverName == null || typeof serverName !== "string") {
                      warnings.push({
                        type: "other",
                        message: "mcp tool use server name is required and must be a string"
                      });
                      break;
                    }
                    anthropicContent.push({
                      type: "mcp_tool_use",
                      id: part.toolCallId,
                      name: part.toolName,
                      input: part.input,
                      server_name: serverName,
                      cache_control: cacheControl
                    });
                  } else if (providerToolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && typeof part.input.type === "string" && (part.input.type === "bash_code_execution" || part.input.type === "text_editor_code_execution"))
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: part.input.type,
                      input: part.input,
                      cache_control: cacheControl
                    });
                  else if (providerToolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && part.input.type === "programmatic-tool-call") {
                    let { type: _, ...inputWithoutType } = part.input;
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: "code_execution",
                      input: inputWithoutType,
                      cache_control: cacheControl
                    });
                  } else if (providerToolName === "code_execution" || providerToolName === "web_fetch" || providerToolName === "web_search")
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: providerToolName,
                      input: part.input,
                      cache_control: cacheControl
                    });
                  else if (providerToolName === "tool_search_tool_regex" || providerToolName === "tool_search_tool_bm25")
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: providerToolName,
                      input: part.input,
                      cache_control: cacheControl
                    });
                  else
                    warnings.push({
                      type: "other",
                      message: `provider executed tool call for tool ${part.toolName} is not supported`
                    });
                  break;
                }
                let callerOptions = (_k = part.providerOptions) == null ? void 0 : _k.anthropic, caller = (callerOptions == null ? void 0 : callerOptions.caller) ? callerOptions.caller.type === "code_execution_20250825" && callerOptions.caller.toolId ? {
                  type: "code_execution_20250825",
                  tool_id: callerOptions.caller.toolId
                } : callerOptions.caller.type === "direct" ? { type: "direct" } : void 0 : void 0;
                anthropicContent.push({
                  type: "tool_use",
                  id: part.toolCallId,
                  name: part.toolName,
                  input: part.input,
                  ...caller && { caller },
                  cache_control: cacheControl
                });
                break;
              }
              case "tool-result": {
                let providerToolName = toolNameMapping.toProviderToolName(part.toolName);
                if (mcpToolUseIds.has(part.toolCallId)) {
                  let output = part.output;
                  if (output.type !== "json" && output.type !== "error-json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  anthropicContent.push({
                    type: "mcp_tool_result",
                    tool_use_id: part.toolCallId,
                    is_error: output.type === "error-json",
                    content: output.value,
                    cache_control: cacheControl
                  });
                } else if (providerToolName === "code_execution") {
                  let output = part.output;
                  if (output.type === "error-text" || output.type === "error-json") {
                    let errorInfo = {};
                    try {
                      if (typeof output.value === "string")
                        errorInfo = JSON.parse(output.value);
                      else if (typeof output.value === "object" && output.value !== null)
                        errorInfo = output.value;
                    } catch (e) {}
                    if (errorInfo.type === "code_execution_tool_result_error")
                      anthropicContent.push({
                        type: "code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        content: {
                          type: "code_execution_tool_result_error",
                          error_code: (_l = errorInfo.errorCode) != null ? _l : "unknown"
                        },
                        cache_control: cacheControl
                      });
                    else
                      anthropicContent.push({
                        type: "bash_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: {
                          type: "bash_code_execution_tool_result_error",
                          error_code: (_m = errorInfo.errorCode) != null ? _m : "unknown"
                        }
                      });
                    break;
                  }
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  if (output.value == null || typeof output.value !== "object" || !("type" in output.value) || typeof output.value.type !== "string") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output value is not a valid code execution result for tool ${part.toolName}`
                    });
                    break;
                  }
                  if (output.value.type === "code_execution_result") {
                    let codeExecutionOutput = await validateTypes({
                      value: output.value,
                      schema: codeExecution_20250522OutputSchema
                    });
                    anthropicContent.push({
                      type: "code_execution_tool_result",
                      tool_use_id: part.toolCallId,
                      content: {
                        type: codeExecutionOutput.type,
                        stdout: codeExecutionOutput.stdout,
                        stderr: codeExecutionOutput.stderr,
                        return_code: codeExecutionOutput.return_code,
                        content: (_n = codeExecutionOutput.content) != null ? _n : []
                      },
                      cache_control: cacheControl
                    });
                  } else {
                    let codeExecutionOutput = await validateTypes({
                      value: output.value,
                      schema: codeExecution_20250825OutputSchema
                    });
                    if (codeExecutionOutput.type === "code_execution_result")
                      anthropicContent.push({
                        type: "code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        content: {
                          type: codeExecutionOutput.type,
                          stdout: codeExecutionOutput.stdout,
                          stderr: codeExecutionOutput.stderr,
                          return_code: codeExecutionOutput.return_code,
                          content: (_o = codeExecutionOutput.content) != null ? _o : []
                        },
                        cache_control: cacheControl
                      });
                    else if (codeExecutionOutput.type === "bash_code_execution_result" || codeExecutionOutput.type === "bash_code_execution_tool_result_error")
                      anthropicContent.push({
                        type: "bash_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      });
                    else
                      anthropicContent.push({
                        type: "text_editor_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      });
                  }
                  break;
                }
                if (providerToolName === "web_fetch") {
                  let output = part.output;
                  if (output.type === "error-json") {
                    let errorValue = {};
                    try {
                      if (typeof output.value === "string")
                        errorValue = JSON.parse(output.value);
                      else if (typeof output.value === "object" && output.value !== null)
                        errorValue = output.value;
                    } catch (e) {
                      let extractedErrorCode = (_p = output.value) == null ? void 0 : _p.errorCode;
                      errorValue = {
                        errorCode: typeof extractedErrorCode === "string" ? extractedErrorCode : "unknown"
                      };
                    }
                    anthropicContent.push({
                      type: "web_fetch_tool_result",
                      tool_use_id: part.toolCallId,
                      content: {
                        type: "web_fetch_tool_result_error",
                        error_code: (_q = errorValue.errorCode) != null ? _q : "unknown"
                      },
                      cache_control: cacheControl
                    });
                    break;
                  }
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  let webFetchOutput = await validateTypes({
                    value: output.value,
                    schema: webFetch_20250910OutputSchema
                  });
                  anthropicContent.push({
                    type: "web_fetch_tool_result",
                    tool_use_id: part.toolCallId,
                    content: {
                      type: "web_fetch_result",
                      url: webFetchOutput.url,
                      retrieved_at: webFetchOutput.retrievedAt,
                      content: {
                        type: "document",
                        title: webFetchOutput.content.title,
                        citations: webFetchOutput.content.citations,
                        source: {
                          type: webFetchOutput.content.source.type,
                          media_type: webFetchOutput.content.source.mediaType,
                          data: webFetchOutput.content.source.data
                        }
                      }
                    },
                    cache_control: cacheControl
                  });
                  break;
                }
                if (providerToolName === "web_search") {
                  let output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  let webSearchOutput = await validateTypes({
                    value: output.value,
                    schema: webSearch_20250305OutputSchema
                  });
                  anthropicContent.push({
                    type: "web_search_tool_result",
                    tool_use_id: part.toolCallId,
                    content: webSearchOutput.map((result) => ({
                      url: result.url,
                      title: result.title,
                      page_age: result.pageAge,
                      encrypted_content: result.encryptedContent,
                      type: result.type
                    })),
                    cache_control: cacheControl
                  });
                  break;
                }
                if (providerToolName === "tool_search_tool_regex" || providerToolName === "tool_search_tool_bm25") {
                  let output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  let toolReferences = (await validateTypes({
                    value: output.value,
                    schema: toolSearchRegex_20251119OutputSchema
                  })).map((ref) => ({
                    type: "tool_reference",
                    tool_name: ref.toolName
                  }));
                  anthropicContent.push({
                    type: "tool_search_tool_result",
                    tool_use_id: part.toolCallId,
                    content: {
                      type: "tool_search_tool_search_result",
                      tool_references: toolReferences
                    },
                    cache_control: cacheControl
                  });
                  break;
                }
                warnings.push({
                  type: "other",
                  message: `provider executed tool result for tool ${part.toolName} is not supported`
                });
                break;
              }
            }
          }
        }
        messages.push({ role: "assistant", content: anthropicContent });
        break;
      }
      default:
        throw Error(`content type: ${type}`);
    }
  }
  return {
    prompt: { system, messages },
    betas
  };
}
function groupIntoBlocks(prompt) {
  let blocks = [], currentBlock = void 0;
  for (let message of prompt) {
    let { role } = message;
    switch (role) {
      case "system": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "system")
          currentBlock = { type: "system", messages: [] }, blocks.push(currentBlock);
        currentBlock.messages.push(message);
        break;
      }
      case "assistant": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant")
          currentBlock = { type: "assistant", messages: [] }, blocks.push(currentBlock);
        currentBlock.messages.push(message);
        break;
      }
      case "user": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user")
          currentBlock = { type: "user", messages: [] }, blocks.push(currentBlock);
        currentBlock.messages.push(message);
        break;
      }
      case "tool": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user")
          currentBlock = { type: "user", messages: [] }, blocks.push(currentBlock);
        currentBlock.messages.push(message);
        break;
      }
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  }
  return blocks;
}
function mapAnthropicStopReason({
  finishReason,
  isJsonResponseFromTool
}) {
  switch (finishReason) {
    case "pause_turn":
    case "end_turn":
    case "stop_sequence":
      return "stop";
    case "refusal":
      return "content-filter";
    case "tool_use":
      return isJsonResponseFromTool ? "stop" : "tool-calls";
    case "max_tokens":
    case "model_context_window_exceeded":
      return "length";
    default:
      return "other";
  }
}
function createCitationSource(citation, citationDocuments, generateId3) {
  var _a21;
  if (citation.type === "web_search_result_location")
    return {
      type: "source",
      sourceType: "url",
      id: generateId3(),
      url: citation.url,
      title: citation.title,
      providerMetadata: {
        anthropic: {
          citedText: citation.cited_text,
          encryptedIndex: citation.encrypted_index
        }
      }
    };
  if (citation.type !== "page_location" && citation.type !== "char_location")
    return;
  let documentInfo = citationDocuments[citation.document_index];
  if (!documentInfo)
    return;
  return {
    type: "source",
    sourceType: "document",
    id: generateId3(),
    mediaType: documentInfo.mediaType,
    title: (_a21 = citation.document_title) != null ? _a21 : documentInfo.title,
    filename: documentInfo.filename,
    providerMetadata: {
      anthropic: citation.type === "page_location" ? {
        citedText: citation.cited_text,
        startPageNumber: citation.start_page_number,
        endPageNumber: citation.end_page_number
      } : {
        citedText: citation.cited_text,
        startCharIndex: citation.start_char_index,
        endCharIndex: citation.end_char_index
      }
    }
  };
}
var AnthropicMessagesLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3";
    var _a21;
    this.modelId = modelId, this.config = config2, this.generateId = (_a21 = config2.generateId) != null ? _a21 : generateId;
  }
  supportsUrl(url2) {
    return url2.protocol === "https:";
  }
  get provider() {
    return this.config.provider;
  }
  get providerOptionsName() {
    let provider = this.config.provider, dotIndex = provider.indexOf(".");
    return dotIndex === -1 ? provider : provider.substring(0, dotIndex);
  }
  get supportedUrls() {
    var _a21, _b16, _c;
    return (_c = (_b16 = (_a21 = this.config).supportedUrls) == null ? void 0 : _b16.call(_a21)) != null ? _c : {};
  }
  async getArgs({
    userSuppliedBetas,
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    tools,
    toolChoice,
    providerOptions,
    stream
  }) {
    var _a21, _b16, _c, _d, _e, _f;
    let warnings = [];
    if (frequencyPenalty != null)
      warnings.push({ type: "unsupported", feature: "frequencyPenalty" });
    if (presencePenalty != null)
      warnings.push({ type: "unsupported", feature: "presencePenalty" });
    if (seed != null)
      warnings.push({ type: "unsupported", feature: "seed" });
    if (temperature != null && temperature > 1)
      warnings.push({
        type: "unsupported",
        feature: "temperature",
        details: `${temperature} exceeds anthropic maximum of 1.0. clamped to 1.0`
      }), temperature = 1;
    else if (temperature != null && temperature < 0)
      warnings.push({
        type: "unsupported",
        feature: "temperature",
        details: `${temperature} is below anthropic minimum of 0. clamped to 0`
      }), temperature = 0;
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
      if (responseFormat.schema == null)
        warnings.push({
          type: "unsupported",
          feature: "responseFormat",
          details: "JSON response format requires a schema. The response format is ignored."
        });
    }
    let providerOptionsName = this.providerOptionsName, canonicalOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions,
      schema: anthropicProviderOptions
    }), customProviderOptions = providerOptionsName !== "anthropic" ? await parseProviderOptions({
      provider: providerOptionsName,
      providerOptions,
      schema: anthropicProviderOptions
    }) : null, usedCustomProviderKey = customProviderOptions != null, anthropicOptions = Object.assign({}, canonicalOptions != null ? canonicalOptions : {}, customProviderOptions != null ? customProviderOptions : {}), {
      maxOutputTokens: maxOutputTokensForModel,
      supportsStructuredOutput: modelSupportsStructuredOutput,
      isKnownModel
    } = getModelCapabilities(this.modelId), supportsStructuredOutput = ((_a21 = this.config.supportsNativeStructuredOutput) != null ? _a21 : !0) && modelSupportsStructuredOutput, structureOutputMode = (_b16 = anthropicOptions == null ? void 0 : anthropicOptions.structuredOutputMode) != null ? _b16 : "auto", useStructuredOutput = structureOutputMode === "outputFormat" || structureOutputMode === "auto" && supportsStructuredOutput, jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !useStructuredOutput ? {
      type: "function",
      name: "json",
      description: "Respond with a JSON object.",
      inputSchema: responseFormat.schema
    } : void 0, contextManagement = anthropicOptions == null ? void 0 : anthropicOptions.contextManagement, cacheControlValidator = new CacheControlValidator, toolNameMapping = createToolNameMapping({
      tools,
      providerToolNames: {
        "anthropic.code_execution_20250522": "code_execution",
        "anthropic.code_execution_20250825": "code_execution",
        "anthropic.computer_20241022": "computer",
        "anthropic.computer_20250124": "computer",
        "anthropic.text_editor_20241022": "str_replace_editor",
        "anthropic.text_editor_20250124": "str_replace_editor",
        "anthropic.text_editor_20250429": "str_replace_based_edit_tool",
        "anthropic.text_editor_20250728": "str_replace_based_edit_tool",
        "anthropic.bash_20241022": "bash",
        "anthropic.bash_20250124": "bash",
        "anthropic.memory_20250818": "memory",
        "anthropic.web_search_20250305": "web_search",
        "anthropic.web_fetch_20250910": "web_fetch",
        "anthropic.tool_search_regex_20251119": "tool_search_tool_regex",
        "anthropic.tool_search_bm25_20251119": "tool_search_tool_bm25"
      }
    }), { prompt: messagesPrompt, betas } = await convertToAnthropicMessagesPrompt({
      prompt,
      sendReasoning: (_c = anthropicOptions == null ? void 0 : anthropicOptions.sendReasoning) != null ? _c : !0,
      warnings,
      cacheControlValidator,
      toolNameMapping
    }), isThinking = ((_d = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _d.type) === "enabled", thinkingBudget = (_e = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _e.budgetTokens, maxTokens = maxOutputTokens != null ? maxOutputTokens : maxOutputTokensForModel, baseArgs = {
      model: this.modelId,
      max_tokens: maxTokens,
      temperature,
      top_k: topK,
      top_p: topP,
      stop_sequences: stopSequences,
      ...isThinking && {
        thinking: { type: "enabled", budget_tokens: thinkingBudget }
      },
      ...(anthropicOptions == null ? void 0 : anthropicOptions.effort) && {
        output_config: { effort: anthropicOptions.effort }
      },
      ...useStructuredOutput && (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && {
        output_format: {
          type: "json_schema",
          schema: responseFormat.schema
        }
      },
      ...(anthropicOptions == null ? void 0 : anthropicOptions.mcpServers) && anthropicOptions.mcpServers.length > 0 && {
        mcp_servers: anthropicOptions.mcpServers.map((server) => ({
          type: server.type,
          name: server.name,
          url: server.url,
          authorization_token: server.authorizationToken,
          tool_configuration: server.toolConfiguration ? {
            allowed_tools: server.toolConfiguration.allowedTools,
            enabled: server.toolConfiguration.enabled
          } : void 0
        }))
      },
      ...(anthropicOptions == null ? void 0 : anthropicOptions.container) && {
        container: anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0 ? {
          id: anthropicOptions.container.id,
          skills: anthropicOptions.container.skills.map((skill) => ({
            type: skill.type,
            skill_id: skill.skillId,
            version: skill.version
          }))
        } : anthropicOptions.container.id
      },
      system: messagesPrompt.system,
      messages: messagesPrompt.messages,
      ...contextManagement && {
        context_management: {
          edits: contextManagement.edits.map((edit) => {
            let strategy = edit.type;
            switch (strategy) {
              case "clear_tool_uses_20250919":
                return {
                  type: edit.type,
                  ...edit.trigger !== void 0 && {
                    trigger: edit.trigger
                  },
                  ...edit.keep !== void 0 && { keep: edit.keep },
                  ...edit.clearAtLeast !== void 0 && {
                    clear_at_least: edit.clearAtLeast
                  },
                  ...edit.clearToolInputs !== void 0 && {
                    clear_tool_inputs: edit.clearToolInputs
                  },
                  ...edit.excludeTools !== void 0 && {
                    exclude_tools: edit.excludeTools
                  }
                };
              case "clear_thinking_20251015":
                return {
                  type: edit.type,
                  ...edit.keep !== void 0 && { keep: edit.keep }
                };
              default:
                warnings.push({
                  type: "other",
                  message: `Unknown context management strategy: ${strategy}`
                });
                return;
            }
          }).filter((edit) => edit !== void 0)
        }
      }
    };
    if (isThinking) {
      if (thinkingBudget == null)
        warnings.push({
          type: "compatibility",
          feature: "extended thinking",
          details: "thinking budget is required when thinking is enabled. using default budget of 1024 tokens."
        }), baseArgs.thinking = {
          type: "enabled",
          budget_tokens: 1024
        }, thinkingBudget = 1024;
      if (baseArgs.temperature != null)
        baseArgs.temperature = void 0, warnings.push({
          type: "unsupported",
          feature: "temperature",
          details: "temperature is not supported when thinking is enabled"
        });
      if (topK != null)
        baseArgs.top_k = void 0, warnings.push({
          type: "unsupported",
          feature: "topK",
          details: "topK is not supported when thinking is enabled"
        });
      if (topP != null)
        baseArgs.top_p = void 0, warnings.push({
          type: "unsupported",
          feature: "topP",
          details: "topP is not supported when thinking is enabled"
        });
      baseArgs.max_tokens = maxTokens + (thinkingBudget != null ? thinkingBudget : 0);
    } else if (topP != null && temperature != null)
      warnings.push({
        type: "unsupported",
        feature: "topP",
        details: "topP is not supported when temperature is set. topP is ignored."
      }), baseArgs.top_p = void 0;
    if (isKnownModel && baseArgs.max_tokens > maxOutputTokensForModel) {
      if (maxOutputTokens != null)
        warnings.push({
          type: "unsupported",
          feature: "maxOutputTokens",
          details: `${baseArgs.max_tokens} (maxOutputTokens + thinkingBudget) is greater than ${this.modelId} ${maxOutputTokensForModel} max output tokens. The max output tokens have been limited to ${maxOutputTokensForModel}.`
        });
      baseArgs.max_tokens = maxOutputTokensForModel;
    }
    if ((anthropicOptions == null ? void 0 : anthropicOptions.mcpServers) && anthropicOptions.mcpServers.length > 0)
      betas.add("mcp-client-2025-04-04");
    if (contextManagement)
      betas.add("context-management-2025-06-27");
    if ((anthropicOptions == null ? void 0 : anthropicOptions.container) && anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0) {
      if (betas.add("code-execution-2025-08-25"), betas.add("skills-2025-10-02"), betas.add("files-api-2025-04-14"), !(tools == null ? void 0 : tools.some((tool2) => tool2.type === "provider" && tool2.id === "anthropic.code_execution_20250825")))
        warnings.push({
          type: "other",
          message: "code execution tool is required when using skills"
        });
    }
    if (anthropicOptions == null ? void 0 : anthropicOptions.effort)
      betas.add("effort-2025-11-24");
    if (stream && ((_f = anthropicOptions == null ? void 0 : anthropicOptions.toolStreaming) != null ? _f : !0))
      betas.add("fine-grained-tool-streaming-2025-05-14");
    if (useStructuredOutput && (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null)
      betas.add("structured-outputs-2025-11-13");
    let {
      tools: anthropicTools2,
      toolChoice: anthropicToolChoice,
      toolWarnings,
      betas: toolsBetas
    } = await prepareTools3(jsonResponseTool != null ? {
      tools: [...tools != null ? tools : [], jsonResponseTool],
      toolChoice: { type: "required" },
      disableParallelToolUse: !0,
      cacheControlValidator,
      supportsStructuredOutput: !1
    } : {
      tools: tools != null ? tools : [],
      toolChoice,
      disableParallelToolUse: anthropicOptions == null ? void 0 : anthropicOptions.disableParallelToolUse,
      cacheControlValidator,
      supportsStructuredOutput
    }), cacheWarnings = cacheControlValidator.getWarnings();
    return {
      args: {
        ...baseArgs,
        tools: anthropicTools2,
        tool_choice: anthropicToolChoice,
        stream: stream === !0 ? !0 : void 0
      },
      warnings: [...warnings, ...toolWarnings, ...cacheWarnings],
      betas: /* @__PURE__ */ new Set([...betas, ...toolsBetas, ...userSuppliedBetas]),
      usesJsonResponseTool: jsonResponseTool != null,
      toolNameMapping,
      providerOptionsName,
      usedCustomProviderKey
    };
  }
  async getHeaders({
    betas,
    headers
  }) {
    return combineHeaders(await resolve(this.config.headers), headers, betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {});
  }
  async getBetasFromHeaders(requestHeaders) {
    var _a21, _b16;
    let configBetaHeader = (_a21 = (await resolve(this.config.headers))["anthropic-beta"]) != null ? _a21 : "", requestBetaHeader = (_b16 = requestHeaders == null ? void 0 : requestHeaders["anthropic-beta"]) != null ? _b16 : "";
    return new Set([
      ...configBetaHeader.toLowerCase().split(","),
      ...requestBetaHeader.toLowerCase().split(",")
    ].map((beta) => beta.trim()).filter((beta) => beta !== ""));
  }
  buildRequestUrl(isStreaming) {
    var _a21, _b16, _c;
    return (_c = (_b16 = (_a21 = this.config).buildRequestUrl) == null ? void 0 : _b16.call(_a21, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;
  }
  transformRequestBody(args) {
    var _a21, _b16, _c;
    return (_c = (_b16 = (_a21 = this.config).transformRequestBody) == null ? void 0 : _b16.call(_a21, args)) != null ? _c : args;
  }
  extractCitationDocuments(prompt) {
    let isCitationPart = (part) => {
      var _a21, _b16;
      if (part.type !== "file")
        return !1;
      if (part.mediaType !== "application/pdf" && part.mediaType !== "text/plain")
        return !1;
      let anthropic2 = (_a21 = part.providerOptions) == null ? void 0 : _a21.anthropic, citationsConfig = anthropic2 == null ? void 0 : anthropic2.citations;
      return (_b16 = citationsConfig == null ? void 0 : citationsConfig.enabled) != null ? _b16 : !1;
    };
    return prompt.filter((message) => message.role === "user").flatMap((message) => message.content).filter(isCitationPart).map((part) => {
      var _a21;
      let filePart = part;
      return {
        title: (_a21 = filePart.filename) != null ? _a21 : "Untitled Document",
        filename: filePart.filename,
        mediaType: filePart.mediaType
      };
    });
  }
  async doGenerate(options) {
    var _a21, _b16, _c, _d, _e, _f;
    let {
      args,
      warnings,
      betas,
      usesJsonResponseTool,
      toolNameMapping,
      providerOptionsName,
      usedCustomProviderKey
    } = await this.getArgs({
      ...options,
      stream: !1,
      userSuppliedBetas: await this.getBetasFromHeaders(options.headers)
    }), citationDocuments = [
      ...this.extractCitationDocuments(options.prompt)
    ], {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: this.buildRequestUrl(!1),
      headers: await this.getHeaders({ betas, headers: options.headers }),
      body: this.transformRequestBody(args),
      failedResponseHandler: anthropicFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(anthropicMessagesResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), content = [], mcpToolCalls = {}, serverToolCalls = {}, isJsonResponseFromTool = !1;
    for (let part of response.content)
      switch (part.type) {
        case "text": {
          if (!usesJsonResponseTool) {
            if (content.push({ type: "text", text: part.text }), part.citations)
              for (let citation of part.citations) {
                let source = createCitationSource(citation, citationDocuments, this.generateId);
                if (source)
                  content.push(source);
              }
          }
          break;
        }
        case "thinking": {
          content.push({
            type: "reasoning",
            text: part.thinking,
            providerMetadata: {
              anthropic: {
                signature: part.signature
              }
            }
          });
          break;
        }
        case "redacted_thinking": {
          content.push({
            type: "reasoning",
            text: "",
            providerMetadata: {
              anthropic: {
                redactedData: part.data
              }
            }
          });
          break;
        }
        case "tool_use": {
          if (usesJsonResponseTool && part.name === "json")
            isJsonResponseFromTool = !0, content.push({
              type: "text",
              text: JSON.stringify(part.input)
            });
          else {
            let caller = part.caller, callerInfo = caller ? {
              type: caller.type,
              toolId: "tool_id" in caller ? caller.tool_id : void 0
            } : void 0;
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: part.name,
              input: JSON.stringify(part.input),
              ...callerInfo && {
                providerMetadata: {
                  anthropic: {
                    caller: callerInfo
                  }
                }
              }
            });
          }
          break;
        }
        case "server_tool_use": {
          if (part.name === "text_editor_code_execution" || part.name === "bash_code_execution")
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: toolNameMapping.toCustomToolName("code_execution"),
              input: JSON.stringify({ type: part.name, ...part.input }),
              providerExecuted: !0
            });
          else if (part.name === "web_search" || part.name === "code_execution" || part.name === "web_fetch") {
            let inputToSerialize = part.name === "code_execution" && part.input != null && typeof part.input === "object" && "code" in part.input && !("type" in part.input) ? { type: "programmatic-tool-call", ...part.input } : part.input;
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: toolNameMapping.toCustomToolName(part.name),
              input: JSON.stringify(inputToSerialize),
              providerExecuted: !0
            });
          } else if (part.name === "tool_search_tool_regex" || part.name === "tool_search_tool_bm25")
            serverToolCalls[part.id] = part.name, content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: toolNameMapping.toCustomToolName(part.name),
              input: JSON.stringify(part.input),
              providerExecuted: !0
            });
          break;
        }
        case "mcp_tool_use": {
          mcpToolCalls[part.id] = {
            type: "tool-call",
            toolCallId: part.id,
            toolName: part.name,
            input: JSON.stringify(part.input),
            providerExecuted: !0,
            dynamic: !0,
            providerMetadata: {
              anthropic: {
                type: "mcp-tool-use",
                serverName: part.server_name
              }
            }
          }, content.push(mcpToolCalls[part.id]);
          break;
        }
        case "mcp_tool_result": {
          content.push({
            type: "tool-result",
            toolCallId: part.tool_use_id,
            toolName: mcpToolCalls[part.tool_use_id].toolName,
            isError: part.is_error,
            result: part.content,
            dynamic: !0,
            providerMetadata: mcpToolCalls[part.tool_use_id].providerMetadata
          });
          break;
        }
        case "web_fetch_tool_result": {
          if (part.content.type === "web_fetch_result")
            citationDocuments.push({
              title: (_a21 = part.content.content.title) != null ? _a21 : part.content.url,
              mediaType: part.content.content.source.media_type
            }), content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: toolNameMapping.toCustomToolName("web_fetch"),
              result: {
                type: "web_fetch_result",
                url: part.content.url,
                retrievedAt: part.content.retrieved_at,
                content: {
                  type: part.content.content.type,
                  title: part.content.content.title,
                  citations: part.content.content.citations,
                  source: {
                    type: part.content.content.source.type,
                    mediaType: part.content.content.source.media_type,
                    data: part.content.content.source.data
                  }
                }
              }
            });
          else if (part.content.type === "web_fetch_tool_result_error")
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: toolNameMapping.toCustomToolName("web_fetch"),
              isError: !0,
              result: {
                type: "web_fetch_tool_result_error",
                errorCode: part.content.error_code
              }
            });
          break;
        }
        case "web_search_tool_result": {
          if (Array.isArray(part.content)) {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: toolNameMapping.toCustomToolName("web_search"),
              result: part.content.map((result) => {
                var _a24;
                return {
                  url: result.url,
                  title: result.title,
                  pageAge: (_a24 = result.page_age) != null ? _a24 : null,
                  encryptedContent: result.encrypted_content,
                  type: result.type
                };
              })
            });
            for (let result of part.content)
              content.push({
                type: "source",
                sourceType: "url",
                id: this.generateId(),
                url: result.url,
                title: result.title,
                providerMetadata: {
                  anthropic: {
                    pageAge: (_b16 = result.page_age) != null ? _b16 : null
                  }
                }
              });
          } else
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: toolNameMapping.toCustomToolName("web_search"),
              isError: !0,
              result: {
                type: "web_search_tool_result_error",
                errorCode: part.content.error_code
              }
            });
          break;
        }
        case "code_execution_tool_result": {
          if (part.content.type === "code_execution_result")
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: toolNameMapping.toCustomToolName("code_execution"),
              result: {
                type: part.content.type,
                stdout: part.content.stdout,
                stderr: part.content.stderr,
                return_code: part.content.return_code,
                content: (_c = part.content.content) != null ? _c : []
              }
            });
          else if (part.content.type === "code_execution_tool_result_error")
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: toolNameMapping.toCustomToolName("code_execution"),
              isError: !0,
              result: {
                type: "code_execution_tool_result_error",
                errorCode: part.content.error_code
              }
            });
          break;
        }
        case "bash_code_execution_tool_result":
        case "text_editor_code_execution_tool_result": {
          content.push({
            type: "tool-result",
            toolCallId: part.tool_use_id,
            toolName: toolNameMapping.toCustomToolName("code_execution"),
            result: part.content
          });
          break;
        }
        case "tool_search_tool_result": {
          let providerToolName = serverToolCalls[part.tool_use_id];
          if (providerToolName == null) {
            let bm25CustomName = toolNameMapping.toCustomToolName("tool_search_tool_bm25"), regexCustomName = toolNameMapping.toCustomToolName("tool_search_tool_regex");
            if (bm25CustomName !== "tool_search_tool_bm25")
              providerToolName = "tool_search_tool_bm25";
            else if (regexCustomName !== "tool_search_tool_regex")
              providerToolName = "tool_search_tool_regex";
            else
              providerToolName = "tool_search_tool_regex";
          }
          if (part.content.type === "tool_search_tool_search_result")
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: toolNameMapping.toCustomToolName(providerToolName),
              result: part.content.tool_references.map((ref) => ({
                type: ref.type,
                toolName: ref.tool_name
              }))
            });
          else
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: toolNameMapping.toCustomToolName(providerToolName),
              isError: !0,
              result: {
                type: "tool_search_tool_result_error",
                errorCode: part.content.error_code
              }
            });
          break;
        }
      }
    return {
      content,
      finishReason: {
        unified: mapAnthropicStopReason({
          finishReason: response.stop_reason,
          isJsonResponseFromTool
        }),
        raw: (_d = response.stop_reason) != null ? _d : void 0
      },
      usage: convertAnthropicMessagesUsage(response.usage),
      request: { body: args },
      response: {
        id: (_e = response.id) != null ? _e : void 0,
        modelId: (_f = response.model) != null ? _f : void 0,
        headers: responseHeaders,
        body: rawResponse
      },
      warnings,
      providerMetadata: (() => {
        var _a24, _b23, _c2, _d2, _e2;
        let anthropicMetadata = {
          usage: response.usage,
          cacheCreationInputTokens: (_a24 = response.usage.cache_creation_input_tokens) != null ? _a24 : null,
          stopSequence: (_b23 = response.stop_sequence) != null ? _b23 : null,
          container: response.container ? {
            expiresAt: response.container.expires_at,
            id: response.container.id,
            skills: (_d2 = (_c2 = response.container.skills) == null ? void 0 : _c2.map((skill) => ({
              type: skill.type,
              skillId: skill.skill_id,
              version: skill.version
            }))) != null ? _d2 : null
          } : null,
          contextManagement: (_e2 = mapAnthropicResponseContextManagement(response.context_management)) != null ? _e2 : null
        }, providerMetadata = {
          anthropic: anthropicMetadata
        };
        if (usedCustomProviderKey && providerOptionsName !== "anthropic")
          providerMetadata[providerOptionsName] = anthropicMetadata;
        return providerMetadata;
      })()
    };
  }
  async doStream(options) {
    var _a21, _b16;
    let {
      args: body,
      warnings,
      betas,
      usesJsonResponseTool,
      toolNameMapping,
      providerOptionsName,
      usedCustomProviderKey
    } = await this.getArgs({
      ...options,
      stream: !0,
      userSuppliedBetas: await this.getBetasFromHeaders(options.headers)
    }), citationDocuments = [
      ...this.extractCitationDocuments(options.prompt)
    ], url2 = this.buildRequestUrl(!0), { responseHeaders, value: response } = await postJsonToApi({
      url: url2,
      headers: await this.getHeaders({ betas, headers: options.headers }),
      body: this.transformRequestBody(body),
      failedResponseHandler: anthropicFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(anthropicMessagesChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), finishReason = {
      unified: "other",
      raw: void 0
    }, usage = {
      input_tokens: 0,
      output_tokens: 0,
      cache_creation_input_tokens: 0,
      cache_read_input_tokens: 0
    }, contentBlocks = {}, mcpToolCalls = {}, serverToolCalls = {}, contextManagement = null, rawUsage = void 0, cacheCreationInputTokens = null, stopSequence = null, container = null, isJsonResponseFromTool = !1, blockType = void 0, generateId3 = this.generateId, transformedStream = response.pipeThrough(new TransformStream({
      start(controller) {
        controller.enqueue({ type: "stream-start", warnings });
      },
      transform(chunk, controller) {
        var _a24, _b23, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
        if (options.includeRawChunks)
          controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
        if (!chunk.success) {
          controller.enqueue({ type: "error", error: chunk.error });
          return;
        }
        let value = chunk.value;
        switch (value.type) {
          case "ping":
            return;
          case "content_block_start": {
            let part = value.content_block, contentBlockType = part.type;
            switch (blockType = contentBlockType, contentBlockType) {
              case "text": {
                if (usesJsonResponseTool)
                  return;
                contentBlocks[value.index] = { type: "text" }, controller.enqueue({
                  type: "text-start",
                  id: String(value.index)
                });
                return;
              }
              case "thinking": {
                contentBlocks[value.index] = { type: "reasoning" }, controller.enqueue({
                  type: "reasoning-start",
                  id: String(value.index)
                });
                return;
              }
              case "redacted_thinking": {
                contentBlocks[value.index] = { type: "reasoning" }, controller.enqueue({
                  type: "reasoning-start",
                  id: String(value.index),
                  providerMetadata: {
                    anthropic: {
                      redactedData: part.data
                    }
                  }
                });
                return;
              }
              case "tool_use": {
                if (usesJsonResponseTool && part.name === "json")
                  isJsonResponseFromTool = !0, contentBlocks[value.index] = { type: "text" }, controller.enqueue({
                    type: "text-start",
                    id: String(value.index)
                  });
                else {
                  let caller = part.caller, callerInfo = caller ? {
                    type: caller.type,
                    toolId: "tool_id" in caller ? caller.tool_id : void 0
                  } : void 0, initialInput = part.input && Object.keys(part.input).length > 0 ? JSON.stringify(part.input) : "";
                  contentBlocks[value.index] = {
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName: part.name,
                    input: initialInput,
                    firstDelta: initialInput.length === 0,
                    ...callerInfo && { caller: callerInfo }
                  }, controller.enqueue({
                    type: "tool-input-start",
                    id: part.id,
                    toolName: part.name
                  });
                }
                return;
              }
              case "server_tool_use": {
                if ([
                  "web_fetch",
                  "web_search",
                  "code_execution",
                  "text_editor_code_execution",
                  "bash_code_execution"
                ].includes(part.name)) {
                  let providerToolName = part.name === "text_editor_code_execution" || part.name === "bash_code_execution" ? "code_execution" : part.name, customToolName = toolNameMapping.toCustomToolName(providerToolName);
                  contentBlocks[value.index] = {
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName: customToolName,
                    input: "",
                    providerExecuted: !0,
                    firstDelta: !0,
                    providerToolName: part.name
                  }, controller.enqueue({
                    type: "tool-input-start",
                    id: part.id,
                    toolName: customToolName,
                    providerExecuted: !0
                  });
                } else if (part.name === "tool_search_tool_regex" || part.name === "tool_search_tool_bm25") {
                  serverToolCalls[part.id] = part.name;
                  let customToolName = toolNameMapping.toCustomToolName(part.name);
                  contentBlocks[value.index] = {
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName: customToolName,
                    input: "",
                    providerExecuted: !0,
                    firstDelta: !0,
                    providerToolName: part.name
                  }, controller.enqueue({
                    type: "tool-input-start",
                    id: part.id,
                    toolName: customToolName,
                    providerExecuted: !0
                  });
                }
                return;
              }
              case "web_fetch_tool_result": {
                if (part.content.type === "web_fetch_result")
                  citationDocuments.push({
                    title: (_a24 = part.content.content.title) != null ? _a24 : part.content.url,
                    mediaType: part.content.content.source.media_type
                  }), controller.enqueue({
                    type: "tool-result",
                    toolCallId: part.tool_use_id,
                    toolName: toolNameMapping.toCustomToolName("web_fetch"),
                    result: {
                      type: "web_fetch_result",
                      url: part.content.url,
                      retrievedAt: part.content.retrieved_at,
                      content: {
                        type: part.content.content.type,
                        title: part.content.content.title,
                        citations: part.content.content.citations,
                        source: {
                          type: part.content.content.source.type,
                          mediaType: part.content.content.source.media_type,
                          data: part.content.content.source.data
                        }
                      }
                    }
                  });
                else if (part.content.type === "web_fetch_tool_result_error")
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: part.tool_use_id,
                    toolName: toolNameMapping.toCustomToolName("web_fetch"),
                    isError: !0,
                    result: {
                      type: "web_fetch_tool_result_error",
                      errorCode: part.content.error_code
                    }
                  });
                return;
              }
              case "web_search_tool_result": {
                if (Array.isArray(part.content)) {
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: part.tool_use_id,
                    toolName: toolNameMapping.toCustomToolName("web_search"),
                    result: part.content.map((result) => {
                      var _a34;
                      return {
                        url: result.url,
                        title: result.title,
                        pageAge: (_a34 = result.page_age) != null ? _a34 : null,
                        encryptedContent: result.encrypted_content,
                        type: result.type
                      };
                    })
                  });
                  for (let result of part.content)
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: generateId3(),
                      url: result.url,
                      title: result.title,
                      providerMetadata: {
                        anthropic: {
                          pageAge: (_b23 = result.page_age) != null ? _b23 : null
                        }
                      }
                    });
                } else
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: part.tool_use_id,
                    toolName: toolNameMapping.toCustomToolName("web_search"),
                    isError: !0,
                    result: {
                      type: "web_search_tool_result_error",
                      errorCode: part.content.error_code
                    }
                  });
                return;
              }
              case "code_execution_tool_result": {
                if (part.content.type === "code_execution_result")
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: part.tool_use_id,
                    toolName: toolNameMapping.toCustomToolName("code_execution"),
                    result: {
                      type: part.content.type,
                      stdout: part.content.stdout,
                      stderr: part.content.stderr,
                      return_code: part.content.return_code,
                      content: (_c = part.content.content) != null ? _c : []
                    }
                  });
                else if (part.content.type === "code_execution_tool_result_error")
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: part.tool_use_id,
                    toolName: toolNameMapping.toCustomToolName("code_execution"),
                    isError: !0,
                    result: {
                      type: "code_execution_tool_result_error",
                      errorCode: part.content.error_code
                    }
                  });
                return;
              }
              case "bash_code_execution_tool_result":
              case "text_editor_code_execution_tool_result": {
                controller.enqueue({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: toolNameMapping.toCustomToolName("code_execution"),
                  result: part.content
                });
                return;
              }
              case "tool_search_tool_result": {
                let providerToolName = serverToolCalls[part.tool_use_id];
                if (providerToolName == null) {
                  let bm25CustomName = toolNameMapping.toCustomToolName("tool_search_tool_bm25"), regexCustomName = toolNameMapping.toCustomToolName("tool_search_tool_regex");
                  if (bm25CustomName !== "tool_search_tool_bm25")
                    providerToolName = "tool_search_tool_bm25";
                  else if (regexCustomName !== "tool_search_tool_regex")
                    providerToolName = "tool_search_tool_regex";
                  else
                    providerToolName = "tool_search_tool_regex";
                }
                if (part.content.type === "tool_search_tool_search_result")
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: part.tool_use_id,
                    toolName: toolNameMapping.toCustomToolName(providerToolName),
                    result: part.content.tool_references.map((ref) => ({
                      type: ref.type,
                      toolName: ref.tool_name
                    }))
                  });
                else
                  controller.enqueue({
                    type: "tool-result",
                    toolCallId: part.tool_use_id,
                    toolName: toolNameMapping.toCustomToolName(providerToolName),
                    isError: !0,
                    result: {
                      type: "tool_search_tool_result_error",
                      errorCode: part.content.error_code
                    }
                  });
                return;
              }
              case "mcp_tool_use": {
                mcpToolCalls[part.id] = {
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName: part.name,
                  input: JSON.stringify(part.input),
                  providerExecuted: !0,
                  dynamic: !0,
                  providerMetadata: {
                    anthropic: {
                      type: "mcp-tool-use",
                      serverName: part.server_name
                    }
                  }
                }, controller.enqueue(mcpToolCalls[part.id]);
                return;
              }
              case "mcp_tool_result": {
                controller.enqueue({
                  type: "tool-result",
                  toolCallId: part.tool_use_id,
                  toolName: mcpToolCalls[part.tool_use_id].toolName,
                  isError: part.is_error,
                  result: part.content,
                  dynamic: !0,
                  providerMetadata: mcpToolCalls[part.tool_use_id].providerMetadata
                });
                return;
              }
              default:
                throw Error(`Unsupported content block type: ${contentBlockType}`);
            }
          }
          case "content_block_stop": {
            if (contentBlocks[value.index] != null) {
              let contentBlock = contentBlocks[value.index];
              switch (contentBlock.type) {
                case "text": {
                  controller.enqueue({
                    type: "text-end",
                    id: String(value.index)
                  });
                  break;
                }
                case "reasoning": {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: String(value.index)
                  });
                  break;
                }
                case "tool-call":
                  if (!(usesJsonResponseTool && contentBlock.toolName === "json")) {
                    controller.enqueue({
                      type: "tool-input-end",
                      id: contentBlock.toolCallId
                    });
                    let finalInput = contentBlock.input === "" ? "{}" : contentBlock.input;
                    if (contentBlock.providerToolName === "code_execution")
                      try {
                        let parsed = JSON.parse(finalInput);
                        if (parsed != null && typeof parsed === "object" && "code" in parsed && !("type" in parsed))
                          finalInput = JSON.stringify({
                            type: "programmatic-tool-call",
                            ...parsed
                          });
                      } catch (e) {}
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: contentBlock.toolCallId,
                      toolName: contentBlock.toolName,
                      input: finalInput,
                      providerExecuted: contentBlock.providerExecuted,
                      ...contentBlock.caller && {
                        providerMetadata: {
                          anthropic: {
                            caller: contentBlock.caller
                          }
                        }
                      }
                    });
                  }
                  break;
              }
              delete contentBlocks[value.index];
            }
            blockType = void 0;
            return;
          }
          case "content_block_delta": {
            let deltaType = value.delta.type;
            switch (deltaType) {
              case "text_delta": {
                if (usesJsonResponseTool)
                  return;
                controller.enqueue({
                  type: "text-delta",
                  id: String(value.index),
                  delta: value.delta.text
                });
                return;
              }
              case "thinking_delta": {
                controller.enqueue({
                  type: "reasoning-delta",
                  id: String(value.index),
                  delta: value.delta.thinking
                });
                return;
              }
              case "signature_delta": {
                if (blockType === "thinking")
                  controller.enqueue({
                    type: "reasoning-delta",
                    id: String(value.index),
                    delta: "",
                    providerMetadata: {
                      anthropic: {
                        signature: value.delta.signature
                      }
                    }
                  });
                return;
              }
              case "input_json_delta": {
                let contentBlock = contentBlocks[value.index], delta = value.delta.partial_json;
                if (delta.length === 0)
                  return;
                if (isJsonResponseFromTool) {
                  if ((contentBlock == null ? void 0 : contentBlock.type) !== "text")
                    return;
                  controller.enqueue({
                    type: "text-delta",
                    id: String(value.index),
                    delta
                  });
                } else {
                  if ((contentBlock == null ? void 0 : contentBlock.type) !== "tool-call")
                    return;
                  if (contentBlock.firstDelta && (contentBlock.providerToolName === "bash_code_execution" || contentBlock.providerToolName === "text_editor_code_execution"))
                    delta = `{"type": "${contentBlock.providerToolName}",${delta.substring(1)}`;
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: contentBlock.toolCallId,
                    delta
                  }), contentBlock.input += delta, contentBlock.firstDelta = !1;
                }
                return;
              }
              case "citations_delta": {
                let citation = value.delta.citation, source = createCitationSource(citation, citationDocuments, generateId3);
                if (source)
                  controller.enqueue(source);
                return;
              }
              default:
                throw Error(`Unsupported delta type: ${deltaType}`);
            }
          }
          case "message_start": {
            if (usage.input_tokens = value.message.usage.input_tokens, usage.cache_read_input_tokens = (_d = value.message.usage.cache_read_input_tokens) != null ? _d : 0, usage.cache_creation_input_tokens = (_e = value.message.usage.cache_creation_input_tokens) != null ? _e : 0, rawUsage = {
              ...value.message.usage
            }, cacheCreationInputTokens = (_f = value.message.usage.cache_creation_input_tokens) != null ? _f : null, value.message.container != null)
              container = {
                expiresAt: value.message.container.expires_at,
                id: value.message.container.id,
                skills: null
              };
            if (value.message.stop_reason != null)
              finishReason = {
                unified: mapAnthropicStopReason({
                  finishReason: value.message.stop_reason,
                  isJsonResponseFromTool
                }),
                raw: value.message.stop_reason
              };
            if (controller.enqueue({
              type: "response-metadata",
              id: (_g = value.message.id) != null ? _g : void 0,
              modelId: (_h = value.message.model) != null ? _h : void 0
            }), value.message.content != null)
              for (let contentIndex = 0;contentIndex < value.message.content.length; contentIndex++) {
                let part = value.message.content[contentIndex];
                if (part.type === "tool_use") {
                  let caller = part.caller, callerInfo = caller ? {
                    type: caller.type,
                    toolId: "tool_id" in caller ? caller.tool_id : void 0
                  } : void 0;
                  controller.enqueue({
                    type: "tool-input-start",
                    id: part.id,
                    toolName: part.name
                  });
                  let inputStr = JSON.stringify((_i = part.input) != null ? _i : {});
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: part.id,
                    delta: inputStr
                  }), controller.enqueue({
                    type: "tool-input-end",
                    id: part.id
                  }), controller.enqueue({
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName: part.name,
                    input: inputStr,
                    ...callerInfo && {
                      providerMetadata: {
                        anthropic: {
                          caller: callerInfo
                        }
                      }
                    }
                  });
                }
              }
            return;
          }
          case "message_delta": {
            if (value.usage.input_tokens != null && usage.input_tokens !== value.usage.input_tokens)
              usage.input_tokens = value.usage.input_tokens;
            if (usage.output_tokens = value.usage.output_tokens, value.usage.cache_read_input_tokens != null)
              usage.cache_read_input_tokens = value.usage.cache_read_input_tokens;
            if (value.usage.cache_creation_input_tokens != null)
              usage.cache_creation_input_tokens = value.usage.cache_creation_input_tokens, cacheCreationInputTokens = value.usage.cache_creation_input_tokens;
            if (finishReason = {
              unified: mapAnthropicStopReason({
                finishReason: value.delta.stop_reason,
                isJsonResponseFromTool
              }),
              raw: (_j = value.delta.stop_reason) != null ? _j : void 0
            }, stopSequence = (_k = value.delta.stop_sequence) != null ? _k : null, container = value.delta.container != null ? {
              expiresAt: value.delta.container.expires_at,
              id: value.delta.container.id,
              skills: (_m = (_l = value.delta.container.skills) == null ? void 0 : _l.map((skill) => ({
                type: skill.type,
                skillId: skill.skill_id,
                version: skill.version
              }))) != null ? _m : null
            } : null, value.context_management)
              contextManagement = mapAnthropicResponseContextManagement(value.context_management);
            rawUsage = {
              ...rawUsage,
              ...value.usage
            };
            return;
          }
          case "message_stop": {
            let anthropicMetadata = {
              usage: rawUsage != null ? rawUsage : null,
              cacheCreationInputTokens,
              stopSequence,
              container,
              contextManagement
            }, providerMetadata = {
              anthropic: anthropicMetadata
            };
            if (usedCustomProviderKey && providerOptionsName !== "anthropic")
              providerMetadata[providerOptionsName] = anthropicMetadata;
            controller.enqueue({
              type: "finish",
              finishReason,
              usage: convertAnthropicMessagesUsage(usage),
              providerMetadata
            });
            return;
          }
          case "error": {
            controller.enqueue({ type: "error", error: value.error });
            return;
          }
          default:
            throw Error(`Unsupported chunk type: ${value}`);
        }
      }
    })), [streamForFirstChunk, streamForConsumer] = transformedStream.tee(), firstChunkReader = streamForFirstChunk.getReader();
    try {
      await firstChunkReader.read();
      let result = await firstChunkReader.read();
      if (((_a21 = result.value) == null ? void 0 : _a21.type) === "raw")
        result = await firstChunkReader.read();
      if (((_b16 = result.value) == null ? void 0 : _b16.type) === "error") {
        let error48 = result.value.error;
        throw new APICallError({
          message: error48.message,
          url: url2,
          requestBodyValues: body,
          statusCode: error48.type === "overloaded_error" ? 529 : 500,
          responseHeaders,
          responseBody: JSON.stringify(error48),
          isRetryable: error48.type === "overloaded_error"
        });
      }
    } finally {
      firstChunkReader.cancel().catch(() => {}), firstChunkReader.releaseLock();
    }
    return {
      stream: streamForConsumer,
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function getModelCapabilities(modelId) {
  if (modelId.includes("claude-sonnet-4-5") || modelId.includes("claude-opus-4-5") || modelId.includes("claude-haiku-4-5"))
    return {
      maxOutputTokens: 64000,
      supportsStructuredOutput: !0,
      isKnownModel: !0
    };
  else if (modelId.includes("claude-opus-4-1"))
    return {
      maxOutputTokens: 32000,
      supportsStructuredOutput: !0,
      isKnownModel: !0
    };
  else if (modelId.includes("claude-sonnet-4-") || modelId.includes("claude-3-7-sonnet"))
    return {
      maxOutputTokens: 64000,
      supportsStructuredOutput: !1,
      isKnownModel: !0
    };
  else if (modelId.includes("claude-opus-4-"))
    return {
      maxOutputTokens: 32000,
      supportsStructuredOutput: !1,
      isKnownModel: !0
    };
  else if (modelId.includes("claude-3-5-haiku"))
    return {
      maxOutputTokens: 8192,
      supportsStructuredOutput: !1,
      isKnownModel: !0
    };
  else if (modelId.includes("claude-3-haiku"))
    return {
      maxOutputTokens: 4096,
      supportsStructuredOutput: !1,
      isKnownModel: !0
    };
  else
    return {
      maxOutputTokens: 4096,
      supportsStructuredOutput: !1,
      isKnownModel: !1
    };
}
function mapAnthropicResponseContextManagement(contextManagement) {
  return contextManagement ? {
    appliedEdits: contextManagement.applied_edits.map((edit) => {
      switch (edit.type) {
        case "clear_tool_uses_20250919":
          return {
            type: edit.type,
            clearedToolUses: edit.cleared_tool_uses,
            clearedInputTokens: edit.cleared_input_tokens
          };
        case "clear_thinking_20251015":
          return {
            type: edit.type,
            clearedThinkingTurns: edit.cleared_thinking_turns,
            clearedInputTokens: edit.cleared_input_tokens
          };
      }
    }).filter((edit) => edit !== void 0)
  } : null;
}
var bash_20241022InputSchema = lazySchema(() => zodSchema(exports_external.object({
  command: exports_external.string(),
  restart: exports_external.boolean().optional()
}))), bash_20241022 = createProviderToolFactory({
  id: "anthropic.bash_20241022",
  inputSchema: bash_20241022InputSchema
}), bash_20250124InputSchema = lazySchema(() => zodSchema(exports_external.object({
  command: exports_external.string(),
  restart: exports_external.boolean().optional()
}))), bash_20250124 = createProviderToolFactory({
  id: "anthropic.bash_20250124",
  inputSchema: bash_20250124InputSchema
}), computer_20241022InputSchema = lazySchema(() => zodSchema(exports_external.object({
  action: exports_external.enum([
    "key",
    "type",
    "mouse_move",
    "left_click",
    "left_click_drag",
    "right_click",
    "middle_click",
    "double_click",
    "screenshot",
    "cursor_position"
  ]),
  coordinate: exports_external.array(exports_external.number().int()).optional(),
  text: exports_external.string().optional()
}))), computer_20241022 = createProviderToolFactory({
  id: "anthropic.computer_20241022",
  inputSchema: computer_20241022InputSchema
}), computer_20250124InputSchema = lazySchema(() => zodSchema(exports_external.object({
  action: exports_external.enum([
    "key",
    "hold_key",
    "type",
    "cursor_position",
    "mouse_move",
    "left_mouse_down",
    "left_mouse_up",
    "left_click",
    "left_click_drag",
    "right_click",
    "middle_click",
    "double_click",
    "triple_click",
    "scroll",
    "wait",
    "screenshot"
  ]),
  coordinate: exports_external.tuple([exports_external.number().int(), exports_external.number().int()]).optional(),
  duration: exports_external.number().optional(),
  scroll_amount: exports_external.number().optional(),
  scroll_direction: exports_external.enum(["up", "down", "left", "right"]).optional(),
  start_coordinate: exports_external.tuple([exports_external.number().int(), exports_external.number().int()]).optional(),
  text: exports_external.string().optional()
}))), computer_20250124 = createProviderToolFactory({
  id: "anthropic.computer_20250124",
  inputSchema: computer_20250124InputSchema
}), computer_20251124InputSchema = lazySchema(() => zodSchema(exports_external.object({
  action: exports_external.enum([
    "key",
    "hold_key",
    "type",
    "cursor_position",
    "mouse_move",
    "left_mouse_down",
    "left_mouse_up",
    "left_click",
    "left_click_drag",
    "right_click",
    "middle_click",
    "double_click",
    "triple_click",
    "scroll",
    "wait",
    "screenshot",
    "zoom"
  ]),
  coordinate: exports_external.tuple([exports_external.number().int(), exports_external.number().int()]).optional(),
  duration: exports_external.number().optional(),
  region: exports_external.tuple([
    exports_external.number().int(),
    exports_external.number().int(),
    exports_external.number().int(),
    exports_external.number().int()
  ]).optional(),
  scroll_amount: exports_external.number().optional(),
  scroll_direction: exports_external.enum(["up", "down", "left", "right"]).optional(),
  start_coordinate: exports_external.tuple([exports_external.number().int(), exports_external.number().int()]).optional(),
  text: exports_external.string().optional()
}))), computer_20251124 = createProviderToolFactory({
  id: "anthropic.computer_20251124",
  inputSchema: computer_20251124InputSchema
}), memory_20250818InputSchema = lazySchema(() => zodSchema(exports_external.discriminatedUnion("command", [
  exports_external.object({
    command: exports_external.literal("view"),
    path: exports_external.string(),
    view_range: exports_external.tuple([exports_external.number(), exports_external.number()]).optional()
  }),
  exports_external.object({
    command: exports_external.literal("create"),
    path: exports_external.string(),
    file_text: exports_external.string()
  }),
  exports_external.object({
    command: exports_external.literal("str_replace"),
    path: exports_external.string(),
    old_str: exports_external.string(),
    new_str: exports_external.string()
  }),
  exports_external.object({
    command: exports_external.literal("insert"),
    path: exports_external.string(),
    insert_line: exports_external.number(),
    insert_text: exports_external.string()
  }),
  exports_external.object({
    command: exports_external.literal("delete"),
    path: exports_external.string()
  }),
  exports_external.object({
    command: exports_external.literal("rename"),
    old_path: exports_external.string(),
    new_path: exports_external.string()
  })
]))), memory_20250818 = createProviderToolFactory({
  id: "anthropic.memory_20250818",
  inputSchema: memory_20250818InputSchema
}), textEditor_20241022InputSchema = lazySchema(() => zodSchema(exports_external.object({
  command: exports_external.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
  path: exports_external.string(),
  file_text: exports_external.string().optional(),
  insert_line: exports_external.number().int().optional(),
  new_str: exports_external.string().optional(),
  insert_text: exports_external.string().optional(),
  old_str: exports_external.string().optional(),
  view_range: exports_external.array(exports_external.number().int()).optional()
}))), textEditor_20241022 = createProviderToolFactory({
  id: "anthropic.text_editor_20241022",
  inputSchema: textEditor_20241022InputSchema
}), textEditor_20250124InputSchema = lazySchema(() => zodSchema(exports_external.object({
  command: exports_external.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
  path: exports_external.string(),
  file_text: exports_external.string().optional(),
  insert_line: exports_external.number().int().optional(),
  new_str: exports_external.string().optional(),
  insert_text: exports_external.string().optional(),
  old_str: exports_external.string().optional(),
  view_range: exports_external.array(exports_external.number().int()).optional()
}))), textEditor_20250124 = createProviderToolFactory({
  id: "anthropic.text_editor_20250124",
  inputSchema: textEditor_20250124InputSchema
}), textEditor_20250429InputSchema = lazySchema(() => zodSchema(exports_external.object({
  command: exports_external.enum(["view", "create", "str_replace", "insert"]),
  path: exports_external.string(),
  file_text: exports_external.string().optional(),
  insert_line: exports_external.number().int().optional(),
  new_str: exports_external.string().optional(),
  insert_text: exports_external.string().optional(),
  old_str: exports_external.string().optional(),
  view_range: exports_external.array(exports_external.number().int()).optional()
}))), textEditor_20250429 = createProviderToolFactory({
  id: "anthropic.text_editor_20250429",
  inputSchema: textEditor_20250429InputSchema
}), toolSearchBm25_20251119OutputSchema = lazySchema(() => zodSchema(exports_external.array(exports_external.object({
  type: exports_external.literal("tool_reference"),
  toolName: exports_external.string()
})))), toolSearchBm25_20251119InputSchema = lazySchema(() => zodSchema(exports_external.object({
  query: exports_external.string(),
  limit: exports_external.number().optional()
}))), factory7 = createProviderToolFactoryWithOutputSchema({
  id: "anthropic.tool_search_bm25_20251119",
  inputSchema: toolSearchBm25_20251119InputSchema,
  outputSchema: toolSearchBm25_20251119OutputSchema,
  supportsDeferredResults: !0
}), toolSearchBm25_20251119 = (args = {}) => {
  return factory7(args);
}, anthropicTools = {
  bash_20241022,
  bash_20250124,
  codeExecution_20250522,
  codeExecution_20250825,
  computer_20241022,
  computer_20250124,
  computer_20251124,
  memory_20250818,
  textEditor_20241022,
  textEditor_20250124,
  textEditor_20250429,
  textEditor_20250728,
  webFetch_20250910,
  webSearch_20250305,
  toolSearchRegex_20251119,
  toolSearchBm25_20251119
};
function createAnthropic(options = {}) {
  var _a21, _b16;
  let baseURL = (_a21 = withoutTrailingSlash(loadOptionalSetting({
    settingValue: options.baseURL,
    environmentVariableName: "ANTHROPIC_BASE_URL"
  }))) != null ? _a21 : "https://api.anthropic.com/v1", providerName = (_b16 = options.name) != null ? _b16 : "anthropic.messages";
  if (options.apiKey && options.authToken)
    throw new InvalidArgumentError({
      argument: "apiKey/authToken",
      message: "Both apiKey and authToken were provided. Please use only one authentication method."
    });
  let getHeaders = () => {
    let authHeaders = options.authToken ? { Authorization: `Bearer ${options.authToken}` } : {
      "x-api-key": loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "ANTHROPIC_API_KEY",
        description: "Anthropic"
      })
    };
    return withUserAgentSuffix({
      "anthropic-version": "2023-06-01",
      ...authHeaders,
      ...options.headers
    }, `ai-sdk/anthropic/${VERSION8}`);
  }, createChatModel = (modelId) => {
    var _a24;
    return new AnthropicMessagesLanguageModel(modelId, {
      provider: providerName,
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: (_a24 = options.generateId) != null ? _a24 : generateId,
      supportedUrls: () => ({
        "image/*": [/^https?:\/\/.*$/],
        "application/pdf": [/^https?:\/\/.*$/]
      })
    });
  }, provider = function(modelId) {
    if (new.target)
      throw Error("The Anthropic model function cannot be called with the new keyword.");
    return createChatModel(modelId);
  };
  return provider.specificationVersion = "v3", provider.languageModel = createChatModel, provider.chat = createChatModel, provider.messages = createChatModel, provider.embeddingModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "embeddingModel" });
  }, provider.textEmbeddingModel = provider.embeddingModel, provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  }, provider.tools = anthropicTools, provider;
}
var anthropic = createAnthropic();
// node_modules/@ai-sdk/openai-compatible/dist/index.mjs
var openaiCompatibleErrorDataSchema = exports_external.object({
  error: exports_external.object({
    message: exports_external.string(),
    type: exports_external.string().nullish(),
    param: exports_external.any().nullish(),
    code: exports_external.union([exports_external.string(), exports_external.number()]).nullish()
  })
}), defaultOpenAICompatibleErrorStructure = {
  errorSchema: openaiCompatibleErrorDataSchema,
  errorToMessage: (data) => data.error.message
};
function convertOpenAICompatibleChatUsage(usage) {
  var _a21, _b16, _c, _d, _e, _f;
  if (usage == null)
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  let promptTokens = (_a21 = usage.prompt_tokens) != null ? _a21 : 0, completionTokens = (_b16 = usage.completion_tokens) != null ? _b16 : 0, cacheReadTokens = (_d = (_c = usage.prompt_tokens_details) == null ? void 0 : _c.cached_tokens) != null ? _d : 0, reasoningTokens = (_f = (_e = usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens - cacheReadTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: completionTokens,
      text: completionTokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function getOpenAIMetadata(message) {
  var _a21, _b16;
  return (_b16 = (_a21 = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a21.openaiCompatible) != null ? _b16 : {};
}
function getAudioFormat(mediaType) {
  switch (mediaType) {
    case "audio/wav":
      return "wav";
    case "audio/mp3":
    case "audio/mpeg":
      return "mp3";
    default:
      return null;
  }
}
function convertToOpenAICompatibleChatMessages(prompt) {
  var _a21, _b16, _c;
  let messages = [];
  for (let { role, content, ...message } of prompt) {
    let metadata = getOpenAIMetadata({ ...message });
    switch (role) {
      case "system": {
        messages.push({ role: "system", content, ...metadata });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({
            role: "user",
            content: content[0].text,
            ...getOpenAIMetadata(content[0])
          });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            var _a24;
            let partMetadata = getOpenAIMetadata(part);
            switch (part.type) {
              case "text":
                return { type: "text", text: part.text, ...partMetadata };
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  let mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                    },
                    ...partMetadata
                  };
                }
                if (part.mediaType.startsWith("audio/")) {
                  if (part.data instanceof URL)
                    throw new UnsupportedFunctionalityError({
                      functionality: "audio file parts with URLs"
                    });
                  let format = getAudioFormat(part.mediaType);
                  if (format === null)
                    throw new UnsupportedFunctionalityError({
                      functionality: `audio media type ${part.mediaType}`
                    });
                  return {
                    type: "input_audio",
                    input_audio: {
                      data: convertToBase64(part.data),
                      format
                    },
                    ...partMetadata
                  };
                }
                if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL)
                    throw new UnsupportedFunctionalityError({
                      functionality: "PDF file parts with URLs"
                    });
                  return {
                    type: "file",
                    file: {
                      filename: (_a24 = part.filename) != null ? _a24 : "document.pdf",
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    },
                    ...partMetadata
                  };
                }
                if (part.mediaType.startsWith("text/"))
                  return {
                    type: "text",
                    text: part.data instanceof URL ? part.data.toString() : typeof part.data === "string" ? part.data : (/* @__PURE__ */ new TextDecoder()).decode(part.data),
                    ...partMetadata
                  };
                throw new UnsupportedFunctionalityError({
                  functionality: `file part media type ${part.mediaType}`
                });
              }
            }
          }),
          ...metadata
        });
        break;
      }
      case "assistant": {
        let text2 = "", reasoning = "", toolCalls = [];
        for (let part of content) {
          let partMetadata = getOpenAIMetadata(part);
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "reasoning": {
              reasoning += part.text;
              break;
            }
            case "tool-call": {
              let thoughtSignature = (_b16 = (_a21 = part.providerOptions) == null ? void 0 : _a21.google) == null ? void 0 : _b16.thoughtSignature;
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                },
                ...partMetadata,
                ...thoughtSignature ? {
                  extra_content: {
                    google: {
                      thought_signature: String(thoughtSignature)
                    }
                  }
                } : {}
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text2,
          ...reasoning.length > 0 ? { reasoning_content: reasoning } : {},
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          ...metadata
        });
        break;
      }
      case "tool": {
        for (let toolResponse of content) {
          if (toolResponse.type === "tool-approval-response")
            continue;
          let output = toolResponse.output, contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_c = output.reason) != null ? _c : "Tool execution denied.";
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          let toolResponseMetadata = getOpenAIMetadata(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue,
            ...toolResponseMetadata
          });
        }
        break;
      }
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  }
  return messages;
}
function getResponseMetadata3({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1000) : void 0
  };
}
function mapOpenAICompatibleFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "other";
  }
}
var openaiCompatibleProviderOptions = exports_external.object({
  user: exports_external.string().optional(),
  reasoningEffort: exports_external.string().optional(),
  textVerbosity: exports_external.string().optional(),
  strictJsonSchema: exports_external.boolean().optional()
});
function prepareTools4({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  let toolWarnings = [];
  if (tools == null)
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  let openaiCompatTools = [];
  for (let tool2 of tools)
    if (tool2.type === "provider")
      toolWarnings.push({
        type: "unsupported",
        feature: `provider-defined tool ${tool2.id}`
      });
    else
      openaiCompatTools.push({
        type: "function",
        function: {
          name: tool2.name,
          description: tool2.description,
          parameters: tool2.inputSchema,
          ...tool2.strict != null ? { strict: tool2.strict } : {}
        }
      });
  if (toolChoice == null)
    return { tools: openaiCompatTools, toolChoice: void 0, toolWarnings };
  let type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiCompatTools, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiCompatTools,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default:
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${type}`
      });
  }
}
var OpenAICompatibleChatLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3";
    var _a21, _b16;
    this.modelId = modelId, this.config = config2;
    let errorStructure = (_a21 = config2.errorStructure) != null ? _a21 : defaultOpenAICompatibleErrorStructure;
    this.chunkSchema = createOpenAICompatibleChatChunkSchema(errorStructure.errorSchema), this.failedResponseHandler = createJsonErrorResponseHandler(errorStructure), this.supportsStructuredOutputs = (_b16 = config2.supportsStructuredOutputs) != null ? _b16 : !1;
  }
  get provider() {
    return this.config.provider;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  get supportedUrls() {
    var _a21, _b16, _c;
    return (_c = (_b16 = (_a21 = this.config).supportedUrls) == null ? void 0 : _b16.call(_a21)) != null ? _c : {};
  }
  transformRequestBody(args) {
    var _a21, _b16, _c;
    return (_c = (_b16 = (_a21 = this.config).transformRequestBody) == null ? void 0 : _b16.call(_a21, args)) != null ? _c : args;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    providerOptions,
    stopSequences,
    responseFormat,
    seed,
    toolChoice,
    tools
  }) {
    var _a21, _b16, _c, _d, _e;
    let warnings = [], deprecatedOptions = await parseProviderOptions({
      provider: "openai-compatible",
      providerOptions,
      schema: openaiCompatibleProviderOptions
    });
    if (deprecatedOptions != null)
      warnings.push({
        type: "other",
        message: "The 'openai-compatible' key in providerOptions is deprecated. Use 'openaiCompatible' instead."
      });
    let compatibleOptions = Object.assign(deprecatedOptions != null ? deprecatedOptions : {}, (_a21 = await parseProviderOptions({
      provider: "openaiCompatible",
      providerOptions,
      schema: openaiCompatibleProviderOptions
    })) != null ? _a21 : {}, (_b16 = await parseProviderOptions({
      provider: this.providerOptionsName,
      providerOptions,
      schema: openaiCompatibleProviderOptions
    })) != null ? _b16 : {}), strictJsonSchema = (_c = compatibleOptions == null ? void 0 : compatibleOptions.strictJsonSchema) != null ? _c : !0;
    if (topK != null)
      warnings.push({ type: "unsupported", feature: "topK" });
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !this.supportsStructuredOutputs)
      warnings.push({
        type: "unsupported",
        feature: "responseFormat",
        details: "JSON response format schema is only supported with structuredOutputs"
      });
    let {
      tools: openaiTools2,
      toolChoice: openaiToolChoice,
      toolWarnings
    } = prepareTools4({
      tools,
      toolChoice
    });
    return {
      args: {
        model: this.modelId,
        user: compatibleOptions.user,
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? this.supportsStructuredOutputs === !0 && responseFormat.schema != null ? {
          type: "json_schema",
          json_schema: {
            schema: responseFormat.schema,
            strict: strictJsonSchema,
            name: (_d = responseFormat.name) != null ? _d : "response",
            description: responseFormat.description
          }
        } : { type: "json_object" } : void 0,
        stop: stopSequences,
        seed,
        ...Object.fromEntries(Object.entries((_e = providerOptions == null ? void 0 : providerOptions[this.providerOptionsName]) != null ? _e : {}).filter(([key]) => !Object.keys(openaiCompatibleProviderOptions.shape).includes(key))),
        reasoning_effort: compatibleOptions.reasoningEffort,
        verbosity: compatibleOptions.textVerbosity,
        messages: convertToOpenAICompatibleChatMessages(prompt),
        tools: openaiTools2,
        tool_choice: openaiToolChoice
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  async doGenerate(options) {
    var _a21, _b16, _c, _d, _e, _f, _g, _h;
    let { args, warnings } = await this.getArgs({ ...options }), transformedBody = this.transformRequestBody(args), body = JSON.stringify(transformedBody), {
      responseHeaders,
      value: responseBody,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: transformedBody,
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(OpenAICompatibleChatResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), choice2 = responseBody.choices[0], content = [], text2 = choice2.message.content;
    if (text2 != null && text2.length > 0)
      content.push({ type: "text", text: text2 });
    let reasoning = (_a21 = choice2.message.reasoning_content) != null ? _a21 : choice2.message.reasoning;
    if (reasoning != null && reasoning.length > 0)
      content.push({
        type: "reasoning",
        text: reasoning
      });
    if (choice2.message.tool_calls != null)
      for (let toolCall of choice2.message.tool_calls) {
        let thoughtSignature = (_c = (_b16 = toolCall.extra_content) == null ? void 0 : _b16.google) == null ? void 0 : _c.thought_signature;
        content.push({
          type: "tool-call",
          toolCallId: (_d = toolCall.id) != null ? _d : generateId(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments,
          ...thoughtSignature ? {
            providerMetadata: {
              [this.providerOptionsName]: { thoughtSignature }
            }
          } : {}
        });
      }
    let providerMetadata = {
      [this.providerOptionsName]: {},
      ...await ((_f = (_e = this.config.metadataExtractor) == null ? void 0 : _e.extractMetadata) == null ? void 0 : _f.call(_e, {
        parsedBody: rawResponse
      }))
    }, completionTokenDetails = (_g = responseBody.usage) == null ? void 0 : _g.completion_tokens_details;
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null)
      providerMetadata[this.providerOptionsName].acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null)
      providerMetadata[this.providerOptionsName].rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
    return {
      content,
      finishReason: {
        unified: mapOpenAICompatibleFinishReason(choice2.finish_reason),
        raw: (_h = choice2.finish_reason) != null ? _h : void 0
      },
      usage: convertOpenAICompatibleChatUsage(responseBody.usage),
      providerMetadata,
      request: { body },
      response: {
        ...getResponseMetadata3(responseBody),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    var _a21;
    let { args, warnings } = await this.getArgs({ ...options }), body = this.transformRequestBody({
      ...args,
      stream: !0,
      stream_options: this.config.includeUsage ? { include_usage: !0 } : void 0
    }), metadataExtractor = (_a21 = this.config.metadataExtractor) == null ? void 0 : _a21.createStreamExtractor(), { responseHeaders, value: response } = await postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(this.chunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), toolCalls = [], finishReason = {
      unified: "other",
      raw: void 0
    }, usage = void 0, isFirstChunk = !0, providerOptionsName = this.providerOptionsName, isActiveReasoning = !1, isActiveText = !1;
    return {
      stream: response.pipeThrough(new TransformStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings });
        },
        transform(chunk, controller) {
          var _a24, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
          if (options.includeRawChunks)
            controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
          if (!chunk.success) {
            finishReason = { unified: "error", raw: void 0 }, controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          if (metadataExtractor == null || metadataExtractor.processChunk(chunk.rawValue), "error" in chunk.value) {
            finishReason = { unified: "error", raw: void 0 }, controller.enqueue({
              type: "error",
              error: chunk.value.error.message
            });
            return;
          }
          let value = chunk.value;
          if (isFirstChunk)
            isFirstChunk = !1, controller.enqueue({
              type: "response-metadata",
              ...getResponseMetadata3(value)
            });
          if (value.usage != null)
            usage = value.usage;
          let choice2 = value.choices[0];
          if ((choice2 == null ? void 0 : choice2.finish_reason) != null)
            finishReason = {
              unified: mapOpenAICompatibleFinishReason(choice2.finish_reason),
              raw: (_a24 = choice2.finish_reason) != null ? _a24 : void 0
            };
          if ((choice2 == null ? void 0 : choice2.delta) == null)
            return;
          let delta = choice2.delta, reasoningContent = (_b16 = delta.reasoning_content) != null ? _b16 : delta.reasoning;
          if (reasoningContent) {
            if (!isActiveReasoning)
              controller.enqueue({
                type: "reasoning-start",
                id: "reasoning-0"
              }), isActiveReasoning = !0;
            controller.enqueue({
              type: "reasoning-delta",
              id: "reasoning-0",
              delta: reasoningContent
            });
          }
          if (delta.content) {
            if (isActiveReasoning)
              controller.enqueue({
                type: "reasoning-end",
                id: "reasoning-0"
              }), isActiveReasoning = !1;
            if (!isActiveText)
              controller.enqueue({ type: "text-start", id: "txt-0" }), isActiveText = !0;
            controller.enqueue({
              type: "text-delta",
              id: "txt-0",
              delta: delta.content
            });
          }
          if (delta.tool_calls != null) {
            if (isActiveReasoning)
              controller.enqueue({
                type: "reasoning-end",
                id: "reasoning-0"
              }), isActiveReasoning = !1;
            for (let toolCallDelta of delta.tool_calls) {
              let index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length;
              if (toolCalls[index] == null) {
                if (toolCallDelta.id == null)
                  throw new InvalidResponseDataError({
                    data: toolCallDelta,
                    message: "Expected 'id' to be a string."
                  });
                if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null)
                  throw new InvalidResponseDataError({
                    data: toolCallDelta,
                    message: "Expected 'function.name' to be a string."
                  });
                controller.enqueue({
                  type: "tool-input-start",
                  id: toolCallDelta.id,
                  toolName: toolCallDelta.function.name
                }), toolCalls[index] = {
                  id: toolCallDelta.id,
                  type: "function",
                  function: {
                    name: toolCallDelta.function.name,
                    arguments: (_e = toolCallDelta.function.arguments) != null ? _e : ""
                  },
                  hasFinished: !1,
                  thoughtSignature: (_h = (_g = (_f = toolCallDelta.extra_content) == null ? void 0 : _f.google) == null ? void 0 : _g.thought_signature) != null ? _h : void 0
                };
                let toolCall2 = toolCalls[index];
                if (((_i = toolCall2.function) == null ? void 0 : _i.name) != null && ((_j = toolCall2.function) == null ? void 0 : _j.arguments) != null) {
                  if (toolCall2.function.arguments.length > 0)
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall2.id,
                      delta: toolCall2.function.arguments
                    });
                  if (isParsableJson(toolCall2.function.arguments))
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall2.id
                    }), controller.enqueue({
                      type: "tool-call",
                      toolCallId: (_k = toolCall2.id) != null ? _k : generateId(),
                      toolName: toolCall2.function.name,
                      input: toolCall2.function.arguments,
                      ...toolCall2.thoughtSignature ? {
                        providerMetadata: {
                          [providerOptionsName]: {
                            thoughtSignature: toolCall2.thoughtSignature
                          }
                        }
                      } : {}
                    }), toolCall2.hasFinished = !0;
                }
                continue;
              }
              let toolCall = toolCalls[index];
              if (toolCall.hasFinished)
                continue;
              if (((_l = toolCallDelta.function) == null ? void 0 : _l.arguments) != null)
                toolCall.function.arguments += (_n = (_m = toolCallDelta.function) == null ? void 0 : _m.arguments) != null ? _n : "";
              if (controller.enqueue({
                type: "tool-input-delta",
                id: toolCall.id,
                delta: (_o = toolCallDelta.function.arguments) != null ? _o : ""
              }), ((_p = toolCall.function) == null ? void 0 : _p.name) != null && ((_q = toolCall.function) == null ? void 0 : _q.arguments) != null && isParsableJson(toolCall.function.arguments))
                controller.enqueue({
                  type: "tool-input-end",
                  id: toolCall.id
                }), controller.enqueue({
                  type: "tool-call",
                  toolCallId: (_r = toolCall.id) != null ? _r : generateId(),
                  toolName: toolCall.function.name,
                  input: toolCall.function.arguments,
                  ...toolCall.thoughtSignature ? {
                    providerMetadata: {
                      [providerOptionsName]: {
                        thoughtSignature: toolCall.thoughtSignature
                      }
                    }
                  } : {}
                }), toolCall.hasFinished = !0;
            }
          }
        },
        flush(controller) {
          var _a24, _b16, _c, _d, _e;
          if (isActiveReasoning)
            controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
          if (isActiveText)
            controller.enqueue({ type: "text-end", id: "txt-0" });
          for (let toolCall of toolCalls.filter((toolCall2) => !toolCall2.hasFinished))
            controller.enqueue({
              type: "tool-input-end",
              id: toolCall.id
            }), controller.enqueue({
              type: "tool-call",
              toolCallId: (_a24 = toolCall.id) != null ? _a24 : generateId(),
              toolName: toolCall.function.name,
              input: toolCall.function.arguments,
              ...toolCall.thoughtSignature ? {
                providerMetadata: {
                  [providerOptionsName]: {
                    thoughtSignature: toolCall.thoughtSignature
                  }
                }
              } : {}
            });
          let providerMetadata = {
            [providerOptionsName]: {},
            ...metadataExtractor == null ? void 0 : metadataExtractor.buildMetadata()
          };
          if (((_b16 = usage == null ? void 0 : usage.completion_tokens_details) == null ? void 0 : _b16.accepted_prediction_tokens) != null)
            providerMetadata[providerOptionsName].acceptedPredictionTokens = (_c = usage == null ? void 0 : usage.completion_tokens_details) == null ? void 0 : _c.accepted_prediction_tokens;
          if (((_d = usage == null ? void 0 : usage.completion_tokens_details) == null ? void 0 : _d.rejected_prediction_tokens) != null)
            providerMetadata[providerOptionsName].rejectedPredictionTokens = (_e = usage == null ? void 0 : usage.completion_tokens_details) == null ? void 0 : _e.rejected_prediction_tokens;
          controller.enqueue({
            type: "finish",
            finishReason,
            usage: convertOpenAICompatibleChatUsage(usage),
            providerMetadata
          });
        }
      })),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
}, openaiCompatibleTokenUsageSchema = exports_external.object({
  prompt_tokens: exports_external.number().nullish(),
  completion_tokens: exports_external.number().nullish(),
  total_tokens: exports_external.number().nullish(),
  prompt_tokens_details: exports_external.object({
    cached_tokens: exports_external.number().nullish()
  }).nullish(),
  completion_tokens_details: exports_external.object({
    reasoning_tokens: exports_external.number().nullish(),
    accepted_prediction_tokens: exports_external.number().nullish(),
    rejected_prediction_tokens: exports_external.number().nullish()
  }).nullish()
}).nullish(), OpenAICompatibleChatResponseSchema = exports_external.looseObject({
  id: exports_external.string().nullish(),
  created: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  choices: exports_external.array(exports_external.object({
    message: exports_external.object({
      role: exports_external.literal("assistant").nullish(),
      content: exports_external.string().nullish(),
      reasoning_content: exports_external.string().nullish(),
      reasoning: exports_external.string().nullish(),
      tool_calls: exports_external.array(exports_external.object({
        id: exports_external.string().nullish(),
        function: exports_external.object({
          name: exports_external.string(),
          arguments: exports_external.string()
        }),
        extra_content: exports_external.object({
          google: exports_external.object({
            thought_signature: exports_external.string().nullish()
          }).nullish()
        }).nullish()
      })).nullish()
    }),
    finish_reason: exports_external.string().nullish()
  })),
  usage: openaiCompatibleTokenUsageSchema
}), chunkBaseSchema = exports_external.looseObject({
  id: exports_external.string().nullish(),
  created: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  choices: exports_external.array(exports_external.object({
    delta: exports_external.object({
      role: exports_external.enum(["assistant"]).nullish(),
      content: exports_external.string().nullish(),
      reasoning_content: exports_external.string().nullish(),
      reasoning: exports_external.string().nullish(),
      tool_calls: exports_external.array(exports_external.object({
        index: exports_external.number().nullish(),
        id: exports_external.string().nullish(),
        function: exports_external.object({
          name: exports_external.string().nullish(),
          arguments: exports_external.string().nullish()
        }),
        extra_content: exports_external.object({
          google: exports_external.object({
            thought_signature: exports_external.string().nullish()
          }).nullish()
        }).nullish()
      })).nullish()
    }).nullish(),
    finish_reason: exports_external.string().nullish()
  })),
  usage: openaiCompatibleTokenUsageSchema
}), createOpenAICompatibleChatChunkSchema = (errorSchema) => exports_external.union([chunkBaseSchema, errorSchema]);
var openaiCompatibleCompletionProviderOptions = exports_external.object({
  echo: exports_external.boolean().optional(),
  logitBias: exports_external.record(exports_external.string(), exports_external.number()).optional(),
  suffix: exports_external.string().optional(),
  user: exports_external.string().optional()
});
var usageSchema2 = exports_external.object({
  prompt_tokens: exports_external.number(),
  completion_tokens: exports_external.number(),
  total_tokens: exports_external.number()
}), openaiCompatibleCompletionResponseSchema = exports_external.object({
  id: exports_external.string().nullish(),
  created: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  choices: exports_external.array(exports_external.object({
    text: exports_external.string(),
    finish_reason: exports_external.string()
  })),
  usage: usageSchema2.nullish()
});
var openaiCompatibleEmbeddingProviderOptions = exports_external.object({
  dimensions: exports_external.number().optional(),
  user: exports_external.string().optional()
});
var openaiTextEmbeddingResponseSchema2 = exports_external.object({
  data: exports_external.array(exports_external.object({ embedding: exports_external.array(exports_external.number()) })),
  usage: exports_external.object({ prompt_tokens: exports_external.number() }).nullish(),
  providerMetadata: exports_external.record(exports_external.string(), exports_external.record(exports_external.string(), exports_external.any())).optional()
}), OpenAICompatibleImageModel = class {
  constructor(modelId, config2) {
    this.modelId = modelId, this.config = config2, this.specificationVersion = "v3", this.maxImagesPerCall = 10;
  }
  get provider() {
    return this.config.provider;
  }
  get providerOptionsKey() {
    return this.config.provider.split(".")[0].trim();
  }
  getArgs(providerOptions) {
    return {
      ...providerOptions[this.providerOptionsKey],
      ...providerOptions[toCamelCase(this.providerOptionsKey)]
    };
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal,
    files,
    mask
  }) {
    var _a21, _b16, _c, _d, _e;
    let warnings = [];
    if (aspectRatio != null)
      warnings.push({
        type: "unsupported",
        feature: "aspectRatio",
        details: "This model does not support aspect ratio. Use `size` instead."
      });
    if (seed != null)
      warnings.push({ type: "unsupported", feature: "seed" });
    let currentDate = (_c = (_b16 = (_a21 = this.config._internal) == null ? void 0 : _a21.currentDate) == null ? void 0 : _b16.call(_a21)) != null ? _c : /* @__PURE__ */ new Date, args = this.getArgs(providerOptions);
    if (files != null && files.length > 0) {
      let { value: response2, responseHeaders: responseHeaders2 } = await postFormDataToApi({
        url: this.config.url({
          path: "/images/edits",
          modelId: this.modelId
        }),
        headers: combineHeaders(this.config.headers(), headers),
        formData: convertToFormData({
          model: this.modelId,
          prompt,
          image: await Promise.all(files.map((file2) => fileToBlob2(file2))),
          mask: mask != null ? await fileToBlob2(mask) : void 0,
          n,
          size,
          ...args
        }),
        failedResponseHandler: createJsonErrorResponseHandler((_d = this.config.errorStructure) != null ? _d : defaultOpenAICompatibleErrorStructure),
        successfulResponseHandler: createJsonResponseHandler(openaiCompatibleImageResponseSchema),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        images: response2.data.map((item) => item.b64_json),
        warnings,
        response: {
          timestamp: currentDate,
          modelId: this.modelId,
          headers: responseHeaders2
        }
      };
    }
    let { value: response, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/images/generations",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), headers),
      body: {
        model: this.modelId,
        prompt,
        n,
        size,
        ...args,
        response_format: "b64_json"
      },
      failedResponseHandler: createJsonErrorResponseHandler((_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure),
      successfulResponseHandler: createJsonResponseHandler(openaiCompatibleImageResponseSchema),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.data.map((item) => item.b64_json),
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      }
    };
  }
}, openaiCompatibleImageResponseSchema = exports_external.object({
  data: exports_external.array(exports_external.object({ b64_json: exports_external.string() }))
});
async function fileToBlob2(file2) {
  if (file2.type === "url")
    return downloadBlob(file2.url);
  let data = file2.data instanceof Uint8Array ? file2.data : convertBase64ToUint8Array(file2.data);
  return new Blob([data], { type: file2.mediaType });
}
function toCamelCase(str) {
  return str.replace(/[_-]([a-z])/g, (g) => g[1].toUpperCase());
}

// node_modules/@ai-sdk/xai/dist/index.mjs
function convertToXaiChatMessages(prompt) {
  var _a21;
  let messages = [], warnings = [];
  for (let { role, content } of prompt)
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text":
                return { type: "text", text: part.text };
              case "file":
                if (part.mediaType.startsWith("image/")) {
                  let mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                    }
                  };
                } else
                  throw new UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
            }
          })
        });
        break;
      }
      case "assistant": {
        let text2 = "", toolCalls = [];
        for (let part of content)
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        messages.push({
          role: "assistant",
          content: text2,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (let toolResponse of content) {
          if (toolResponse.type === "tool-approval-response")
            continue;
          let output = toolResponse.output, contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "execution-denied":
              contentValue = (_a21 = output.reason) != null ? _a21 : "Tool execution denied.";
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  return { messages, warnings };
}
function convertXaiChatUsage(usage) {
  var _a21, _b16, _c, _d;
  let cacheReadTokens = (_b16 = (_a21 = usage.prompt_tokens_details) == null ? void 0 : _a21.cached_tokens) != null ? _b16 : 0, reasoningTokens = (_d = (_c = usage.completion_tokens_details) == null ? void 0 : _c.reasoning_tokens) != null ? _d : 0;
  return {
    inputTokens: {
      total: usage.prompt_tokens,
      noCache: usage.prompt_tokens - cacheReadTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: usage.completion_tokens,
      text: usage.completion_tokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function getResponseMetadata4({
  id,
  model,
  created,
  created_at
}) {
  let unixTime = created != null ? created : created_at;
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: unixTime != null ? new Date(unixTime * 1000) : void 0
  };
}
function mapXaiFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "other";
  }
}
var webSourceSchema = exports_external.object({
  type: exports_external.literal("web"),
  country: exports_external.string().length(2).optional(),
  excludedWebsites: exports_external.array(exports_external.string()).max(5).optional(),
  allowedWebsites: exports_external.array(exports_external.string()).max(5).optional(),
  safeSearch: exports_external.boolean().optional()
}), xSourceSchema = exports_external.object({
  type: exports_external.literal("x"),
  excludedXHandles: exports_external.array(exports_external.string()).optional(),
  includedXHandles: exports_external.array(exports_external.string()).optional(),
  postFavoriteCount: exports_external.number().int().optional(),
  postViewCount: exports_external.number().int().optional(),
  xHandles: exports_external.array(exports_external.string()).optional()
}), newsSourceSchema = exports_external.object({
  type: exports_external.literal("news"),
  country: exports_external.string().length(2).optional(),
  excludedWebsites: exports_external.array(exports_external.string()).max(5).optional(),
  safeSearch: exports_external.boolean().optional()
}), rssSourceSchema = exports_external.object({
  type: exports_external.literal("rss"),
  links: exports_external.array(exports_external.string().url()).max(1)
}), searchSourceSchema = exports_external.discriminatedUnion("type", [
  webSourceSchema,
  xSourceSchema,
  newsSourceSchema,
  rssSourceSchema
]), xaiProviderOptions = exports_external.object({
  reasoningEffort: exports_external.enum(["low", "high"]).optional(),
  parallel_function_calling: exports_external.boolean().optional(),
  searchParameters: exports_external.object({
    mode: exports_external.enum(["off", "auto", "on"]),
    returnCitations: exports_external.boolean().optional(),
    fromDate: exports_external.string().optional(),
    toDate: exports_external.string().optional(),
    maxSearchResults: exports_external.number().min(1).max(50).optional(),
    sources: exports_external.array(searchSourceSchema).optional()
  }).optional()
}), xaiErrorDataSchema = exports_external.object({
  error: exports_external.object({
    message: exports_external.string(),
    type: exports_external.string().nullish(),
    param: exports_external.any().nullish(),
    code: exports_external.union([exports_external.string(), exports_external.number()]).nullish()
  })
}), xaiFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: xaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
function prepareTools5({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  let toolWarnings = [];
  if (tools == null)
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  let xaiTools2 = [];
  for (let tool2 of tools)
    if (tool2.type === "provider")
      toolWarnings.push({
        type: "unsupported",
        feature: `provider-defined tool ${tool2.name}`
      });
    else
      xaiTools2.push({
        type: "function",
        function: {
          name: tool2.name,
          description: tool2.description,
          parameters: tool2.inputSchema
        }
      });
  if (toolChoice == null)
    return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
  let type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: xaiTools2, toolChoice: type, toolWarnings };
    case "required":
      return { tools: xaiTools2, toolChoice: "required", toolWarnings };
    case "tool":
      return {
        tools: xaiTools2,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default:
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${type}`
      });
  }
}
var XaiChatLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    }, this.modelId = modelId, this.config = config2;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    seed,
    responseFormat,
    providerOptions,
    tools,
    toolChoice
  }) {
    var _a21, _b16, _c;
    let warnings = [], options = (_a21 = await parseProviderOptions({
      provider: "xai",
      providerOptions,
      schema: xaiProviderOptions
    })) != null ? _a21 : {};
    if (topK != null)
      warnings.push({ type: "unsupported", feature: "topK" });
    if (frequencyPenalty != null)
      warnings.push({ type: "unsupported", feature: "frequencyPenalty" });
    if (presencePenalty != null)
      warnings.push({ type: "unsupported", feature: "presencePenalty" });
    if (stopSequences != null)
      warnings.push({ type: "unsupported", feature: "stopSequences" });
    let { messages, warnings: messageWarnings } = convertToXaiChatMessages(prompt);
    warnings.push(...messageWarnings);
    let {
      tools: xaiTools2,
      toolChoice: xaiToolChoice,
      toolWarnings
    } = prepareTools5({
      tools,
      toolChoice
    });
    return warnings.push(...toolWarnings), {
      args: {
        model: this.modelId,
        max_completion_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        seed,
        reasoning_effort: options.reasoningEffort,
        parallel_function_calling: options.parallel_function_calling,
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
          type: "json_schema",
          json_schema: {
            name: (_b16 = responseFormat.name) != null ? _b16 : "response",
            schema: responseFormat.schema,
            strict: !0
          }
        } : { type: "json_object" } : void 0,
        search_parameters: options.searchParameters ? {
          mode: options.searchParameters.mode,
          return_citations: options.searchParameters.returnCitations,
          from_date: options.searchParameters.fromDate,
          to_date: options.searchParameters.toDate,
          max_search_results: options.searchParameters.maxSearchResults,
          sources: (_c = options.searchParameters.sources) == null ? void 0 : _c.map((source) => {
            var _a24;
            return {
              type: source.type,
              ...source.type === "web" && {
                country: source.country,
                excluded_websites: source.excludedWebsites,
                allowed_websites: source.allowedWebsites,
                safe_search: source.safeSearch
              },
              ...source.type === "x" && {
                excluded_x_handles: source.excludedXHandles,
                included_x_handles: (_a24 = source.includedXHandles) != null ? _a24 : source.xHandles,
                post_favorite_count: source.postFavoriteCount,
                post_view_count: source.postViewCount
              },
              ...source.type === "news" && {
                country: source.country,
                excluded_websites: source.excludedWebsites,
                safe_search: source.safeSearch
              },
              ...source.type === "rss" && {
                links: source.links
              }
            };
          })
        } : void 0,
        messages,
        tools: xaiTools2,
        tool_choice: xaiToolChoice
      },
      warnings
    };
  }
  async doGenerate(options) {
    var _a21, _b16;
    let { args: body, warnings } = await this.getArgs(options), url2 = `${(_a21 = this.config.baseURL) != null ? _a21 : "https://api.x.ai/v1"}/chat/completions`, {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: url2,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(xaiChatResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if (response.error != null)
      throw new APICallError({
        message: response.error,
        url: url2,
        requestBodyValues: body,
        statusCode: 200,
        responseHeaders,
        responseBody: JSON.stringify(rawResponse),
        isRetryable: response.code === "The service is currently unavailable"
      });
    let choice2 = response.choices[0], content = [];
    if (choice2.message.content != null && choice2.message.content.length > 0) {
      let text2 = choice2.message.content, lastMessage = body.messages[body.messages.length - 1];
      if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && text2 === lastMessage.content)
        text2 = "";
      if (text2.length > 0)
        content.push({ type: "text", text: text2 });
    }
    if (choice2.message.reasoning_content != null && choice2.message.reasoning_content.length > 0)
      content.push({
        type: "reasoning",
        text: choice2.message.reasoning_content
      });
    if (choice2.message.tool_calls != null)
      for (let toolCall of choice2.message.tool_calls)
        content.push({
          type: "tool-call",
          toolCallId: toolCall.id,
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
    if (response.citations != null)
      for (let url22 of response.citations)
        content.push({
          type: "source",
          sourceType: "url",
          id: this.config.generateId(),
          url: url22
        });
    return {
      content,
      finishReason: {
        unified: mapXaiFinishReason(choice2.finish_reason),
        raw: (_b16 = choice2.finish_reason) != null ? _b16 : void 0
      },
      usage: convertXaiChatUsage(response.usage),
      request: { body },
      response: {
        ...getResponseMetadata4(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    var _a21;
    let { args, warnings } = await this.getArgs(options), body = {
      ...args,
      stream: !0,
      stream_options: {
        include_usage: !0
      }
    }, url2 = `${(_a21 = this.config.baseURL) != null ? _a21 : "https://api.x.ai/v1"}/chat/completions`, { responseHeaders, value: response } = await postJsonToApi({
      url: url2,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: async ({ response: response2 }) => {
        let responseHeaders2 = extractResponseHeaders(response2), contentType = response2.headers.get("content-type");
        if (contentType == null ? void 0 : contentType.includes("application/json")) {
          let responseBody = await response2.text(), parsedError = await safeParseJSON({
            text: responseBody,
            schema: xaiStreamErrorSchema
          });
          if (parsedError.success)
            throw new APICallError({
              message: parsedError.value.error,
              url: url2,
              requestBodyValues: body,
              statusCode: 200,
              responseHeaders: responseHeaders2,
              responseBody,
              isRetryable: parsedError.value.code === "The service is currently unavailable"
            });
          throw new APICallError({
            message: "Invalid JSON response",
            url: url2,
            requestBodyValues: body,
            statusCode: 200,
            responseHeaders: responseHeaders2,
            responseBody
          });
        }
        return createEventSourceResponseHandler(xaiChatChunkSchema)({
          response: response2,
          url: url2,
          requestBodyValues: body
        });
      },
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), finishReason = {
      unified: "other",
      raw: void 0
    }, usage = void 0, isFirstChunk = !0, contentBlocks = {}, lastReasoningDeltas = {}, activeReasoningBlockId = void 0, self2 = this;
    return {
      stream: response.pipeThrough(new TransformStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings });
        },
        transform(chunk, controller) {
          if (options.includeRawChunks)
            controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
          if (!chunk.success) {
            controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          let value = chunk.value;
          if (isFirstChunk)
            controller.enqueue({
              type: "response-metadata",
              ...getResponseMetadata4(value)
            }), isFirstChunk = !1;
          if (value.citations != null)
            for (let url22 of value.citations)
              controller.enqueue({
                type: "source",
                sourceType: "url",
                id: self2.config.generateId(),
                url: url22
              });
          if (value.usage != null)
            usage = convertXaiChatUsage(value.usage);
          let choice2 = value.choices[0];
          if ((choice2 == null ? void 0 : choice2.finish_reason) != null)
            finishReason = {
              unified: mapXaiFinishReason(choice2.finish_reason),
              raw: choice2.finish_reason
            };
          if ((choice2 == null ? void 0 : choice2.delta) == null)
            return;
          let { delta, index: choiceIndex } = choice2;
          if (delta.content != null && delta.content.length > 0) {
            let textContent = delta.content;
            if (activeReasoningBlockId != null && !contentBlocks[activeReasoningBlockId].ended)
              controller.enqueue({
                type: "reasoning-end",
                id: activeReasoningBlockId
              }), contentBlocks[activeReasoningBlockId].ended = !0, activeReasoningBlockId = void 0;
            let lastMessage = body.messages[body.messages.length - 1];
            if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && textContent === lastMessage.content)
              return;
            let blockId = `text-${value.id || choiceIndex}`;
            if (contentBlocks[blockId] == null)
              contentBlocks[blockId] = { type: "text", ended: !1 }, controller.enqueue({
                type: "text-start",
                id: blockId
              });
            controller.enqueue({
              type: "text-delta",
              id: blockId,
              delta: textContent
            });
          }
          if (delta.reasoning_content != null && delta.reasoning_content.length > 0) {
            let blockId = `reasoning-${value.id || choiceIndex}`;
            if (lastReasoningDeltas[blockId] === delta.reasoning_content)
              return;
            if (lastReasoningDeltas[blockId] = delta.reasoning_content, contentBlocks[blockId] == null)
              contentBlocks[blockId] = { type: "reasoning", ended: !1 }, activeReasoningBlockId = blockId, controller.enqueue({
                type: "reasoning-start",
                id: blockId
              });
            controller.enqueue({
              type: "reasoning-delta",
              id: blockId,
              delta: delta.reasoning_content
            });
          }
          if (delta.tool_calls != null) {
            if (activeReasoningBlockId != null && !contentBlocks[activeReasoningBlockId].ended)
              controller.enqueue({
                type: "reasoning-end",
                id: activeReasoningBlockId
              }), contentBlocks[activeReasoningBlockId].ended = !0, activeReasoningBlockId = void 0;
            for (let toolCall of delta.tool_calls) {
              let toolCallId = toolCall.id;
              controller.enqueue({
                type: "tool-input-start",
                id: toolCallId,
                toolName: toolCall.function.name
              }), controller.enqueue({
                type: "tool-input-delta",
                id: toolCallId,
                delta: toolCall.function.arguments
              }), controller.enqueue({
                type: "tool-input-end",
                id: toolCallId
              }), controller.enqueue({
                type: "tool-call",
                toolCallId,
                toolName: toolCall.function.name,
                input: toolCall.function.arguments
              });
            }
          }
        },
        flush(controller) {
          for (let [blockId, block] of Object.entries(contentBlocks))
            if (!block.ended)
              controller.enqueue({
                type: block.type === "text" ? "text-end" : "reasoning-end",
                id: blockId
              });
          controller.enqueue({ type: "finish", finishReason, usage });
        }
      })),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
}, xaiUsageSchema = exports_external.object({
  prompt_tokens: exports_external.number(),
  completion_tokens: exports_external.number(),
  total_tokens: exports_external.number(),
  prompt_tokens_details: exports_external.object({
    text_tokens: exports_external.number().nullish(),
    audio_tokens: exports_external.number().nullish(),
    image_tokens: exports_external.number().nullish(),
    cached_tokens: exports_external.number().nullish()
  }).nullish(),
  completion_tokens_details: exports_external.object({
    reasoning_tokens: exports_external.number().nullish(),
    audio_tokens: exports_external.number().nullish(),
    accepted_prediction_tokens: exports_external.number().nullish(),
    rejected_prediction_tokens: exports_external.number().nullish()
  }).nullish()
}), xaiChatResponseSchema = exports_external.object({
  id: exports_external.string().nullish(),
  created: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  choices: exports_external.array(exports_external.object({
    message: exports_external.object({
      role: exports_external.literal("assistant"),
      content: exports_external.string().nullish(),
      reasoning_content: exports_external.string().nullish(),
      tool_calls: exports_external.array(exports_external.object({
        id: exports_external.string(),
        type: exports_external.literal("function"),
        function: exports_external.object({
          name: exports_external.string(),
          arguments: exports_external.string()
        })
      })).nullish()
    }),
    index: exports_external.number(),
    finish_reason: exports_external.string().nullish()
  })).nullish(),
  object: exports_external.literal("chat.completion").nullish(),
  usage: xaiUsageSchema.nullish(),
  citations: exports_external.array(exports_external.string().url()).nullish(),
  code: exports_external.string().nullish(),
  error: exports_external.string().nullish()
}), xaiChatChunkSchema = exports_external.object({
  id: exports_external.string().nullish(),
  created: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  choices: exports_external.array(exports_external.object({
    delta: exports_external.object({
      role: exports_external.enum(["assistant"]).optional(),
      content: exports_external.string().nullish(),
      reasoning_content: exports_external.string().nullish(),
      tool_calls: exports_external.array(exports_external.object({
        id: exports_external.string(),
        type: exports_external.literal("function"),
        function: exports_external.object({
          name: exports_external.string(),
          arguments: exports_external.string()
        })
      })).nullish()
    }),
    finish_reason: exports_external.string().nullish(),
    index: exports_external.number()
  })),
  usage: xaiUsageSchema.nullish(),
  citations: exports_external.array(exports_external.string().url()).nullish()
}), xaiStreamErrorSchema = exports_external.object({
  code: exports_external.string(),
  error: exports_external.string()
});
async function convertToXaiResponsesInput({
  prompt
}) {
  var _a21, _b16, _c, _d, _e;
  let input = [], inputWarnings = [];
  for (let message of prompt)
    switch (message.role) {
      case "system": {
        input.push({
          role: "system",
          content: message.content
        });
        break;
      }
      case "user": {
        let contentParts = [];
        for (let block of message.content)
          switch (block.type) {
            case "text": {
              contentParts.push({ type: "input_text", text: block.text });
              break;
            }
            case "file": {
              if (block.mediaType.startsWith("image/")) {
                let mediaType = block.mediaType === "image/*" ? "image/jpeg" : block.mediaType, imageUrl = block.data instanceof URL ? block.data.toString() : `data:${mediaType};base64,${convertToBase64(block.data)}`;
                contentParts.push({ type: "input_image", image_url: imageUrl });
              } else
                throw new UnsupportedFunctionalityError({
                  functionality: `file part media type ${block.mediaType}`
                });
              break;
            }
            default: {
              let _exhaustiveCheck = block;
              inputWarnings.push({
                type: "other",
                message: "xAI Responses API does not support this content type in user messages"
              });
            }
          }
        input.push({
          role: "user",
          content: contentParts
        });
        break;
      }
      case "assistant": {
        for (let part of message.content)
          switch (part.type) {
            case "text": {
              let id = typeof ((_b16 = (_a21 = part.providerOptions) == null ? void 0 : _a21.xai) == null ? void 0 : _b16.itemId) === "string" ? part.providerOptions.xai.itemId : void 0;
              input.push({
                role: "assistant",
                content: part.text,
                id
              });
              break;
            }
            case "tool-call": {
              if (part.providerExecuted)
                break;
              let id = typeof ((_d = (_c = part.providerOptions) == null ? void 0 : _c.xai) == null ? void 0 : _d.itemId) === "string" ? part.providerOptions.xai.itemId : void 0;
              input.push({
                type: "function_call",
                id: id != null ? id : part.toolCallId,
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.input),
                status: "completed"
              });
              break;
            }
            case "tool-result":
              break;
            case "reasoning":
            case "file": {
              inputWarnings.push({
                type: "other",
                message: `xAI Responses API does not support ${part.type} in assistant messages`
              });
              break;
            }
            default: {
              let _exhaustiveCheck = part;
              inputWarnings.push({
                type: "other",
                message: "xAI Responses API does not support this content type in assistant messages"
              });
            }
          }
        break;
      }
      case "tool": {
        for (let part of message.content) {
          if (part.type === "tool-approval-response")
            continue;
          let output = part.output, outputValue;
          switch (output.type) {
            case "text":
            case "error-text":
              outputValue = output.value;
              break;
            case "execution-denied":
              outputValue = (_e = output.reason) != null ? _e : "tool execution denied";
              break;
            case "json":
            case "error-json":
              outputValue = JSON.stringify(output.value);
              break;
            case "content":
              outputValue = output.value.map((item) => {
                if (item.type === "text")
                  return item.text;
                return "";
              }).join("");
              break;
            default: {
              let _exhaustiveCheck = output;
              outputValue = "";
            }
          }
          input.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: outputValue
          });
        }
        break;
      }
      default: {
        let _exhaustiveCheck = message;
        inputWarnings.push({
          type: "other",
          message: "unsupported message role"
        });
      }
    }
  return { input, inputWarnings };
}
function convertXaiResponsesUsage(usage) {
  var _a21, _b16, _c, _d;
  let cacheReadTokens = (_b16 = (_a21 = usage.input_tokens_details) == null ? void 0 : _a21.cached_tokens) != null ? _b16 : 0, reasoningTokens = (_d = (_c = usage.output_tokens_details) == null ? void 0 : _c.reasoning_tokens) != null ? _d : 0;
  return {
    inputTokens: {
      total: usage.input_tokens,
      noCache: usage.input_tokens - cacheReadTokens,
      cacheRead: cacheReadTokens,
      cacheWrite: void 0
    },
    outputTokens: {
      total: usage.output_tokens,
      text: usage.output_tokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function mapXaiResponsesFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
    case "completed":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "other";
  }
}
var annotationSchema = exports_external.union([
  exports_external.object({
    type: exports_external.literal("url_citation"),
    url: exports_external.string(),
    title: exports_external.string().optional()
  }),
  exports_external.object({
    type: exports_external.string()
  })
]), messageContentPartSchema = exports_external.object({
  type: exports_external.string(),
  text: exports_external.string().optional(),
  logprobs: exports_external.array(exports_external.any()).optional(),
  annotations: exports_external.array(annotationSchema).optional()
}), reasoningSummaryPartSchema = exports_external.object({
  type: exports_external.string(),
  text: exports_external.string()
}), toolCallSchema = exports_external.object({
  name: exports_external.string().optional(),
  arguments: exports_external.string().optional(),
  input: exports_external.string().optional(),
  call_id: exports_external.string().optional(),
  id: exports_external.string(),
  status: exports_external.string(),
  action: exports_external.any().optional()
}), mcpCallSchema = exports_external.object({
  name: exports_external.string().optional(),
  arguments: exports_external.string().optional(),
  output: exports_external.string().optional(),
  error: exports_external.string().optional(),
  id: exports_external.string(),
  status: exports_external.string(),
  server_label: exports_external.string().optional()
}), outputItemSchema = exports_external.discriminatedUnion("type", [
  exports_external.object({
    type: exports_external.literal("web_search_call"),
    ...toolCallSchema.shape
  }),
  exports_external.object({
    type: exports_external.literal("x_search_call"),
    ...toolCallSchema.shape
  }),
  exports_external.object({
    type: exports_external.literal("code_interpreter_call"),
    ...toolCallSchema.shape
  }),
  exports_external.object({
    type: exports_external.literal("code_execution_call"),
    ...toolCallSchema.shape
  }),
  exports_external.object({
    type: exports_external.literal("view_image_call"),
    ...toolCallSchema.shape
  }),
  exports_external.object({
    type: exports_external.literal("view_x_video_call"),
    ...toolCallSchema.shape
  }),
  exports_external.object({
    type: exports_external.literal("file_search_call"),
    id: exports_external.string(),
    status: exports_external.string(),
    queries: exports_external.array(exports_external.string()).optional(),
    results: exports_external.array(exports_external.object({
      file_id: exports_external.string(),
      filename: exports_external.string(),
      score: exports_external.number(),
      text: exports_external.string()
    })).nullish()
  }),
  exports_external.object({
    type: exports_external.literal("custom_tool_call"),
    ...toolCallSchema.shape
  }),
  exports_external.object({
    type: exports_external.literal("mcp_call"),
    ...mcpCallSchema.shape
  }),
  exports_external.object({
    type: exports_external.literal("message"),
    role: exports_external.string(),
    content: exports_external.array(messageContentPartSchema),
    id: exports_external.string(),
    status: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("function_call"),
    name: exports_external.string(),
    arguments: exports_external.string(),
    call_id: exports_external.string(),
    id: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("reasoning"),
    id: exports_external.string(),
    summary: exports_external.array(reasoningSummaryPartSchema),
    status: exports_external.string(),
    encrypted_content: exports_external.string().nullish()
  })
]), xaiResponsesUsageSchema = exports_external.object({
  input_tokens: exports_external.number(),
  output_tokens: exports_external.number(),
  total_tokens: exports_external.number().optional(),
  input_tokens_details: exports_external.object({
    cached_tokens: exports_external.number().optional()
  }).optional(),
  output_tokens_details: exports_external.object({
    reasoning_tokens: exports_external.number().optional()
  }).optional(),
  num_sources_used: exports_external.number().optional(),
  num_server_side_tools_used: exports_external.number().optional()
}), xaiResponsesResponseSchema = exports_external.object({
  id: exports_external.string().nullish(),
  created_at: exports_external.number().nullish(),
  model: exports_external.string().nullish(),
  object: exports_external.literal("response"),
  output: exports_external.array(outputItemSchema),
  usage: xaiResponsesUsageSchema.nullish(),
  status: exports_external.string()
}), xaiResponsesChunkSchema = exports_external.union([
  exports_external.object({
    type: exports_external.literal("response.created"),
    response: xaiResponsesResponseSchema.partial({ usage: !0, status: !0 })
  }),
  exports_external.object({
    type: exports_external.literal("response.in_progress"),
    response: xaiResponsesResponseSchema.partial({ usage: !0, status: !0 })
  }),
  exports_external.object({
    type: exports_external.literal("response.output_item.added"),
    item: outputItemSchema,
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.output_item.done"),
    item: outputItemSchema,
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.content_part.added"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    content_index: exports_external.number(),
    part: messageContentPartSchema
  }),
  exports_external.object({
    type: exports_external.literal("response.content_part.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    content_index: exports_external.number(),
    part: messageContentPartSchema
  }),
  exports_external.object({
    type: exports_external.literal("response.output_text.delta"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    content_index: exports_external.number(),
    delta: exports_external.string(),
    logprobs: exports_external.array(exports_external.any()).optional()
  }),
  exports_external.object({
    type: exports_external.literal("response.output_text.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    content_index: exports_external.number(),
    text: exports_external.string(),
    logprobs: exports_external.array(exports_external.any()).optional(),
    annotations: exports_external.array(annotationSchema).optional()
  }),
  exports_external.object({
    type: exports_external.literal("response.output_text.annotation.added"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    content_index: exports_external.number(),
    annotation_index: exports_external.number(),
    annotation: annotationSchema
  }),
  exports_external.object({
    type: exports_external.literal("response.reasoning_summary_part.added"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    summary_index: exports_external.number(),
    part: reasoningSummaryPartSchema
  }),
  exports_external.object({
    type: exports_external.literal("response.reasoning_summary_part.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    summary_index: exports_external.number(),
    part: reasoningSummaryPartSchema
  }),
  exports_external.object({
    type: exports_external.literal("response.reasoning_summary_text.delta"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    summary_index: exports_external.number(),
    delta: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.reasoning_summary_text.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    summary_index: exports_external.number(),
    text: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.web_search_call.in_progress"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.web_search_call.searching"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.web_search_call.completed"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.x_search_call.in_progress"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.x_search_call.searching"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.x_search_call.completed"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.file_search_call.in_progress"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.file_search_call.searching"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.file_search_call.completed"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_execution_call.in_progress"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_execution_call.executing"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_execution_call.completed"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_interpreter_call.in_progress"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_interpreter_call.executing"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_interpreter_call.interpreting"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_interpreter_call.completed"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_interpreter_call_code.delta"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    delta: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.code_interpreter_call_code.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    code: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.custom_tool_call_input.delta"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    delta: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.custom_tool_call_input.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    input: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.mcp_call.in_progress"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.mcp_call.executing"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.mcp_call.completed"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.mcp_call.failed"),
    item_id: exports_external.string(),
    output_index: exports_external.number()
  }),
  exports_external.object({
    type: exports_external.literal("response.mcp_call_arguments.delta"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    delta: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.mcp_call_arguments.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    arguments: exports_external.string().optional()
  }),
  exports_external.object({
    type: exports_external.literal("response.mcp_call_output.delta"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    delta: exports_external.string()
  }),
  exports_external.object({
    type: exports_external.literal("response.mcp_call_output.done"),
    item_id: exports_external.string(),
    output_index: exports_external.number(),
    output: exports_external.string().optional()
  }),
  exports_external.object({
    type: exports_external.literal("response.done"),
    response: xaiResponsesResponseSchema
  }),
  exports_external.object({
    type: exports_external.literal("response.completed"),
    response: xaiResponsesResponseSchema
  })
]), xaiResponsesProviderOptions = exports_external.object({
  reasoningEffort: exports_external.enum(["low", "medium", "high"]).optional(),
  store: exports_external.boolean().optional(),
  previousResponseId: exports_external.string().optional(),
  include: exports_external.array(exports_external.enum(["file_search_call.results"])).nullish()
}), fileSearchArgsSchema3 = lazySchema(() => zodSchema(exports_external.object({
  vectorStoreIds: exports_external.array(exports_external.string()),
  maxNumResults: exports_external.number().optional()
}))), fileSearchOutputSchema2 = lazySchema(() => zodSchema(exports_external.object({
  queries: exports_external.array(exports_external.string()),
  results: exports_external.array(exports_external.object({
    fileId: exports_external.string(),
    filename: exports_external.string(),
    score: exports_external.number().min(0).max(1),
    text: exports_external.string()
  })).nullable()
}))), fileSearchToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "xai.file_search",
  inputSchema: lazySchema(() => zodSchema(exports_external.object({}))),
  outputSchema: fileSearchOutputSchema2
}), fileSearch3 = (args) => fileSearchToolFactory(args), mcpServerArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  serverUrl: exports_external.string().describe("The URL of the MCP server"),
  serverLabel: exports_external.string().optional().describe("A label for the MCP server"),
  serverDescription: exports_external.string().optional().describe("Description of the MCP server"),
  allowedTools: exports_external.array(exports_external.string()).optional().describe("List of allowed tool names"),
  headers: exports_external.record(exports_external.string(), exports_external.string()).optional().describe("Custom headers to send"),
  authorization: exports_external.string().optional().describe("Authorization header value")
}))), mcpServerOutputSchema = lazySchema(() => zodSchema(exports_external.object({
  name: exports_external.string(),
  arguments: exports_external.string(),
  result: exports_external.unknown()
}))), mcpServerToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "xai.mcp",
  inputSchema: lazySchema(() => zodSchema(exports_external.object({}))),
  outputSchema: mcpServerOutputSchema
}), mcpServer = (args) => mcpServerToolFactory(args), webSearchArgsSchema2 = lazySchema(() => zodSchema(exports_external.object({
  allowedDomains: exports_external.array(exports_external.string()).max(5).optional(),
  excludedDomains: exports_external.array(exports_external.string()).max(5).optional(),
  enableImageUnderstanding: exports_external.boolean().optional()
}))), webSearchOutputSchema2 = lazySchema(() => zodSchema(exports_external.object({
  query: exports_external.string(),
  sources: exports_external.array(exports_external.object({
    title: exports_external.string(),
    url: exports_external.string(),
    snippet: exports_external.string()
  }))
}))), webSearchToolFactory2 = createProviderToolFactoryWithOutputSchema({
  id: "xai.web_search",
  inputSchema: lazySchema(() => zodSchema(exports_external.object({}))),
  outputSchema: webSearchOutputSchema2
}), webSearch2 = (args = {}) => webSearchToolFactory2(args), xSearchArgsSchema = lazySchema(() => zodSchema(exports_external.object({
  allowedXHandles: exports_external.array(exports_external.string()).max(10).optional(),
  excludedXHandles: exports_external.array(exports_external.string()).max(10).optional(),
  fromDate: exports_external.string().optional(),
  toDate: exports_external.string().optional(),
  enableImageUnderstanding: exports_external.boolean().optional(),
  enableVideoUnderstanding: exports_external.boolean().optional()
}))), xSearchOutputSchema = lazySchema(() => zodSchema(exports_external.object({
  query: exports_external.string(),
  posts: exports_external.array(exports_external.object({
    author: exports_external.string(),
    text: exports_external.string(),
    url: exports_external.string(),
    likes: exports_external.number()
  }))
}))), xSearchToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "xai.x_search",
  inputSchema: lazySchema(() => zodSchema(exports_external.object({}))),
  outputSchema: xSearchOutputSchema
}), xSearch = (args = {}) => xSearchToolFactory(args);
async function prepareResponsesTools2({
  tools,
  toolChoice
}) {
  let normalizedTools = (tools == null ? void 0 : tools.length) ? tools : void 0, toolWarnings = [];
  if (normalizedTools == null)
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  let xaiTools2 = [], toolByName = /* @__PURE__ */ new Map;
  for (let tool2 of normalizedTools)
    if (toolByName.set(tool2.name, tool2), tool2.type === "provider")
      switch (tool2.id) {
        case "xai.web_search": {
          let args = await validateTypes({
            value: tool2.args,
            schema: webSearchArgsSchema2
          });
          xaiTools2.push({
            type: "web_search",
            allowed_domains: args.allowedDomains,
            excluded_domains: args.excludedDomains,
            enable_image_understanding: args.enableImageUnderstanding
          });
          break;
        }
        case "xai.x_search": {
          let args = await validateTypes({
            value: tool2.args,
            schema: xSearchArgsSchema
          });
          xaiTools2.push({
            type: "x_search",
            allowed_x_handles: args.allowedXHandles,
            excluded_x_handles: args.excludedXHandles,
            from_date: args.fromDate,
            to_date: args.toDate,
            enable_image_understanding: args.enableImageUnderstanding,
            enable_video_understanding: args.enableVideoUnderstanding
          });
          break;
        }
        case "xai.code_execution": {
          xaiTools2.push({
            type: "code_interpreter"
          });
          break;
        }
        case "xai.view_image": {
          xaiTools2.push({
            type: "view_image"
          });
          break;
        }
        case "xai.view_x_video": {
          xaiTools2.push({
            type: "view_x_video"
          });
          break;
        }
        case "xai.file_search": {
          let args = await validateTypes({
            value: tool2.args,
            schema: fileSearchArgsSchema3
          });
          xaiTools2.push({
            type: "file_search",
            vector_store_ids: args.vectorStoreIds,
            max_num_results: args.maxNumResults
          });
          break;
        }
        case "xai.mcp": {
          let args = await validateTypes({
            value: tool2.args,
            schema: mcpServerArgsSchema
          });
          xaiTools2.push({
            type: "mcp",
            server_url: args.serverUrl,
            server_label: args.serverLabel,
            server_description: args.serverDescription,
            allowed_tools: args.allowedTools,
            headers: args.headers,
            authorization: args.authorization
          });
          break;
        }
        default: {
          toolWarnings.push({
            type: "unsupported",
            feature: `provider-defined tool ${tool2.name}`
          });
          break;
        }
      }
    else
      xaiTools2.push({
        type: "function",
        name: tool2.name,
        description: tool2.description,
        parameters: tool2.inputSchema
      });
  if (toolChoice == null)
    return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
  let type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: xaiTools2, toolChoice: type, toolWarnings };
    case "required":
      return { tools: xaiTools2, toolChoice: "required", toolWarnings };
    case "tool": {
      let selectedTool = toolByName.get(toolChoice.toolName);
      if (selectedTool == null)
        return {
          tools: xaiTools2,
          toolChoice: void 0,
          toolWarnings
        };
      if (selectedTool.type === "provider")
        return toolWarnings.push({
          type: "unsupported",
          feature: `toolChoice for server-side tool "${selectedTool.name}"`
        }), { tools: xaiTools2, toolChoice: void 0, toolWarnings };
      return {
        tools: xaiTools2,
        toolChoice: { type: "function", name: selectedTool.name },
        toolWarnings
      };
    }
    default:
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${type}`
      });
  }
}
var XaiResponsesLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    }, this.modelId = modelId, this.config = config2;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    stopSequences,
    seed,
    responseFormat,
    providerOptions,
    tools,
    toolChoice
  }) {
    var _a21, _b16, _c, _d, _e, _f, _g;
    let warnings = [], options = (_a21 = await parseProviderOptions({
      provider: "xai",
      providerOptions,
      schema: xaiResponsesProviderOptions
    })) != null ? _a21 : {};
    if (stopSequences != null)
      warnings.push({ type: "unsupported", feature: "stopSequences" });
    let webSearchToolName = (_b16 = tools == null ? void 0 : tools.find((tool2) => tool2.type === "provider" && tool2.id === "xai.web_search")) == null ? void 0 : _b16.name, xSearchToolName = (_c = tools == null ? void 0 : tools.find((tool2) => tool2.type === "provider" && tool2.id === "xai.x_search")) == null ? void 0 : _c.name, codeExecutionToolName = (_d = tools == null ? void 0 : tools.find((tool2) => tool2.type === "provider" && tool2.id === "xai.code_execution")) == null ? void 0 : _d.name, mcpToolName = (_e = tools == null ? void 0 : tools.find((tool2) => tool2.type === "provider" && tool2.id === "xai.mcp")) == null ? void 0 : _e.name, fileSearchToolName = (_f = tools == null ? void 0 : tools.find((tool2) => tool2.type === "provider" && tool2.id === "xai.file_search")) == null ? void 0 : _f.name, { input, inputWarnings } = await convertToXaiResponsesInput({
      prompt,
      store: !0
    });
    warnings.push(...inputWarnings);
    let {
      tools: xaiTools2,
      toolChoice: xaiToolChoice,
      toolWarnings
    } = await prepareResponsesTools2({
      tools,
      toolChoice
    });
    warnings.push(...toolWarnings);
    let include = options.include ? [...options.include] : void 0;
    if (options.store === !1)
      if (include == null)
        include = ["reasoning.encrypted_content"];
      else
        include = [...include, "reasoning.encrypted_content"];
    let baseArgs = {
      model: this.modelId,
      input,
      max_output_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      seed,
      ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
        text: {
          format: responseFormat.schema != null ? {
            type: "json_schema",
            strict: !0,
            name: (_g = responseFormat.name) != null ? _g : "response",
            description: responseFormat.description,
            schema: responseFormat.schema
          } : { type: "json_object" }
        }
      },
      ...options.reasoningEffort != null && {
        reasoning: { effort: options.reasoningEffort }
      },
      ...options.store === !1 && {
        store: options.store
      },
      ...include != null && {
        include
      },
      ...options.previousResponseId != null && {
        previous_response_id: options.previousResponseId
      }
    };
    if (xaiTools2 && xaiTools2.length > 0)
      baseArgs.tools = xaiTools2;
    if (xaiToolChoice != null)
      baseArgs.tool_choice = xaiToolChoice;
    return {
      args: baseArgs,
      warnings,
      webSearchToolName,
      xSearchToolName,
      codeExecutionToolName,
      mcpToolName,
      fileSearchToolName
    };
  }
  async doGenerate(options) {
    var _a21, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    let {
      args: body,
      warnings,
      webSearchToolName,
      xSearchToolName,
      codeExecutionToolName,
      mcpToolName,
      fileSearchToolName
    } = await this.getArgs(options), {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: `${(_a21 = this.config.baseURL) != null ? _a21 : "https://api.x.ai/v1"}/responses`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(xaiResponsesResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), content = [], webSearchSubTools = [
      "web_search",
      "web_search_with_snippets",
      "browse_page"
    ], xSearchSubTools = [
      "x_user_search",
      "x_keyword_search",
      "x_semantic_search",
      "x_thread_fetch"
    ];
    for (let part of response.output) {
      if (part.type === "file_search_call") {
        let toolName = fileSearchToolName != null ? fileSearchToolName : "file_search";
        content.push({
          type: "tool-call",
          toolCallId: part.id,
          toolName,
          input: "",
          providerExecuted: !0
        }), content.push({
          type: "tool-result",
          toolCallId: part.id,
          toolName,
          result: {
            queries: (_b16 = part.queries) != null ? _b16 : [],
            results: (_d = (_c = part.results) == null ? void 0 : _c.map((result) => ({
              fileId: result.file_id,
              filename: result.filename,
              score: result.score,
              text: result.text
            }))) != null ? _d : null
          }
        });
        continue;
      }
      if (part.type === "web_search_call" || part.type === "x_search_call" || part.type === "code_interpreter_call" || part.type === "code_execution_call" || part.type === "view_image_call" || part.type === "view_x_video_call" || part.type === "custom_tool_call" || part.type === "mcp_call") {
        let toolName = (_e = part.name) != null ? _e : "";
        if (webSearchSubTools.includes((_f = part.name) != null ? _f : "") || part.type === "web_search_call")
          toolName = webSearchToolName != null ? webSearchToolName : "web_search";
        else if (xSearchSubTools.includes((_g = part.name) != null ? _g : "") || part.type === "x_search_call")
          toolName = xSearchToolName != null ? xSearchToolName : "x_search";
        else if (part.name === "code_execution" || part.type === "code_interpreter_call" || part.type === "code_execution_call")
          toolName = codeExecutionToolName != null ? codeExecutionToolName : "code_execution";
        else if (part.type === "mcp_call")
          toolName = (_h = mcpToolName != null ? mcpToolName : part.name) != null ? _h : "mcp";
        let toolInput = part.type === "custom_tool_call" ? (_i = part.input) != null ? _i : "" : part.type === "mcp_call" ? (_j = part.arguments) != null ? _j : "" : (_k = part.arguments) != null ? _k : "";
        content.push({
          type: "tool-call",
          toolCallId: part.id,
          toolName,
          input: toolInput,
          providerExecuted: !0
        });
        continue;
      }
      switch (part.type) {
        case "message": {
          for (let contentPart of part.content) {
            if (contentPart.text)
              content.push({
                type: "text",
                text: contentPart.text
              });
            if (contentPart.annotations) {
              for (let annotation of contentPart.annotations)
                if (annotation.type === "url_citation" && "url" in annotation)
                  content.push({
                    type: "source",
                    sourceType: "url",
                    id: this.config.generateId(),
                    url: annotation.url,
                    title: (_l = annotation.title) != null ? _l : annotation.url
                  });
            }
          }
          break;
        }
        case "function_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.call_id,
            toolName: part.name,
            input: part.arguments
          });
          break;
        }
        case "reasoning": {
          let summaryTexts = part.summary.map((s) => s.text).filter((text2) => text2 && text2.length > 0);
          if (summaryTexts.length > 0) {
            let reasoningText = summaryTexts.join("");
            if (part.encrypted_content || part.id)
              content.push({
                type: "reasoning",
                text: reasoningText,
                providerMetadata: {
                  xai: {
                    ...part.encrypted_content && {
                      reasoningEncryptedContent: part.encrypted_content
                    },
                    ...part.id && { itemId: part.id }
                  }
                }
              });
            else
              content.push({
                type: "reasoning",
                text: reasoningText
              });
          }
          break;
        }
        default:
          break;
      }
    }
    return {
      content,
      finishReason: {
        unified: mapXaiResponsesFinishReason(response.status),
        raw: (_m = response.status) != null ? _m : void 0
      },
      usage: response.usage ? convertXaiResponsesUsage(response.usage) : {
        inputTokens: { total: 0, noCache: 0, cacheRead: 0, cacheWrite: 0 },
        outputTokens: { total: 0, text: 0, reasoning: 0 }
      },
      request: { body },
      response: {
        ...getResponseMetadata4(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    var _a21;
    let {
      args,
      warnings,
      webSearchToolName,
      xSearchToolName,
      codeExecutionToolName,
      mcpToolName,
      fileSearchToolName
    } = await this.getArgs(options), body = {
      ...args,
      stream: !0
    }, { responseHeaders, value: response } = await postJsonToApi({
      url: `${(_a21 = this.config.baseURL) != null ? _a21 : "https://api.x.ai/v1"}/responses`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(xaiResponsesChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), finishReason = {
      unified: "other",
      raw: void 0
    }, usage = void 0, isFirstChunk = !0, contentBlocks = {}, seenToolCalls = /* @__PURE__ */ new Set, activeReasoning = {}, self2 = this;
    return {
      stream: response.pipeThrough(new TransformStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings });
        },
        transform(chunk, controller) {
          var _a24, _b16, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
          if (options.includeRawChunks)
            controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
          if (!chunk.success) {
            controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          let event = chunk.value;
          if (event.type === "response.created" || event.type === "response.in_progress") {
            if (isFirstChunk)
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata4(event.response)
              }), isFirstChunk = !1;
            return;
          }
          if (event.type === "response.reasoning_summary_part.added") {
            let blockId = `reasoning-${event.item_id}`;
            activeReasoning[event.item_id] = {}, controller.enqueue({
              type: "reasoning-start",
              id: blockId,
              providerMetadata: {
                xai: {
                  itemId: event.item_id
                }
              }
            });
          }
          if (event.type === "response.reasoning_summary_text.delta") {
            let blockId = `reasoning-${event.item_id}`;
            controller.enqueue({
              type: "reasoning-delta",
              id: blockId,
              delta: event.delta,
              providerMetadata: {
                xai: {
                  itemId: event.item_id
                }
              }
            });
            return;
          }
          if (event.type === "response.reasoning_summary_text.done")
            return;
          if (event.type === "response.output_text.delta") {
            let blockId = `text-${event.item_id}`;
            if (contentBlocks[blockId] == null)
              contentBlocks[blockId] = { type: "text" }, controller.enqueue({
                type: "text-start",
                id: blockId
              });
            controller.enqueue({
              type: "text-delta",
              id: blockId,
              delta: event.delta
            });
            return;
          }
          if (event.type === "response.output_text.done") {
            if (event.annotations) {
              for (let annotation of event.annotations)
                if (annotation.type === "url_citation" && "url" in annotation)
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: self2.config.generateId(),
                    url: annotation.url,
                    title: (_a24 = annotation.title) != null ? _a24 : annotation.url
                  });
            }
            return;
          }
          if (event.type === "response.output_text.annotation.added") {
            let annotation = event.annotation;
            if (annotation.type === "url_citation" && "url" in annotation)
              controller.enqueue({
                type: "source",
                sourceType: "url",
                id: self2.config.generateId(),
                url: annotation.url,
                title: (_b16 = annotation.title) != null ? _b16 : annotation.url
              });
            return;
          }
          if (event.type === "response.done" || event.type === "response.completed") {
            let response2 = event.response;
            if (response2.usage)
              usage = convertXaiResponsesUsage(response2.usage);
            if (response2.status)
              finishReason = {
                unified: mapXaiResponsesFinishReason(response2.status),
                raw: response2.status
              };
            return;
          }
          if (event.type === "response.custom_tool_call_input.delta" || event.type === "response.custom_tool_call_input.done")
            return;
          if (event.type === "response.output_item.added" || event.type === "response.output_item.done") {
            let part = event.item;
            if (part.type === "reasoning") {
              if (event.type === "response.output_item.done") {
                let blockId = `reasoning-${part.id}`;
                if (!(part.id in activeReasoning))
                  activeReasoning[part.id] = {}, controller.enqueue({
                    type: "reasoning-start",
                    id: blockId,
                    providerMetadata: {
                      xai: {
                        ...part.id && { itemId: part.id }
                      }
                    }
                  });
                controller.enqueue({
                  type: "reasoning-end",
                  id: blockId,
                  providerMetadata: {
                    xai: {
                      ...part.encrypted_content && {
                        reasoningEncryptedContent: part.encrypted_content
                      },
                      ...part.id && { itemId: part.id }
                    }
                  }
                }), delete activeReasoning[part.id];
              }
              return;
            }
            if (part.type === "file_search_call") {
              let toolName = fileSearchToolName != null ? fileSearchToolName : "file_search";
              if (!seenToolCalls.has(part.id))
                seenToolCalls.add(part.id), controller.enqueue({
                  type: "tool-input-start",
                  id: part.id,
                  toolName
                }), controller.enqueue({
                  type: "tool-input-delta",
                  id: part.id,
                  delta: ""
                }), controller.enqueue({
                  type: "tool-input-end",
                  id: part.id
                }), controller.enqueue({
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName,
                  input: "",
                  providerExecuted: !0
                });
              if (event.type === "response.output_item.done")
                controller.enqueue({
                  type: "tool-result",
                  toolCallId: part.id,
                  toolName,
                  result: {
                    queries: (_c = part.queries) != null ? _c : [],
                    results: (_e = (_d = part.results) == null ? void 0 : _d.map((result) => ({
                      fileId: result.file_id,
                      filename: result.filename,
                      score: result.score,
                      text: result.text
                    }))) != null ? _e : null
                  }
                });
              return;
            }
            if (part.type === "web_search_call" || part.type === "x_search_call" || part.type === "code_interpreter_call" || part.type === "code_execution_call" || part.type === "view_image_call" || part.type === "view_x_video_call" || part.type === "custom_tool_call" || part.type === "mcp_call") {
              let webSearchSubTools = [
                "web_search",
                "web_search_with_snippets",
                "browse_page"
              ], xSearchSubTools = [
                "x_user_search",
                "x_keyword_search",
                "x_semantic_search",
                "x_thread_fetch"
              ], toolName = (_f = part.name) != null ? _f : "";
              if (webSearchSubTools.includes((_g = part.name) != null ? _g : "") || part.type === "web_search_call")
                toolName = webSearchToolName != null ? webSearchToolName : "web_search";
              else if (xSearchSubTools.includes((_h = part.name) != null ? _h : "") || part.type === "x_search_call")
                toolName = xSearchToolName != null ? xSearchToolName : "x_search";
              else if (part.name === "code_execution" || part.type === "code_interpreter_call" || part.type === "code_execution_call")
                toolName = codeExecutionToolName != null ? codeExecutionToolName : "code_execution";
              else if (part.type === "mcp_call")
                toolName = (_i = mcpToolName != null ? mcpToolName : part.name) != null ? _i : "mcp";
              let toolInput = part.type === "custom_tool_call" ? (_j = part.input) != null ? _j : "" : part.type === "mcp_call" ? (_k = part.arguments) != null ? _k : "" : (_l = part.arguments) != null ? _l : "";
              if ((part.type === "custom_tool_call" ? event.type === "response.output_item.done" : !seenToolCalls.has(part.id)) && !seenToolCalls.has(part.id))
                seenToolCalls.add(part.id), controller.enqueue({
                  type: "tool-input-start",
                  id: part.id,
                  toolName
                }), controller.enqueue({
                  type: "tool-input-delta",
                  id: part.id,
                  delta: toolInput
                }), controller.enqueue({
                  type: "tool-input-end",
                  id: part.id
                }), controller.enqueue({
                  type: "tool-call",
                  toolCallId: part.id,
                  toolName,
                  input: toolInput,
                  providerExecuted: !0
                });
              return;
            }
            if (part.type === "message")
              for (let contentPart of part.content) {
                if (contentPart.text && contentPart.text.length > 0) {
                  let blockId = `text-${part.id}`;
                  if (contentBlocks[blockId] == null)
                    contentBlocks[blockId] = { type: "text" }, controller.enqueue({
                      type: "text-start",
                      id: blockId
                    }), controller.enqueue({
                      type: "text-delta",
                      id: blockId,
                      delta: contentPart.text
                    });
                }
                if (contentPart.annotations) {
                  for (let annotation of contentPart.annotations)
                    if (annotation.type === "url_citation" && "url" in annotation)
                      controller.enqueue({
                        type: "source",
                        sourceType: "url",
                        id: self2.config.generateId(),
                        url: annotation.url,
                        title: (_m = annotation.title) != null ? _m : annotation.url
                      });
                }
              }
            else if (part.type === "function_call") {
              if (!seenToolCalls.has(part.call_id))
                seenToolCalls.add(part.call_id), controller.enqueue({
                  type: "tool-input-start",
                  id: part.call_id,
                  toolName: part.name
                }), controller.enqueue({
                  type: "tool-input-delta",
                  id: part.call_id,
                  delta: part.arguments
                }), controller.enqueue({
                  type: "tool-input-end",
                  id: part.call_id
                }), controller.enqueue({
                  type: "tool-call",
                  toolCallId: part.call_id,
                  toolName: part.name,
                  input: part.arguments
                });
            }
          }
        },
        flush(controller) {
          for (let [blockId, block] of Object.entries(contentBlocks))
            if (block.type === "text")
              controller.enqueue({
                type: "text-end",
                id: blockId
              });
          controller.enqueue({ type: "finish", finishReason, usage });
        }
      })),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
}, codeExecutionOutputSchema = exports_external.object({
  output: exports_external.string().describe("the output of the code execution"),
  error: exports_external.string().optional().describe("any error that occurred")
}), codeExecutionToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "xai.code_execution",
  inputSchema: exports_external.object({}).describe("no input parameters"),
  outputSchema: codeExecutionOutputSchema
}), codeExecution2 = (args = {}) => codeExecutionToolFactory(args), viewImageOutputSchema = exports_external.object({
  description: exports_external.string().describe("description of the image"),
  objects: exports_external.array(exports_external.string()).optional().describe("objects detected in the image")
}), viewImageToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "xai.view_image",
  inputSchema: exports_external.object({}).describe("no input parameters"),
  outputSchema: viewImageOutputSchema
}), viewImage = (args = {}) => viewImageToolFactory(args), viewXVideoOutputSchema = exports_external.object({
  transcript: exports_external.string().optional().describe("transcript of the video"),
  description: exports_external.string().describe("description of the video content"),
  duration: exports_external.number().optional().describe("duration in seconds")
}), viewXVideoToolFactory = createProviderToolFactoryWithOutputSchema({
  id: "xai.view_x_video",
  inputSchema: exports_external.object({}).describe("no input parameters"),
  outputSchema: viewXVideoOutputSchema
}), viewXVideo = (args = {}) => viewXVideoToolFactory(args), xaiTools = {
  codeExecution: codeExecution2,
  fileSearch: fileSearch3,
  mcpServer,
  viewImage,
  viewXVideo,
  webSearch: webSearch2,
  xSearch
}, VERSION9 = "3.0.46", xaiErrorStructure = {
  errorSchema: xaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
};
function createXai(options = {}) {
  var _a21;
  let baseURL = withoutTrailingSlash((_a21 = options.baseURL) != null ? _a21 : "https://api.x.ai/v1"), getHeaders = () => withUserAgentSuffix({
    Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "XAI_API_KEY",
      description: "xAI API key"
    })}`,
    ...options.headers
  }, `ai-sdk/xai/${VERSION9}`), createChatLanguageModel = (modelId) => {
    return new XaiChatLanguageModel(modelId, {
      provider: "xai.chat",
      baseURL,
      headers: getHeaders,
      generateId,
      fetch: options.fetch
    });
  }, createResponsesLanguageModel = (modelId) => {
    return new XaiResponsesLanguageModel(modelId, {
      provider: "xai.responses",
      baseURL,
      headers: getHeaders,
      generateId,
      fetch: options.fetch
    });
  }, createImageModel = (modelId) => {
    return new OpenAICompatibleImageModel(modelId, {
      provider: "xai.image",
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch,
      errorStructure: xaiErrorStructure
    });
  }, provider = (modelId) => createChatLanguageModel(modelId);
  return provider.specificationVersion = "v3", provider.languageModel = createChatLanguageModel, provider.chat = createChatLanguageModel, provider.responses = createResponsesLanguageModel, provider.embeddingModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "embeddingModel" });
  }, provider.textEmbeddingModel = provider.embeddingModel, provider.imageModel = createImageModel, provider.image = createImageModel, provider.tools = xaiTools, provider;
}
var xai = createXai();
// node_modules/@ai-sdk/perplexity/dist/index.mjs
function convertPerplexityUsage(usage) {
  var _a21, _b16, _c;
  if (usage == null)
    return {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      },
      raw: void 0
    };
  let promptTokens = (_a21 = usage.prompt_tokens) != null ? _a21 : 0, completionTokens = (_b16 = usage.completion_tokens) != null ? _b16 : 0, reasoningTokens = (_c = usage.reasoning_tokens) != null ? _c : 0;
  return {
    inputTokens: {
      total: promptTokens,
      noCache: promptTokens,
      cacheRead: void 0,
      cacheWrite: void 0
    },
    outputTokens: {
      total: completionTokens,
      text: completionTokens - reasoningTokens,
      reasoning: reasoningTokens
    },
    raw: usage
  };
}
function convertToPerplexityMessages(prompt) {
  let messages = [];
  for (let { role, content } of prompt)
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user":
      case "assistant": {
        let hasMultipartContent = content.some((part) => part.type === "file" && part.mediaType.startsWith("image/") || part.type === "file" && part.mediaType === "application/pdf"), messageContent = content.map((part, index) => {
          var _a21;
          switch (part.type) {
            case "text":
              return {
                type: "text",
                text: part.text
              };
            case "file":
              if (part.mediaType === "application/pdf")
                return part.data instanceof URL ? {
                  type: "file_url",
                  file_url: {
                    url: part.data.toString()
                  },
                  file_name: part.filename
                } : {
                  type: "file_url",
                  file_url: {
                    url: typeof part.data === "string" ? part.data : convertUint8ArrayToBase64(part.data)
                  },
                  file_name: part.filename || `document-${index}.pdf`
                };
              else if (part.mediaType.startsWith("image/"))
                return part.data instanceof URL ? {
                  type: "image_url",
                  image_url: {
                    url: part.data.toString()
                  }
                } : {
                  type: "image_url",
                  image_url: {
                    url: `data:${(_a21 = part.mediaType) != null ? _a21 : "image/jpeg"};base64,${typeof part.data === "string" ? part.data : convertUint8ArrayToBase64(part.data)}`
                  }
                };
          }
        }).filter(Boolean);
        messages.push({
          role,
          content: hasMultipartContent ? messageContent : messageContent.filter((part) => part.type === "text").map((part) => part.text).join("")
        });
        break;
      }
      case "tool":
        throw new UnsupportedFunctionalityError({
          functionality: "Tool messages"
        });
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  return messages;
}
function mapPerplexityFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
    case "length":
      return finishReason;
    default:
      return "other";
  }
}
var PerplexityLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.provider = "perplexity", this.supportedUrls = {}, this.modelId = modelId, this.config = config2;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    providerOptions
  }) {
    var _a21;
    let warnings = [];
    if (topK != null)
      warnings.push({ type: "unsupported", feature: "topK" });
    if (stopSequences != null)
      warnings.push({ type: "unsupported", feature: "stopSequences" });
    if (seed != null)
      warnings.push({ type: "unsupported", feature: "seed" });
    return {
      args: {
        model: this.modelId,
        frequency_penalty: frequencyPenalty,
        max_tokens: maxOutputTokens,
        presence_penalty: presencePenalty,
        temperature,
        top_k: topK,
        top_p: topP,
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? {
          type: "json_schema",
          json_schema: { schema: responseFormat.schema }
        } : void 0,
        ...(_a21 = providerOptions == null ? void 0 : providerOptions.perplexity) != null ? _a21 : {},
        messages: convertToPerplexityMessages(prompt)
      },
      warnings
    };
  }
  async doGenerate(options) {
    var _a21, _b16, _c, _d, _e, _f, _g;
    let { args: body, warnings } = this.getArgs(options), {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: `${this.config.baseURL}/chat/completions`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: createJsonErrorResponseHandler({
        errorSchema: perplexityErrorSchema,
        errorToMessage
      }),
      successfulResponseHandler: createJsonResponseHandler(perplexityResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), choice2 = response.choices[0], content = [], text2 = choice2.message.content;
    if (text2.length > 0)
      content.push({ type: "text", text: text2 });
    if (response.citations != null)
      for (let url2 of response.citations)
        content.push({
          type: "source",
          sourceType: "url",
          id: this.config.generateId(),
          url: url2
        });
    return {
      content,
      finishReason: {
        unified: mapPerplexityFinishReason(choice2.finish_reason),
        raw: (_a21 = choice2.finish_reason) != null ? _a21 : void 0
      },
      usage: convertPerplexityUsage(response.usage),
      request: { body },
      response: {
        ...getResponseMetadata5(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings,
      providerMetadata: {
        perplexity: {
          images: (_c = (_b16 = response.images) == null ? void 0 : _b16.map((image) => ({
            imageUrl: image.image_url,
            originUrl: image.origin_url,
            height: image.height,
            width: image.width
          }))) != null ? _c : null,
          usage: {
            citationTokens: (_e = (_d = response.usage) == null ? void 0 : _d.citation_tokens) != null ? _e : null,
            numSearchQueries: (_g = (_f = response.usage) == null ? void 0 : _f.num_search_queries) != null ? _g : null
          }
        }
      }
    };
  }
  async doStream(options) {
    let { args, warnings } = this.getArgs(options), body = { ...args, stream: !0 }, { responseHeaders, value: response } = await postJsonToApi({
      url: `${this.config.baseURL}/chat/completions`,
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: createJsonErrorResponseHandler({
        errorSchema: perplexityErrorSchema,
        errorToMessage
      }),
      successfulResponseHandler: createEventSourceResponseHandler(perplexityChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), finishReason = {
      unified: "other",
      raw: void 0
    }, usage = void 0, providerMetadata = {
      perplexity: {
        usage: {
          citationTokens: null,
          numSearchQueries: null
        },
        images: null
      }
    }, isFirstChunk = !0, isActive = !1, self2 = this;
    return {
      stream: response.pipeThrough(new TransformStream({
        start(controller) {
          controller.enqueue({ type: "stream-start", warnings });
        },
        transform(chunk, controller) {
          var _a21, _b16, _c;
          if (options.includeRawChunks)
            controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
          if (!chunk.success) {
            controller.enqueue({ type: "error", error: chunk.error });
            return;
          }
          let value = chunk.value;
          if (isFirstChunk)
            controller.enqueue({
              type: "response-metadata",
              ...getResponseMetadata5(value)
            }), (_a21 = value.citations) == null || _a21.forEach((url2) => {
              controller.enqueue({
                type: "source",
                sourceType: "url",
                id: self2.config.generateId(),
                url: url2
              });
            }), isFirstChunk = !1;
          if (value.usage != null)
            usage = value.usage, providerMetadata.perplexity.usage = {
              citationTokens: (_b16 = value.usage.citation_tokens) != null ? _b16 : null,
              numSearchQueries: (_c = value.usage.num_search_queries) != null ? _c : null
            };
          if (value.images != null)
            providerMetadata.perplexity.images = value.images.map((image) => ({
              imageUrl: image.image_url,
              originUrl: image.origin_url,
              height: image.height,
              width: image.width
            }));
          let choice2 = value.choices[0];
          if ((choice2 == null ? void 0 : choice2.finish_reason) != null)
            finishReason = {
              unified: mapPerplexityFinishReason(choice2.finish_reason),
              raw: choice2.finish_reason
            };
          if ((choice2 == null ? void 0 : choice2.delta) == null)
            return;
          let textContent = choice2.delta.content;
          if (textContent != null) {
            if (!isActive)
              controller.enqueue({ type: "text-start", id: "0" }), isActive = !0;
            controller.enqueue({
              type: "text-delta",
              id: "0",
              delta: textContent
            });
          }
        },
        flush(controller) {
          if (isActive)
            controller.enqueue({ type: "text-end", id: "0" });
          controller.enqueue({
            type: "finish",
            finishReason,
            usage: convertPerplexityUsage(usage),
            providerMetadata
          });
        }
      })),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function getResponseMetadata5({
  id,
  model,
  created
}) {
  return {
    id,
    modelId: model,
    timestamp: new Date(created * 1000)
  };
}
var perplexityUsageSchema = exports_external.object({
  prompt_tokens: exports_external.number(),
  completion_tokens: exports_external.number(),
  total_tokens: exports_external.number().nullish(),
  citation_tokens: exports_external.number().nullish(),
  num_search_queries: exports_external.number().nullish(),
  reasoning_tokens: exports_external.number().nullish()
}), perplexityImageSchema = exports_external.object({
  image_url: exports_external.string(),
  origin_url: exports_external.string(),
  height: exports_external.number(),
  width: exports_external.number()
}), perplexityResponseSchema = exports_external.object({
  id: exports_external.string(),
  created: exports_external.number(),
  model: exports_external.string(),
  choices: exports_external.array(exports_external.object({
    message: exports_external.object({
      role: exports_external.literal("assistant"),
      content: exports_external.string()
    }),
    finish_reason: exports_external.string().nullish()
  })),
  citations: exports_external.array(exports_external.string()).nullish(),
  images: exports_external.array(perplexityImageSchema).nullish(),
  usage: perplexityUsageSchema.nullish()
}), perplexityChunkSchema = exports_external.object({
  id: exports_external.string(),
  created: exports_external.number(),
  model: exports_external.string(),
  choices: exports_external.array(exports_external.object({
    delta: exports_external.object({
      role: exports_external.literal("assistant"),
      content: exports_external.string()
    }),
    finish_reason: exports_external.string().nullish()
  })),
  citations: exports_external.array(exports_external.string()).nullish(),
  images: exports_external.array(perplexityImageSchema).nullish(),
  usage: perplexityUsageSchema.nullish()
}), perplexityErrorSchema = exports_external.object({
  error: exports_external.object({
    code: exports_external.number(),
    message: exports_external.string().nullish(),
    type: exports_external.string().nullish()
  })
}), errorToMessage = (data) => {
  var _a21, _b16;
  return (_b16 = (_a21 = data.error.message) != null ? _a21 : data.error.type) != null ? _b16 : "unknown error";
}, VERSION10 = "3.0.17";
function createPerplexity(options = {}) {
  let getHeaders = () => withUserAgentSuffix({
    Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "PERPLEXITY_API_KEY",
      description: "Perplexity"
    })}`,
    ...options.headers
  }, `ai-sdk/perplexity/${VERSION10}`), createLanguageModel = (modelId) => {
    var _a21;
    return new PerplexityLanguageModel(modelId, {
      baseURL: withoutTrailingSlash((_a21 = options.baseURL) != null ? _a21 : "https://api.perplexity.ai"),
      headers: getHeaders,
      generateId,
      fetch: options.fetch
    });
  }, provider = (modelId) => createLanguageModel(modelId);
  return provider.specificationVersion = "v3", provider.languageModel = createLanguageModel, provider.embeddingModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "embeddingModel" });
  }, provider.textEmbeddingModel = provider.embeddingModel, provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  }, provider;
}
var perplexity = createPerplexity();
// node_modules/@ai-sdk/cerebras/dist/index.mjs
var VERSION11 = "2.0.29", cerebrasErrorSchema = exports_external.object({
  message: exports_external.string(),
  type: exports_external.string(),
  param: exports_external.string(),
  code: exports_external.string()
}), cerebrasErrorStructure = {
  errorSchema: cerebrasErrorSchema,
  errorToMessage: (data) => data.message
};
function createCerebras(options = {}) {
  var _a21;
  let baseURL = withoutTrailingSlash((_a21 = options.baseURL) != null ? _a21 : "https://api.cerebras.ai/v1"), getHeaders = () => withUserAgentSuffix({
    Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "CEREBRAS_API_KEY",
      description: "Cerebras API key"
    })}`,
    ...options.headers
  }, `ai-sdk/cerebras/${VERSION11}`), createLanguageModel = (modelId) => {
    return new OpenAICompatibleChatLanguageModel(modelId, {
      provider: "cerebras.chat",
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch,
      errorStructure: cerebrasErrorStructure,
      supportsStructuredOutputs: !0
    });
  }, provider = (modelId) => createLanguageModel(modelId);
  return provider.specificationVersion = "v3", provider.languageModel = createLanguageModel, provider.chat = createLanguageModel, provider.embeddingModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "embeddingModel" });
  }, provider.textEmbeddingModel = provider.embeddingModel, provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  }, provider;
}
var cerebras = createCerebras();
// node_modules/ollama-ai-provider-v2/dist/index.mjs
function convertToOllamaCompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text2 = "";
  if (prompt[0].role === "system")
    text2 += `${prompt[0].content}

`, prompt = prompt.slice(1);
  for (let { role, content } of prompt)
    switch (role) {
      case "system":
        throw new InvalidPromptError({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      case "user": {
        let userMessage = content.map((part) => {
          switch (part.type) {
            case "text":
              return part.text;
          }
        }).filter(Boolean).join("");
        text2 += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        let assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text":
              return part.text;
            case "tool-call":
              throw new UnsupportedFunctionalityError({
                functionality: "tool-call messages"
              });
          }
        }).join("");
        text2 += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool":
        throw new UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  return text2 += `${assistant}:
`, {
    prompt: text2,
    stopSequences: [`
${user}:`]
  };
}
function mapOllamaFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return {
        raw: finishReason,
        unified: "stop"
      };
    case "length":
      return {
        raw: finishReason,
        unified: "length"
      };
    case "content_filter":
      return {
        raw: finishReason,
        unified: "content-filter"
      };
    case "function_call":
    case "tool_calls":
      return {
        raw: finishReason,
        unified: "tool-calls"
      };
    default:
      return {
        raw: finishReason,
        unified: "other"
      };
  }
}
function getResponseMetadata6({
  model,
  created_at
}) {
  return {
    id: void 0,
    modelId: model != null ? model : void 0,
    timestamp: created_at != null ? new Date(created_at) : void 0
  };
}
function createNdjsonStreamResponseHandler(schema) {
  return async ({ response }) => {
    let responseHeaders = extractResponseHeaders(response);
    if (response.body == null)
      throw Error("Response body is null");
    let reader = response.body.getReader(), decoder = /* @__PURE__ */ new TextDecoder, buffer = "", stream = new ReadableStream({
      async pull(controller) {
        while (!0) {
          let { done, value } = await reader.read();
          if (done) {
            if (buffer.trim())
              try {
                let parsed = JSON.parse(buffer.trim()), validated = schema.parse(parsed);
                controller.enqueue({ success: !0, value: validated, rawValue: validated });
              } catch (e) {}
            controller.close();
            return;
          }
          buffer += decoder.decode(value, { stream: !0 });
          let lines = buffer.split(`
`);
          buffer = lines.pop() || "";
          for (let line of lines) {
            let trimmedLine = line.trim();
            if (trimmedLine)
              try {
                let parsed = JSON.parse(trimmedLine), validated = schema.parse(parsed);
                controller.enqueue({ success: !0, value: validated, rawValue: validated });
              } catch (error48) {
                console.warn("Failed to parse NDJSON line:", error48);
              }
          }
        }
      },
      cancel() {
        reader.cancel();
      }
    });
    return {
      responseHeaders,
      value: stream
    };
  };
}
var ollamaErrorDataSchema = exports_external.object({
  error: exports_external.object({
    message: exports_external.string(),
    type: exports_external.string().nullish(),
    param: exports_external.any().nullish(),
    code: exports_external.union([exports_external.string(), exports_external.number()]).nullish()
  })
}), ollamaFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: ollamaErrorDataSchema,
  errorToMessage: (data) => data.error.message
}), ollamaCompletionProviderOptions = exports_external.object({
  think: exports_external.boolean().optional(),
  user: exports_external.string().optional(),
  suffix: exports_external.string().optional(),
  echo: exports_external.boolean().optional()
}), OllamaCompletionLanguageModel = class {
  constructor(modelId, settings, config2) {
    this.specificationVersion = "v3", this.defaultObjectGenerationMode = void 0, this.supportsImageUrls = !1, this.supportedUrls = {}, this.modelId = modelId, this.settings = settings, this.config = config2, this.provider = config2.provider;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences: userStopSequences,
    responseFormat,
    tools,
    toolChoice,
    seed
  }) {
    let warnings = [];
    if (topK != null)
      warnings.push({
        type: "unsupported",
        feature: "topK"
      });
    if (tools == null ? void 0 : tools.length)
      warnings.push({ type: "unsupported", feature: "tools" });
    if (toolChoice != null)
      warnings.push({ type: "unsupported", feature: "toolChoice" });
    if (responseFormat != null && responseFormat.type !== "text")
      warnings.push({
        type: "unsupported",
        feature: "responseFormat (JSON)"
      });
    let { prompt: completionPrompt, stopSequences } = convertToOllamaCompletionPrompt({ prompt }), stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
    return {
      args: {
        model: this.modelId,
        user: this.settings.user,
        think: this.settings.think,
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        stop,
        prompt: completionPrompt,
        suffix: this.settings.suffix,
        echo: this.settings.echo,
        stream: !1
      },
      warnings
    };
  }
  async doGenerate(options) {
    var _a21, _b16;
    let { args: body, warnings } = this.getArgs(options), {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: this.config.url({
        path: "/generate",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: { ...body, stream: !1 },
      failedResponseHandler: ollamaFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(baseOllamaResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), { prompt: rawPrompt, ...rawSettings } = body, typedResponse = response;
    return {
      content: [
        {
          type: "text",
          text: typedResponse.response
        }
      ],
      usage: {
        inputTokens: {
          total: (_a21 = typedResponse.prompt_eval_count) != null ? _a21 : 0,
          noCache: void 0,
          cacheRead: void 0,
          cacheWrite: void 0
        },
        outputTokens: {
          total: (_b16 = typedResponse.eval_count) != null ? _b16 : 0,
          text: void 0,
          reasoning: void 0
        }
      },
      finishReason: mapOllamaFinishReason("stop"),
      request: { body: JSON.stringify(body) },
      response: {
        ...getResponseMetadata6(typedResponse),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    let { args, warnings } = this.getArgs(options), body = {
      ...args,
      stream: !0
    }, { responseHeaders, value: response } = await postJsonToApi({
      url: this.config.url({
        path: "/generate",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: ollamaFailedResponseHandler,
      successfulResponseHandler: createNdjsonStreamResponseHandler(baseOllamaResponseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), { prompt: rawPrompt, ...rawSettings } = args, finishReason = "other", usage = {
      inputTokens: {
        total: void 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: void 0,
        text: void 0,
        reasoning: void 0
      }
    }, isFirstChunk = !0, textStarted = !1, textId = generateId();
    return {
      stream: response.pipeThrough(new TransformStream({
        transform(chunk, controller) {
          if (!chunk.success) {
            controller.enqueue({ type: "error", error: chunk.rawValue });
            return;
          }
          let value = chunk.value;
          if ("error" in value) {
            finishReason = "error", controller.enqueue({ type: "error", error: value.error });
            return;
          }
          if (isFirstChunk)
            isFirstChunk = !1, controller.enqueue({
              type: "response-metadata",
              ...getResponseMetadata6(value)
            });
          if (value.done)
            finishReason = "stop";
          if (value.response != null) {
            if (!textStarted)
              controller.enqueue({
                type: "text-start",
                id: textId
              }), textStarted = !0;
            controller.enqueue({
              type: "text-delta",
              id: textId,
              delta: value.response
            });
          }
        },
        flush(controller) {
          if (textStarted)
            controller.enqueue({
              type: "text-end",
              id: textId
            });
          controller.enqueue({
            type: "finish",
            finishReason: mapOllamaFinishReason(finishReason),
            usage
          });
        }
      })),
      request: { body: JSON.stringify(body) },
      response: { headers: responseHeaders },
      warnings
    };
  }
}, baseOllamaResponseSchema = exports_external.object({
  model: exports_external.string(),
  created_at: exports_external.string(),
  response: exports_external.string(),
  done: exports_external.boolean(),
  context: exports_external.array(exports_external.number()),
  eval_count: exports_external.number().optional(),
  eval_duration: exports_external.number().optional(),
  load_duration: exports_external.number().optional(),
  total_duration: exports_external.number().optional(),
  prompt_eval_count: exports_external.number().optional(),
  prompt_eval_duration: exports_external.number().optional()
}), ollamaEmbeddingProviderOptions = exports_external.object({
  dimensions: exports_external.number().optional(),
  truncate: exports_external.boolean().optional(),
  keepAlive: exports_external.string().optional()
}), OllamaEmbeddingModel = class {
  constructor(modelId, settings, config2) {
    this.specificationVersion = "v3";
    var _a21, _b16;
    this.modelId = modelId, this.settings = settings, this.config = config2, this.provider = config2.provider, this.maxEmbeddingsPerCall = (_a21 = settings.maxEmbeddingsPerCall) != null ? _a21 : 2048, this.supportsParallelCalls = (_b16 = settings.supportsParallelCalls) != null ? _b16 : !0;
  }
  getArgs({
    values
  }) {
    return {
      model: this.modelId,
      input: values,
      dimensions: this.settings.dimensions,
      truncate: this.settings.truncate,
      keep_alive: this.settings.keepAlive
    };
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a21, _b16, _c;
    if (this.maxEmbeddingsPerCall && values.length > this.maxEmbeddingsPerCall)
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    let ollamaOptions = await parseProviderOptions({
      provider: "ollama",
      providerOptions,
      schema: ollamaEmbeddingProviderOptions
    }), dimensions = (_a21 = ollamaOptions == null ? void 0 : ollamaOptions.dimensions) != null ? _a21 : this.settings.dimensions, truncate = (_b16 = ollamaOptions == null ? void 0 : ollamaOptions.truncate) != null ? _b16 : this.settings.truncate, keepAlive = (_c = ollamaOptions == null ? void 0 : ollamaOptions.keepAlive) != null ? _c : this.settings.keepAlive, body = {
      model: this.modelId,
      input: values
    };
    if (dimensions !== void 0)
      body.dimensions = dimensions;
    if (truncate !== void 0)
      body.truncate = truncate;
    if (keepAlive !== void 0)
      body.keep_alive = keepAlive;
    let {
      responseHeaders,
      value: response,
      rawValue
    } = await postJsonToApi({
      url: this.config.url({
        path: "/embed",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), headers),
      body: { ...body },
      failedResponseHandler: ollamaFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(ollamaTextEmbeddingResponseSchema),
      abortSignal,
      fetch: this.config.fetch
    }), typedResponse = response;
    return {
      embeddings: typedResponse.embeddings.map((item) => item),
      usage: { tokens: typedResponse.prompt_eval_count },
      response: { headers: responseHeaders, body: rawValue },
      warnings: []
    };
  }
}, ollamaTextEmbeddingResponseSchema = exports_external.object({
  model: exports_external.string(),
  embeddings: exports_external.array(exports_external.array(exports_external.number())),
  total_duration: exports_external.number(),
  load_duration: exports_external.number(),
  prompt_eval_count: exports_external.number()
}), baseOllamaResponseSchema2 = exports_external.object({
  model: exports_external.string(),
  created_at: exports_external.string(),
  done: exports_external.boolean(),
  message: exports_external.object({
    content: exports_external.string(),
    role: exports_external.string(),
    thinking: exports_external.string().optional(),
    tool_calls: exports_external.array(exports_external.object({
      function: exports_external.object({
        name: exports_external.string(),
        arguments: exports_external.record(exports_external.string(), exports_external.any())
      }),
      id: exports_external.string().optional()
    })).optional().nullable()
  }),
  done_reason: exports_external.string().optional(),
  eval_count: exports_external.number().optional(),
  eval_duration: exports_external.number().optional(),
  load_duration: exports_external.number().optional(),
  prompt_eval_count: exports_external.number().optional(),
  prompt_eval_duration: exports_external.number().optional(),
  total_duration: exports_external.number().optional()
}), OllamaResponseProcessor = class {
  constructor(config2) {
    this.config = config2;
  }
  processGenerateResponse(response) {
    let content = this.extractContent(response), finishReason = mapOllamaFinishReason(response.done_reason), usage = this.extractUsage(response);
    return {
      content,
      finishReason,
      usage,
      providerMetadata: { ollama: {} }
    };
  }
  extractContent(response) {
    var _a21, _b16, _c, _d, _e;
    let content = [], text2 = response.message.content;
    if (text2 != null && text2.length > 0)
      content.push({
        type: "text",
        text: text2
      });
    let thinking = response.message.thinking;
    if (thinking != null && thinking.length > 0)
      content.push({
        type: "reasoning",
        text: thinking
      });
    for (let toolCall of (_a21 = response.message.tool_calls) != null ? _a21 : [])
      content.push({
        type: "tool-call",
        toolCallId: (_e = toolCall.id) != null ? _e : (_d = (_c = (_b16 = this.config).generateId) == null ? void 0 : _c.call(_b16)) != null ? _d : generateId(),
        toolName: toolCall.function.name,
        input: JSON.stringify(toolCall.function.arguments)
      });
    return content;
  }
  extractUsage(response) {
    var _a21, _b16;
    return {
      inputTokens: {
        total: (_a21 = response.prompt_eval_count) != null ? _a21 : 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: (_b16 = response.eval_count) != null ? _b16 : 0,
        text: void 0,
        reasoning: void 0
      }
    };
  }
};
function extractOllamaResponseObjectsFromChunk(chunk) {
  var _a21;
  if (chunk.success)
    return [chunk.value];
  let results = [], raw = (_a21 = chunk.error) == null ? void 0 : _a21.text;
  if (typeof raw !== "string" || raw.length === 0)
    return results;
  let lines = raw.split(/\r?\n/);
  for (let line of lines) {
    let trimmed = line.trim();
    if (trimmed === "")
      continue;
    try {
      let parsed = JSON.parse(trimmed), validated = baseOllamaResponseSchema2.safeParse(parsed);
      if (validated.success)
        results.push(validated.data);
    } catch (e) {}
  }
  return results;
}
function convertToOllamaChatMessages({
  prompt,
  systemMessageMode = "system"
}) {
  let messages = [];
  for (let { role, content } of prompt)
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove":
            break;
          default:
            throw Error(`Unsupported system message mode: ${systemMessageMode}`);
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        let userText = content.filter((part) => part.type === "text").map((part) => part.text).join(""), images = content.filter((part) => part.type === "file" && part.mediaType.startsWith("image/")).map((part) => part.data);
        messages.push({
          role: "user",
          content: userText.length > 0 ? userText : [],
          images: images.length > 0 ? images : void 0
        });
        break;
      }
      case "assistant": {
        let text2 = "", thinking = "", toolCalls = [];
        for (let part of content)
          switch (part.type) {
            case "text": {
              text2 += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: part.input
                }
              });
              break;
            }
            case "reasoning": {
              thinking += part.text;
              break;
            }
            default:
              throw Error(`Unsupported part: ${part}`);
          }
        messages.push({
          role: "assistant",
          content: text2,
          ...thinking && { thinking },
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (let toolResponse of content) {
          let output = toolResponse.output, contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  return messages;
}
var ollamaProviderOptions = exports_external.object({
  think: exports_external.boolean().optional(),
  options: exports_external.object({
    num_ctx: exports_external.number().optional(),
    repeat_last_n: exports_external.number().optional(),
    repeat_penalty: exports_external.number().optional(),
    temperature: exports_external.number().optional(),
    seed: exports_external.number().optional(),
    stop: exports_external.array(exports_external.string()).optional(),
    num_predict: exports_external.number().optional(),
    top_k: exports_external.number().optional(),
    top_p: exports_external.number().optional(),
    min_p: exports_external.number().optional()
  }).optional()
});
function convertToOllamaResponsesMessages({
  prompt,
  systemMessageMode
}) {
  let messages = [], warnings = [];
  for (let { role, content } of prompt)
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default:
            throw Error(`Unsupported system message mode: ${systemMessageMode}`);
        }
        break;
      }
      case "user": {
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a21, _b16, _c;
            switch (part.type) {
              case "text":
                return { type: "input_text", text: part.text };
              case "file":
                if (part.mediaType.startsWith("image/")) {
                  let mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "input_image",
                    image_url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${part.data}`,
                    detail: (_b16 = (_a21 = part.providerOptions) == null ? void 0 : _a21.ollama) == null ? void 0 : _b16.imageDetail
                  };
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL)
                    throw new UnsupportedFunctionalityError({
                      functionality: "PDF file parts with URLs"
                    });
                  return {
                    type: "input_file",
                    filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                    file_data: `data:application/pdf;base64,${part.data}`
                  };
                } else
                  throw new UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
            }
          })
        });
        break;
      }
      case "assistant": {
        for (let part of content)
          switch (part.type) {
            case "text": {
              messages.push({
                role: "assistant",
                content: [{ type: "output_text", text: part.text }]
              });
              break;
            }
            case "tool-call": {
              if (part.providerExecuted)
                break;
              messages.push({
                type: "function_call",
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.input)
              });
              break;
            }
            case "tool-result": {
              warnings.push({
                type: "other",
                message: "tool result parts in assistant messages are not supported for Ollama responses"
              });
              break;
            }
          }
        break;
      }
      case "tool": {
        for (let part of content) {
          let output = part.output, contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: contentValue
          });
        }
        break;
      }
      default:
        throw Error(`Unsupported role: ${role}`);
    }
  return { messages, warnings };
}
function prepareResponsesTools3({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  let toolWarnings = [];
  if (tools == null)
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  let ollamaTools = [];
  for (let tool2 of tools)
    switch (tool2.type) {
      case "function": {
        let parameters = tool2.inputSchema;
        if (!parameters)
          parameters = {
            type: "object",
            properties: {},
            required: []
          };
        else if (parameters && typeof parameters === "object" && parameters.type === "object" && parameters.properties && Object.keys(parameters.properties).length === 0)
          parameters = {
            ...parameters,
            properties: {},
            required: []
          };
        ollamaTools.push({
          type: "function",
          function: {
            name: tool2.name,
            description: tool2.description,
            parameters
          }
        });
        break;
      }
      default:
        toolWarnings.push({ type: "unsupported", feature: "tool", details: tool2.name });
        break;
    }
  if (toolChoice == null)
    return { tools: ollamaTools, toolChoice: void 0, toolWarnings };
  let type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: ollamaTools, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: ollamaTools,
        toolChoice: toolChoice.toolName == "web_search_preview" ? { type: "web_search_preview" } : { type: "function", name: toolChoice.toolName },
        toolWarnings
      };
    default:
      throw new UnsupportedFunctionalityError({
        functionality: `tool choice type: ${type}`
      });
  }
}
var OllamaRequestBuilder = class {
  async buildRequest({
    modelId,
    maxOutputTokens,
    temperature,
    stopSequences,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    seed,
    prompt,
    providerOptions,
    tools,
    toolChoice,
    responseFormat
  }) {
    let warnings = this.collectUnsupportedSettingsWarnings({
      topK,
      seed,
      presencePenalty,
      frequencyPenalty,
      stopSequences
    }), { messages, warnings: messageWarnings } = convertToOllamaResponsesMessages({
      prompt,
      systemMessageMode: "system"
    });
    warnings.push(...messageWarnings);
    let ollamaOptions = await this.parseProviderOptions(providerOptions), baseArgs = this.buildBaseArgs({
      modelId,
      prompt,
      temperature,
      topP,
      maxOutputTokens,
      responseFormat,
      ollamaOptions
    }), { tools: ollamaTools, toolChoice: ollamaToolChoice, toolWarnings } = prepareResponsesTools3({
      tools,
      toolChoice
    });
    return {
      args: {
        ...baseArgs,
        tools: ollamaTools,
        tool_choice: ollamaToolChoice
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  collectUnsupportedSettingsWarnings({
    topK,
    seed,
    presencePenalty,
    frequencyPenalty,
    stopSequences
  }) {
    let warnings = [], unsupportedSettings = [
      { value: topK, name: "topK" },
      { value: seed, name: "seed" },
      { value: presencePenalty, name: "presencePenalty" },
      { value: frequencyPenalty, name: "frequencyPenalty" },
      { value: stopSequences, name: "stopSequences" }
    ];
    for (let { value, name: name21 } of unsupportedSettings)
      if (value != null)
        warnings.push({ type: "unsupported", feature: "setting", details: name21 });
    return warnings;
  }
  async parseProviderOptions(providerOptions) {
    let result = await parseProviderOptions({
      provider: "ollama",
      providerOptions,
      schema: ollamaProviderOptions
    });
    return result != null ? result : null;
  }
  buildBaseArgs({
    modelId,
    prompt,
    temperature,
    topP,
    maxOutputTokens,
    responseFormat,
    ollamaOptions
  }) {
    var _a21, _b16;
    return {
      model: modelId,
      messages: convertToOllamaChatMessages({
        prompt,
        systemMessageMode: "system"
      }),
      temperature,
      top_p: topP,
      max_output_tokens: maxOutputTokens,
      ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
        format: responseFormat.schema != null ? responseFormat.schema : "json"
      },
      think: (_a21 = ollamaOptions == null ? void 0 : ollamaOptions.think) != null ? _a21 : !1,
      options: (_b16 = ollamaOptions == null ? void 0 : ollamaOptions.options) != null ? _b16 : void 0
    };
  }
}, OllamaStreamProcessor = class {
  constructor(config2) {
    this.config = config2, this.state = this.initializeState();
  }
  createTransformStream(warnings, options) {
    return new TransformStream({
      transform: (chunk, controller) => {
        this.processChunk(chunk, controller, options);
      },
      flush: (controller) => {
        this.finalizeStream(controller);
      }
    });
  }
  initializeState() {
    return {
      finishReason: {
        unified: "other",
        raw: void 0
      },
      usage: {
        inputTokens: {
          total: void 0,
          noCache: void 0,
          cacheRead: void 0,
          cacheWrite: void 0
        },
        outputTokens: {
          total: void 0,
          text: void 0,
          reasoning: void 0
        }
      },
      responseId: null,
      ongoingToolCalls: {},
      hasToolCalls: !1,
      isFirstChunk: !0,
      hasTextStarted: !1,
      hasReasoningStarted: !1,
      textEnded: !1,
      reasoningEnded: !1,
      textId: generateId(),
      reasoningId: generateId()
    };
  }
  processChunk(chunk, controller, options) {
    if (options == null ? void 0 : options.includeRawChunks)
      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
    let values = extractOllamaResponseObjectsFromChunk(chunk);
    if (values.length === 0) {
      if (!chunk.success)
        this.state.finishReason = { unified: "error", raw: void 0 }, controller.enqueue({ type: "error", error: chunk.error });
      return;
    }
    for (let value of values)
      this.processResponseValue(value, controller);
  }
  processResponseValue(value, controller) {
    if (value && typeof value === "object" && "error" in value) {
      this.state.finishReason = { unified: "error", raw: void 0 }, controller.enqueue({ type: "error", error: value.error });
      return;
    }
    if (this.state.isFirstChunk)
      this.state.isFirstChunk = !1, controller.enqueue({
        type: "response-metadata",
        ...getResponseMetadata6(value)
      });
    if (value.done)
      this.handleDoneChunk(value, controller);
    let delta = value == null ? void 0 : value.message;
    if (delta)
      this.processDelta(delta, controller);
  }
  handleDoneChunk(value, controller) {
    if (this.state.finishReason = mapOllamaFinishReason(value.done_reason), this.state.usage = {
      inputTokens: {
        total: value.prompt_eval_count || 0,
        noCache: void 0,
        cacheRead: void 0,
        cacheWrite: void 0
      },
      outputTokens: {
        total: value.eval_count || 0,
        text: void 0,
        reasoning: void 0
      }
    }, this.state.hasTextStarted && !this.state.textEnded)
      controller.enqueue({ type: "text-end", id: this.state.textId }), this.state.textEnded = !0;
    if (this.state.hasReasoningStarted && !this.state.reasoningEnded)
      controller.enqueue({ type: "reasoning-end", id: this.state.reasoningId }), this.state.reasoningEnded = !0;
  }
  processDelta(delta, controller) {
    this.processTextContent(delta, controller), this.processThinking(delta, controller), this.processToolCalls(delta, controller);
  }
  processTextContent(delta, controller) {
    if ((delta == null ? void 0 : delta.content) != null) {
      if (!this.state.hasTextStarted)
        controller.enqueue({ type: "text-start", id: this.state.textId }), this.state.hasTextStarted = !0;
      controller.enqueue({
        type: "text-delta",
        id: this.state.textId,
        delta: delta.content
      });
    }
  }
  processThinking(delta, controller) {
    if (delta == null ? void 0 : delta.thinking) {
      if (!this.state.hasReasoningStarted)
        controller.enqueue({ type: "reasoning-start", id: this.state.reasoningId }), this.state.hasReasoningStarted = !0;
      controller.enqueue({
        type: "reasoning-delta",
        id: this.state.reasoningId,
        delta: delta.thinking
      });
    }
  }
  processToolCalls(delta, controller) {
    var _a21, _b16, _c, _d;
    for (let toolCall of (_a21 = delta.tool_calls) != null ? _a21 : []) {
      if (((_b16 = toolCall.function) == null ? void 0 : _b16.name) == null)
        throw new InvalidResponseDataError({
          data: toolCall,
          message: "Expected 'function.name' to be a string."
        });
      if (((_c = toolCall.function) == null ? void 0 : _c.name) != null && ((_d = toolCall.function) == null ? void 0 : _d.arguments) != null)
        this.emitToolCall(toolCall, controller);
    }
  }
  emitToolCall(toolCall, controller) {
    var _a21, _b16, _c, _d;
    let id = (_d = toolCall.id) != null ? _d : (_c = (_b16 = (_a21 = this.config).generateId) == null ? void 0 : _b16.call(_a21)) != null ? _c : generateId();
    controller.enqueue({
      type: "tool-input-start",
      id,
      toolName: toolCall.function.name
    }), controller.enqueue({
      type: "tool-input-delta",
      id,
      delta: JSON.stringify(toolCall.function.arguments)
    }), controller.enqueue({
      type: "tool-input-end",
      id
    }), controller.enqueue({
      type: "tool-call",
      toolCallId: id,
      toolName: toolCall.function.name,
      input: JSON.stringify(toolCall.function.arguments)
    }), this.state.hasToolCalls = !0;
  }
  finalizeStream(controller) {
    if (this.state.hasTextStarted && !this.state.textEnded)
      controller.enqueue({ type: "text-end", id: this.state.textId });
    if (this.state.hasReasoningStarted && !this.state.reasoningEnded)
      controller.enqueue({ type: "reasoning-end", id: this.state.reasoningId });
    controller.enqueue({
      type: "finish",
      finishReason: this.state.finishReason,
      usage: this.state.usage,
      providerMetadata: {
        ollama: {
          responseId: this.state.responseId
        }
      }
    });
  }
}, OllamaResponsesLanguageModel = class {
  constructor(modelId, config2) {
    this.specificationVersion = "v3", this.defaultObjectGenerationMode = void 0, this.supportsImageUrls = !0, this.supportedUrls = {
      "image/*": [
        /^https?:\/\/.*$/
      ]
    }, this.modelId = modelId, this.config = config2, this.provider = config2.provider, this.requestBuilder = new OllamaRequestBuilder, this.responseProcessor = new OllamaResponseProcessor(config2);
  }
  async doGenerate(options) {
    let { args: body, warnings } = await this.prepareRequest(options), {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi({
      url: this.config.url({
        path: "/chat",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: { ...body, stream: !1 },
      failedResponseHandler: ollamaFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(baseOllamaResponseSchema2),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    return {
      ...this.responseProcessor.processGenerateResponse(response),
      request: { body: JSON.stringify(body) },
      response: {
        modelId: this.modelId,
        timestamp: /* @__PURE__ */ new Date,
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    let { args: body, warnings } = await this.prepareRequest(options), { responseHeaders, value: response } = await postJsonToApi({
      url: this.config.url({
        path: "/chat",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: { ...body, stream: !0 },
      failedResponseHandler: ollamaFailedResponseHandler,
      successfulResponseHandler: createNdjsonStreamResponseHandler(baseOllamaResponseSchema2),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    }), streamProcessor = new OllamaStreamProcessor(this.config);
    return {
      stream: response.pipeThrough(streamProcessor.createTransformStream(warnings, options)),
      request: { body },
      response: { headers: responseHeaders },
      warnings
    };
  }
  async prepareRequest(options) {
    return await this.requestBuilder.buildRequest({
      modelId: this.modelId,
      ...options
    });
  }
};
function createOllama(options = {}) {
  var _a21, _b16;
  let baseURL = (_a21 = withoutTrailingSlash(options.baseURL)) != null ? _a21 : "http://127.0.0.1:11434/api", providerName = (_b16 = options.name) != null ? _b16 : "ollama", getHeaders = () => ({
    "Ollama-Organization": options.organization,
    "Ollama-Project": options.project,
    ...options.headers
  }), createCompletionModel = (modelId, settings = {}) => new OllamaCompletionLanguageModel(modelId, settings, {
    provider: `${providerName}.completion`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  }), createEmbeddingModel = (modelId, settings = {}) => new OllamaEmbeddingModel(modelId, settings, {
    provider: `${providerName}.embedding`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  }), createLanguageModel = (modelId) => {
    if (new.target)
      throw Error("The Ollama model function cannot be called with the new keyword.");
    return createResponsesModel(modelId);
  }, createResponsesModel = (modelId) => {
    return new OllamaResponsesLanguageModel(modelId, {
      provider: `${providerName}.responses`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
  }, provider = function(modelId) {
    return createLanguageModel(modelId);
  };
  return provider.specificationVersion = "v3", provider.languageModel = createLanguageModel, provider.chat = createLanguageModel, provider.completion = createCompletionModel, provider.embedding = createEmbeddingModel, provider.textEmbedding = createEmbeddingModel, provider.textEmbeddingModel = createEmbeddingModel, provider.embeddingModel = createEmbeddingModel, provider.imageModel = (modelId) => {
    throw new NoSuchModelError({
      modelId,
      modelType: "imageModel",
      message: "Image generation is unsupported with Ollama"
    });
  }, provider;
}
var ollama = createOllama();
export {
  exports_external as z,
  tool,
  streamText,
  stepCountIs,
  generateText,
  createPerplexity,
  createOpenAI,
  createOllama,
  createMistral,
  xai as createGrok,
  createGoogleGenerativeAI,
  createCerebras,
  createAnthropic
};
